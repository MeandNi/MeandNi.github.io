<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joker&#39;s Blog</title>
  
  <subtitle>个人分享博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://meandni.com/"/>
  <updated>2019-01-13T11:02:11.117Z</updated>
  <id>https://meandni.com/</id>
  
  <author>
    <name>Joker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实战中学习Flutter2：打造一款通用的APPUI结构，从此走上人生巅峰！</title>
    <link href="https://meandni.com/2019/01/12/flutter-practice2/"/>
    <id>https://meandni.com/2019/01/12/flutter-practice2/</id>
    <published>2019-01-12T13:43:40.000Z</published>
    <updated>2019-01-13T11:02:11.117Z</updated>
    
    <content type="html"><![CDATA[<p>打造一款通用的AppUI结构，包括登录、注册、首页及各中共用部分，最后能够构成一款完整的APP，目前还在完善，希望大家一起加入。</p><p>引用我在<a href="https://github.com/MeandNi/AndroidEfficientBaseUtils" target="_blank" rel="noopener">AndroidEfficientBaseUtils</a>说过的话，相当于给你一个完完整整地漂亮的盒子，你只需把自己需要的东西放进去就好。而且这是跨平台的呀。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/MeandNi/flutter_commonApp/raw/master/show/appshow.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="结构清单"><a href="#结构清单" class="headerlink" title="结构清单"></a>结构清单</h2><ul><li style="list-style: none"><input type="checkbox" checked> Welcome - 首页</li><li style="list-style: none"><input type="checkbox" checked> Login - 登录</li><li style="list-style: none"><input type="checkbox"> Register - 注册</li><li style="list-style: none"><input type="checkbox" checked> Home - 首页</li><li style="list-style: none"><input type="checkbox"> Personal information - 个人信息</li><li style="list-style: none"><input type="checkbox"> ….</li></ul><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><ul><li>Yangjiakang, <a href="https://github.com/MeandNi/flutter_commonApp" target="_blank" rel="noopener"><strong>MeandNi</strong></a></li><li><p>….</p></li><li><p>相信这一套结构可以适用于大部分App（当然自己要根据需求修改。），这里追求的是通用而不是花哨的效果。</p></li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/MeandNi/flutter_commonApp" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打造一款通用的AppUI结构，包括登录、注册、首页及各中共用部分，最后能够构成一款完整的APP，目前还在完善，希望大家一起加入。&lt;/p&gt;
&lt;p&gt;引用我在&lt;a href=&quot;https://github.com/MeandNi/AndroidEfficientBaseUtils
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记3——7种垃圾收集器</title>
    <link href="https://meandni.com/2019/01/11/jvm_note3/"/>
    <id>https://meandni.com/2019/01/11/jvm_note3/</id>
    <published>2019-01-11T03:50:40.000Z</published>
    <updated>2019-01-11T04:32:37.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://meandni.com/2019/01/05/winter_vacation/">2019大三的寒假计划</a>——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳实践》，这一系列是通过对原文的拜读与自己理解加上网络上的资料文章整理出的读书笔记。</p></blockquote><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。接下来讨论的收集器基于JDK1.7 Update 14 之后的HotSpot虚拟机（在此版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），该虚拟机包含的所有收集器如下图所示：</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/e8793494/27df7474.jpg" width=""> </div><br></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul><li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li></ul><h4 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h4><p>吞吐量就是<strong>CPU用于运行用户代码的时间</strong>与<strong>CPU总消耗时间</strong>的比值，即</p><p><strong>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</strong></p><p>假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><h4 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h4><ul><li><strong>新生代GC（Minor GC）</strong>：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。具体原理见上一篇文章。</li><li><strong>老年代GC（Major GC / Full GC）</strong>：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h1 id="各收集器阐述"><a href="#各收集器阐述" class="headerlink" title="各收集器阐述"></a>各收集器阐述</h1><h4 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/5c861f07/b1ac068e.jpg" width=""> </div><br></p><p>Serial 翻译为串行，也就是说它以串行的方式执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 模式下的默认新生代收集器，因为在该应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><h4 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/a5c6e277/481e1ca1.jpg" width=""> </div><br></p><p>它是 Serial 收集器的多线程版本。</p><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p><h4 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h4><p>与 ParNew 一样是多线程收集器。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h4 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/14f72c5c/367020d3.jpg" width=""> </div><br></p><p>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><h4 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/2d1989e5/6e965e83.jpg" width=""> </div><br></p><p>是 Parallel Scavenge 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h4 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/14f72c5c/367020d3.jpg" width=""> </div><br></p><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h4 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/400d294e/1d022e13.png" width="600"> </div><br></p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/5393369d/5f8cbd42.png" width="600"> </div><br></p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/ce8ef9fc/10c8999f.jpg" width=""> </div><br></p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">收集器</th><th style="text-align:center">串行、并行or并发</th><th style="text-align:center">新生代/老年代</th><th style="text-align:center">算法</th><th style="text-align:center">目标</th><th>适用场景</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><strong>Serial</strong></td><td style="text-align:center">串行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td>单CPU环境下的Client模式</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>Serial Old</strong></td><td style="text-align:center">串行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">响应速度优先</td><td>单CPU环境下的Client模式、CMS的后备预案</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>ParNew</strong></td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td>多CPU环境时在Server模式下与CMS配合</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>Parallel Scavenge</strong></td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>Parallel Old</strong></td><td style="text-align:center">并行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>CMS</strong></td><td style="text-align:center">并发</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-清除</td><td style="text-align:center">响应速度优先</td><td>集中在互联网站或B/S系统服务端上的Java应用</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>G1</strong></td><td style="text-align:center">并发</td><td style="text-align:center">both</td><td style="text-align:center">标记-整理+复制算法</td><td style="text-align:center">响应速度优先</td><td>面向服务端应用，将来替换CMS</td><td></td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank" rel="noopener">CS-Note——Java：java虚拟机</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://meandni.com/2019/01/05/winter_vacation/&quot;&gt;2019大三的寒假计划&lt;/a&gt;——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="读书" scheme="https://meandni.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="jvm" scheme="https://meandni.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解java虚拟机》笔记2——GC算法与内存分配策略</title>
    <link href="https://meandni.com/2019/01/11/jvm_note2/"/>
    <id>https://meandni.com/2019/01/11/jvm_note2/</id>
    <published>2019-01-11T03:16:01.000Z</published>
    <updated>2019-01-11T04:34:28.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://meandni.com/2019/01/05/winter_vacation/">2019大三的寒假计划</a>——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳实践》，这一系列是通过对原文的拜读与自己理解加上网络上的资料文章整理出的读书笔记。</p></blockquote><p>说起<strong>垃圾收集（Garbage Collection, GC）</strong>，想必大家都不陌生，它是JVM实现里非常重要的一环，JVM成熟的内存动态分配与回收技术使Java（当然还有其他运行在JVM上的语言，如Scala等）程序员在提升开发效率上获得了惊人的便利。理解GC，对于理解JVM和Java语言有着非常重要的作用。并且当我们需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，只有深入理解GC和内存分配，才能对这些“自动化”的技术实施必要的监控和调节。</p><p>在Java的运行时数据区中，程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，随线程而生，随线程而灭，在方法结束或线程结束时，内存自然就跟着回收了，不需要过多考虑回收的问题。而<strong>Java堆</strong>和<strong>方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器关注的是这部分内存，后续讨论的“内存”分配回收也是指这一块，尤其需要注意。</p><p>GC主要回答了以下三个问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>这三个问题的具体解决方案，也就是本文接下来要讲解的内容。</p><h1 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h1><p>在堆里存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，首要的就是确定这些对象中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法是在JVM中被摒弃的一种对象存活判定算法，不过它也有一些知名的应用场景（如Python、FlashPlayer），因此在这里也简单介绍一下。</p><p>用引用计数器判断对象是否存活的过程是这样的：<strong>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。</strong></p><p>引用计数算法的实现简单，判定效率也很高，大部分情况下是一个不错的算法。它没有被JVM采用的原因是<strong>它很难解决对象之间循环引用的问题</strong>。例如以下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * testGC()方法执行后，objA和objB会不会被GC呢？ </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，对象objA 和对象objB都有字段instance，赋值令<code>objA.instance = objB;</code>、<code>objB.instance = objA;</code>，除此之外，这两个对象再无引用。如果JVM采用引用计数算法来管理内存，<strong>这两个对象不可能再被访问，但是他们互相引用着对方，导致它们引用计数不为0，所以引用计数器无法通知GC收集器回收它们</strong>。</p><p>而事实上执行这段代码，objA和objB是可以被回收的，下面一节将介绍JVM实际使用的存活判定算法。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>在主流商用程序语言的实现中，都是通过<strong>可达性分析（tracing GC）</strong>来判定对象是否存活的。此算法的基本思路是：通过一系列的称为<strong>“GC Roots”</strong>的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong>，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是GC Roots 到这个对象不可达）时，则证明此对象时不可用的。用下图来加以说明：</p><center><img src="https://pic.yupoo.com/crowhawk/5d0246eb/0635cbe8.png"></center><p>上图中，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p><p>可以看到，GC Roots在对象图之外，是特别定义的<strong>“起点”</strong>，不可能被对象图内的对象所引用。</p><p>准确地说，<strong>GC Roots其实不是一组对象，而通常是一组特别管理的指向引用类型对象的指针</strong>，这些指针是tracing GC的trace的起点。它们不是对象图里的对象，对象也不可能引用到这些“外部”的指针，这也是tracing GC算法不会出现循环引用问题的基本保证。因此也容易得出，<strong>只有引用类型的变量才被认为是Roots，值类型的变量永远不被认为是Roots</strong>。只有深刻理解引用类型和值类型的内存分配和管理的不同，才能知道为什么root只能是引用类型。</p><p>在Java中，可作为GC Roots的对象包括以下几种：</p><ul><li><strong>虚拟机栈（栈帧中的局部变量表，Local Variable Table）</strong>中引用的对象。</li><li><strong>方法区中<em>类静态属性</em></strong>引用的对象。</li><li><strong>方法区中<em>常量</em></strong>引用的对象。</li><li><strong>本地方法栈中JNI（即一般说的Native方法）</strong>引用的对象。</li></ul><p>看到这里你可能要问，选择这些对象的依据是什么呢？</p><p>可以概括得出，可作为GC Roots的节点主要在<strong>全局性的引用</strong>与<strong>执行上下文</strong>中。要明确的是，tracing gc必须<strong>以当前存活的对象集为Roots</strong>，因此必须选取确定存活的引用类型对象。GC管理的区域是Java堆，<strong>虚拟机栈</strong>、<strong>方法区</strong>和<strong>本地方法栈</strong>不被GC所管理，因此选用这些区域内引用的对象作为GC Roots，是<strong>不会被GC所回收</strong>的。其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是GC roots的一部分。</p><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。在JDK1.2之前，Java中的应用定义跟很传统，如若reference类型的数据引用了一块内存地址，则这块内存代表一个引用，这样一个对象仅有被引用或没有被引用两种状态，对于一些“<strong>食之无味，弃之可惜</strong>”的无法描述。</p><p>JDK1.2之后，Java 提供了四种强度不同的引用类型。</p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来实现弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h4 id="两次标记与-finalize-方法"><a href="#两次标记与-finalize-方法" class="headerlink" title="两次标记与 finalize()方法"></a>两次标记与 finalize()方法</h4><p>即使在可达性分析算法中不可达的对象，也不是一定会死亡的，它们暂时都处于<strong>“缓刑”</strong>阶段，要真正宣告一个对象“死亡”，至少要经历两次标记过程：</p><p>如果对象在进行可达性分析后发现没有与 GC Roots相连接的引用链，那它将会被<strong>第一次标记</strong>并且进行一次筛选，筛选的条件是<strong>此对象是否有必要执行<code>finaliza()</code>方法</strong>。当对象没有覆盖<code>finaliza()</code>方法，或者<code>finaliza()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行<code>finaliza()</code>方法，那么此对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发此方法，但并不承诺会等待它运行结束，原因是：如果一个对象在<code>finaliza()</code>方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能导致F-Queue 队列中的其它对象永久处于等待，甚至导致整个内存回收系统崩溃。</p><p><code>finaliza()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue 队列中的对象进行<strong>第二次小规模的标记</strong>。如果对象想在<code>finaliza()</code>方法中成功拯救自己，<strong>只要重新与引用链上的任何一个对象建立关联即可，例如把自己（this关键字）赋值给某个类变量或者对象的成员变量，这样在第二次标记时它将被移出“即将回收”的集合</strong>；如果对象这时候还没有逃脱，基本上它就真的被回收了。</p><p>值得注意的是，如果代码中有两段一模一样的代码段，执行结果却是一次逃脱成功，一次失败。这是因为任何一个对象的<code>finalize()</code>方法都只会被系统调用一次，如果对象面临下一次回收，它的<code>finalize()</code>方法不会再被执行，因此第二次逃脱行动失败。</p><p>需要说明的是，使用<code>finalize()</code>方法来“拯救”对象是不值得提倡的，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做的一个妥协。<strong>它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</strong><code>finalize()</code>能做的工作，使用<code>try-finally</code>或者其它方法都更适合、及时，所以笔者建议大家可以忘掉此方法存在。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>很多人认为方法区没有垃圾回收，Java虚拟机规范中确实说过不要求，而且在方法区中进行垃圾收集的“性价比”较低：在堆中，尤其是新生代，常规应用进行一次垃圾收集可以回收70%~95%的空间，而方法区的效率远低于此。在JDK 1.8中，JVM摒弃了永久代，用元空间来作为方法区的实现，下面介绍的将是元空间的垃圾回收。</p><p>元空间的内存管理由<strong>元空间虚拟机</strong>来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。<strong>在元空间中，类和其元数据的生命周期</strong>和<strong>其对应的类加载器</strong>是相同的。话句话说，<strong>只要类加载器存活，其加载的类的元数据也是存活的</strong>，因而不会被回收掉。</p><p>我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，<strong>每一个<em>类加载器的存储区域</em>都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。</strong>当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>本节将介绍几种垃圾收集算法的思想及其发展过程，具体的实现将在稍后介绍。</p><h4 id="标记－清除（Mark-Sweep）算法"><a href="#标记－清除（Mark-Sweep）算法" class="headerlink" title="标记－清除（Mark-Sweep）算法"></a>标记－清除（Mark-Sweep）算法</h4><p><strong>标记－清除（Mark-Sweep）</strong>算法是最基础的垃圾收集算法，后续的收集算法都是基于它的思路并对其不足进行改进而得到的。顾名思义，算法分成“标记”、“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程在前一节讲述对象标记判定时已经讲过了。</p><p>标记－清除算法的不足主要有以下两点：</p><ul><li><strong>空间问题</strong>，标记清除之后会产生大量不连续的<strong>内存碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li><li><strong>效率问题</strong>，因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。</li></ul><p>标记－清除算法的执行过程如下图所示：</p><center><img src="https://pic.yupoo.com/crowhawk/5a3494ae/efc6204a.png"></center><h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h4><p>为了解决标记-清除算法的效率问题，一种称为<strong>“复制”（Copying）</strong>的收集算法出现了，思想为：它<strong>将可用内存按容量分成大小相等的两块</strong>，每次只使用其中的一块。<strong>当这一块内存用完，就将还存活着的对象复制到另一块上面</strong>，然后再把已使用过的内存空间一次清理掉。</p><p>这样做使得<strong>每次都是对整个半区进行内存回收</strong>，内存分配时也就<strong>不用考虑内存碎片</strong>等复杂情况，只要<strong>移动堆顶指针，按顺序分配内存</strong>即可，实现简单，运行高效。只是这种算法的代价是<strong>将内存缩小为原来的一半</strong>，代价可能过高了。复制算法的执行过程如下图所示：</p><center><img src="https://pic.yupoo.com/crowhawk/62b8a3a8/f1cada8a.png"></center><big><strong>Minor GC与复制算法</strong></big><p><strong>现在的商业虚拟机都使用复制算法来回收新生代。</strong>新生代的GC又叫<strong>“Minor GC”</strong>，IBM公司的专门研究表明：新生代中的对象98%是<strong>“朝生夕死”</strong>的，所以Minor GC非常频繁，一般回收速度也比较快，同时<strong>“朝生夕死”</strong>的特性也使得Minor GC使用复制算法时不需要按照1:1的比例来划分新生代内存空间。</p><big><strong>Minor GC过程</strong></big><p>事实上，新生代将内存分为<strong>一块较大的Eden空间</strong>和<strong>两块较小的Survivor空间（From Survivor和To Survivor）</strong>，<strong>每次Minor GC都使用Eden和From Survivor</strong>，当回收时，<strong>将Eden和From Survivor中还存活着的对象都一次性地复制到另外一块To Survivor空间上</strong>，最后清理掉Eden和刚使用的Survivor空间。<strong>一次Minor GC结束的时候</strong>，<strong>Eden</strong>空间和<strong>From Survivor</strong>空间都是空的，而<strong>To Survivor</strong>空间里面存储着存活的对象。<strong>在下次MinorGC的时候</strong>，两个Survivor空间交换他们的标签，现在是空的<strong>“From” Survivor</strong>标记成为<strong>“To”</strong>，<strong>“To” Survivor</strong>标记为<strong>“From”</strong>。因此，在MinorGC结束的时候，Eden空间是空的，两个Survivor空间中的一个是空的，而另一个存储着存活的对象。</p><p>HotSpot虚拟机默认的<strong>Eden : Survivor</strong>的比例是<strong>8 : 1</strong>，由于一共有两块Survivor，所以<strong>每次新生代中可用内存空间为整个新生代容量的90%（80%＋10%）</strong>，只有10%的容量会被“浪费”。</p><big><strong>分配担保</strong></big><p>上文说的98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，<strong>当Survivor空间不够用时</strong>，需要依赖<strong>老年代内存</strong>进行<strong>分配担保（Handle Promotion）</strong>。如果另外一块Survivor上没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><h5 id="标记－整理（Mark-Compact）算法"><a href="#标记－整理（Mark-Compact）算法" class="headerlink" title="标记－整理（Mark-Compact）算法"></a>标记－整理（Mark-Compact）算法</h5><p>复制算法在对象存活率较高时要进行较多的复制操作，效率将会变低。更关键的是：如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在<strong>老年代一般不能直接选用复制算法</strong>。</p><p>根据老年代的特点，<strong>标记－整理（Mark-Compact）</strong>算法被提出来，主要思想为：此算法的标记过程与<strong>标记－清除</strong>算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</strong>具体示意图如下所示：</p><center><img src="https://pic.yupoo.com/crowhawk/d046244a/d3d3277f.png"></center><h5 id="分代收集（Generational-Collection）算法"><a href="#分代收集（Generational-Collection）算法" class="headerlink" title="分代收集（Generational Collection）算法"></a>分代收集（Generational Collection）算法</h5><p>当前商业虚拟机的垃圾收集都采用<strong>分代收集（Generational Collection）算法</strong>，此算法相较于前几种没有什么新的特征，主要思想为：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法：</p><ul><li><strong>新生代</strong><br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</li><li><strong>老年代</strong><br>在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>“标记-清除”</strong>或<strong>“标记-整理”</strong>算法来进行回收。</li></ul><h1 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h1><p>前面两大节主要从理论上介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。</p><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>从可达性分析中<strong>从GC Roots节点找引用链</strong>这个操作为例，可作为GC Roots的节点主要在<strong>全局性的引用</strong>（例如常量或类静态属性）与<strong>执行上下文</strong>（例如栈帧中的局部变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p><big><strong>GC停顿（”Stop The World”）</strong></big><p>另外，可达性分析工作必须在一个<strong>能确保一致性的快照</strong>中进行——这里<strong>“一致性”</strong>的意思是指<strong>在整个分析期间整个执行系统看起来就像被冻结在某个时间点上</strong>，不可以出现分析过程中对象引用关系还在不断变化的情况，这是保证分析结果准确性的基础。这点是导致GC进行时必须<strong>停顿所有Java执行线程</strong>（Sun将这件事情称为<strong>“Stop The World”</strong>）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><big><strong>准确式GC与OopMap</strong></big><p>由于目前的主流Java虚拟机使用的都是<strong>准确式GC（即使用准确式内存管理，虚拟机可用知道内存中某个位置的数据具体是什么类型）</strong>，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把<strong>对象内什么偏移量上是什么类型的数据</strong>计算出来，在JIT编译过程中，也会在特定的位置记录下<strong>栈和寄存器中哪些位置是引用</strong>。这样，GC在扫描时就可以直接得知这些信息了。</p><h4 id="安全点（Safepoint）——进行GC时程序停顿的位置"><a href="#安全点（Safepoint）——进行GC时程序停顿的位置" class="headerlink" title="安全点（Safepoint）——进行GC时程序停顿的位置"></a>安全点（Safepoint）——进行GC时程序停顿的位置</h4><p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，<strong>如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</strong></p><p>为此，HotSpot选择不为每条指令都生成OopMap，而是只在“特定的位置”记录这些信息，这些位置便被称为<strong>安全点（Safepoint）</strong>。也就是说，<strong>程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</strong>。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序<strong>“是否具有让程序长时间执行的特征”</strong>为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是<strong>指令序列复用</strong>，例如<strong>方法调用</strong>、<strong>循环跳转</strong>、<strong>异常跳转</strong>等，所以具有这些功能的指令才会产生Safepoint。</p><p>对于Sefepoint，另一个需要考虑的问题是如何<strong>在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来</strong>。这里有两种方案可供选择：</p><ul><li><strong>抢先式中断（Preemptive Suspension）</strong><br>抢先式中断不需要线程的执行代码主动去配合，<strong>在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。</strong>现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</li><li><strong>主动式中断（Voluntary Suspension）</strong>：<br>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地<strong>设置一个标志</strong>，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外<strong>再加上创建对象需要分配内存的地方</strong>。</li></ul><h4 id="安全区域（Safe-Region）"><a href="#安全区域（Safe-Region）" class="headerlink" title="安全区域（Safe Region）"></a>安全区域（Safe Region）</h4><p><strong>Safepoint</strong>机制保证了<strong>程序执行时</strong>，在不太长的时间内就会遇到可进入GC的Safepoint。但是，<strong>程序“不执行”的时候（如线程处于Sleep状态或Blocked状态）</strong>，这时线程无法响应JVM的中断请求，“走到”安全的地方去中断挂起，这时候就需要<strong>安全区域（Safe Region）</strong>来解决。</p><p>安全区域是指<strong>在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</strong>我们也可以把Safe Region看做是被扩展了的Safepoint。</p><p>在线程执行到Safe Region中的代码时，首先<strong>标识自己已经进入了Safe Region</strong>，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。<strong>在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程）</strong>，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><p>Java的自动内存管理最终可以归结为自动化地解决了两个问题：</p><ul><li><strong>给对象分配内存</strong></li><li><strong>回收分配给对象的内存</strong></li></ul><p>对象的内存分配通常是在堆上分配（除此以外还有可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是固定的，实际取决于垃圾收集器的具体组合以及虚拟机中与内存相关的参数的设置。至于内存回收策略，在上文已经描述得很详尽了。</p><p>下面以使用Serial/Serial Old收集器（将在下一篇文章中讲解）为例，介绍内存分配的策略。</p><h4 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h4><p>大多数情况下，对象在新生代的Eden区中分配。<strong>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</strong></p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串以及数组。大对象对虚拟机的内存分配来说是一个坏消息（尤其是遇到朝生夕灭的“短命大对象”，写程序时应避免），<strong>经常出现大对象容易导致内存还有不少空间时就提前触发GC以获取足够的连续空间来安置它们</strong>。</p><p>虚拟机提供了一个<strong>-XX:PretenureSizeThreshold</strong>参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是<strong>避免在Eden区及两个Survivor区之间发生大量的内存复制</strong>（新生代采用复制算法回收内存）。</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器</strong>。<strong>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</strong>对象晋升老年代的年龄阈值，可以通过参数<strong>-XX:MaxTenuringThreshold</strong>设置。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了<strong>MaxTenuringThreshold</strong>才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无须等到<strong>MaxTenuringThreshold</strong>中要求的年龄。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p><strong>在发生Minor GC之前</strong>，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看<strong>HandlePromotionFailure</strong>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者<strong>HandlePromotionFailure</strong>设置不允许冒险，那这时也要改为进行一次<strong>Full GC</strong>。</p><p>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此<strong>当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</strong>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p><p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致<strong>担保失败（Handle Promotion Failure）</strong>。如果出现了<strong>HandlePromotionFailure</strong>失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将<strong>HandlePromotionFailure</strong>开关打开，避免Full GC过于频繁。</p><h1 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h1><p>对于Minor GC，其触发条件非常简单，当Eden区空间满时，就将触发一次Minor GC。而Full GC则相对复杂，因此本节我们主要介绍Full GC的触发条件。</p><h4 id="调用System-gc"><a href="#调用System-gc" class="headerlink" title="调用System.gc()"></a>调用System.gc()</h4><p>此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过<strong>-XX:+ DisableExplicitGC</strong>来禁止RMI调用System.gc()。</p><h4 id="老年代空间不足"><a href="#老年代空间不足" class="headerlink" title="老年代空间不足"></a>老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的<strong>大对象直接进入老年代</strong>、<strong>长期存活的对象进入老年代</strong>等，当执行Full GC后空间仍然不足，则抛出如下错误：<br><code>Java.lang.OutOfMemoryError: Java heap space</code><br>为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p><h4 id="空间分配担保失败"><a href="#空间分配担保失败" class="headerlink" title="空间分配担保失败"></a>空间分配担保失败</h4><p>前文介绍过，使用复制算法的Minor GC需要老年代的内存空间作担保，如果出现了<strong>HandlePromotionFailure</strong>担保失败，则会触发Full GC。</p><h4 id="JDK-1-7及以前的永久代空间不足"><a href="#JDK-1-7及以前的永久代空间不足" class="headerlink" title="JDK 1.7及以前的永久代空间不足"></a>JDK 1.7及以前的永久代空间不足</h4><p>在JDK 1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<br><code>java.lang.OutOfMemoryError: PermGen space</code><br>为避免PermGen占满造成Full GC现象，可采用的方法为增大PermGen空间或转为使用CMS GC。</p><p>在JDK 1.8中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种Full GC触发的可能性。</p><h4 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h4><p>执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC），便会报<code>Concurrent Mode Failure</code>错误，并触发Full GC。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文简要地介绍了HotSpot虚拟机如何去发起内存回收的问题，也解答了文章开头提出的三个问题中的前两个——“哪些内存需要回收”和“何时回收”，同时对于第三个问题——“如何回收”，在原理层面作出了解答。在下一篇文章中，笔者将通过介绍几种具体的垃圾收集器，来更深入地回答第三个问题。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank" rel="noopener">CS-Note——Java：java虚拟机</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/index.html" target="_blank" rel="noopener">JVM 垃圾回收器工作原理及使用实例介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://meandni.com/2019/01/05/winter_vacation/&quot;&gt;2019大三的寒假计划&lt;/a&gt;——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="读书" scheme="https://meandni.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="jvm" scheme="https://meandni.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解java虚拟机》笔记1——Java内存区域与Java对象</title>
    <link href="https://meandni.com/2019/01/10/jvm_note1/"/>
    <id>https://meandni.com/2019/01/10/jvm_note1/</id>
    <published>2019-01-10T03:02:02.000Z</published>
    <updated>2019-01-11T04:32:18.840Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://meandni.com/2019/01/05/winter_vacation/">2019大三的寒假计划</a>——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳实践》，这一系列是通过对原文的拜读与自己理解加上网络上的资料文章整理出的读书笔记。</p></blockquote><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JVM载执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。具体如下图所示：（其中程序计数器、Java虚拟机栈、本地方法栈为线程私有；Java堆、方法区位线程共享的内存区域。）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.yupoo.com/crowhawk/3d24df02/776c8d55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。在虚拟机概念模型中，<strong>字节码解释器</strong>工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>程序计数器是一块<strong>“线程私有”</strong>的内存，如上文的图所示，每条线程都有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。这样设计使得在多线程环境下，线程切换后能恢复到正确的执行位置。</p><p>如果线程正在执行的是一个<strong>Java方法</strong>，这个计数器记录的是正在执行的<strong>虚拟机字节码指令的地址</strong>；若执行的是<strong>Native方法</strong>，则<strong>计数器为空（Undefined）</strong>（因为对于Native方法而言，它的方法体并不是由Java字节码构成的，自然无法应用上述的“字节码指令的地址”的概念）。程序计数器也是唯一一个在Java虚拟机规范中<strong>没有</strong>规定任何<strong>OutOfMemoryError</strong>情况的内存区域。</p><h4 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h4><p><strong>Java虚拟机栈（Java Virtual Machine Stacks）</strong>描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）</strong>，栈帧中存储着<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。<strong>每一个方法从调用直至执行完成的过程，会对应一个栈帧在虚拟机栈中入栈到出栈的过程。</strong>与程序计数器一样，Java虚拟机栈也是<strong>线程私有</strong>的。</p><p>函数的调用有完美的嵌套关系——调用者的生命期总是长于被调用者的生命期，并且后者在前者的之内。这样，被调用者的局部信息所占空间的分配总是后于调用者的（后入），而其释放则总是先于调用者的（先出），所以正好可以满足栈的LIFO顺序，选用栈这种数据结构来实现调用栈是一种很自然的选择。</p><p><strong>局部变量表</strong>中存放了编译期可知的各种：</p><ul><li><strong>基本数据类型</strong>(boolen、byte、char、short、int、 float、 long、double）</li><li><strong>对象引用</strong>（reference类型，它不等于对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</li><li><strong>returnAddress类型</strong>（指向了一条字节码指令的地址）</li></ul><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>Java虚拟机规范中对这个区域规定了两种异常状况：</p><ul><li><strong>StackOverflowError</strong>：线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常。</li><li><strong>OutOfMemoryError</strong>：当可动态扩展的虚拟机栈在扩展时无法申请到足够的内存，就会抛出该异常。</li></ul><h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><p><strong>本地方法栈（Native Method Stack）</strong>与Java虚拟机栈作用很相似，它们的区别在于虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>在虚拟机规范中对本地方法栈中使用的语言、方式和数据结构并无强制规定，因此具体的虚拟机可实现它。甚至<strong>有的虚拟机（Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一</strong>。与虚拟机一样，本地方法栈会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常。</p><h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4><p>对于大多数应用而言，<strong>Java堆（Heap）</strong>是Java虚拟机所管理的内存中最大的一块，它<strong>被所有线程共享的</strong>，在虚拟机启动时创建。此内存区域<strong>唯一的目的</strong>是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存，且每次分配的空间是<strong>不定长</strong>的。在Heap 中分配一定的内存来保存对象实例，实际上只是保存<strong>对象实例的属性值</strong>，<strong>属性的类型</strong>和<strong>对象本身的类型标记</strong>等，<strong>并不保存对象的方法（方法是指令，保存在Stack中）</strong>,在Heap 中分配一定的内存保存对象实例和对象的序列化比较类似。对象实例在Heap 中分配好以后，需要<strong>在Stack中保存一个4字节的Heap 内存地址</strong>，用来定位该对象实例在Heap 中的位置，便于找到该对象实例。</p><p>Java虚拟机规范中描述道：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都在堆上分配的定论也并不<strong>“绝对”</strong>了。</p><p>Java堆是垃圾收集器管理的主要区域，因此也被称为<strong>“GC堆（Garbage Collected Heap）”</strong>。从内存回收的角度看内存空间可如下划分：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.yupoo.com/crowhawk/5cf46998/fe5079d3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ul><li><strong>新生代（Young）</strong>： 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。新生代又可细分为<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>，默认比例为8:1:1。它们的具体作用将在下一篇文章讲解GC时介绍。</li><li><strong>老年代（Tenured/Old）</strong>：在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</li><li><strong>永久代（Perm）</strong>：永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</li></ul><p>其中<strong>新生代和老年代组成了Java堆的全部内存区域</strong>，而<strong>永久代不属于堆空间，它在JDK 1.8以前被Sun HotSpot虚拟机用作方法区的实现</strong>，关于方法区的具体内容将在稍后介绍。</p><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域。<strong>Object Class Data(类定义数据)</strong>是存储在方法区的，此外，<strong>常量</strong>、<strong>静态变量</strong>、<strong>JIT编译后的代码</strong>也存储在方法区。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 <strong>Non-Heap</strong>。</p> <big><strong>JDK 1.8以前的永久代（PermGen）</strong></big><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集，也就是说，Java虚拟机规范只是规定了方法区的概念和它的作用，并没有规定如何去实现它。<strong>对于JDK 1.8之前的版本，HotSpot虚拟机设计团队选择把GC分代收集扩展至方法区，即用永久代来实现方法区</strong>，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他的虚拟机（如<strong>Oracle JRockit</strong>、<strong>IBM J9</strong>等）来说是不存在永久代的概念的。</p><p>如果运行时有大量的类产生，可能会导致方法区被填满，直至溢出。常见的应用场景如：</p><ul><li>Spring和ORM框架使用CGLib操纵字节码对类进行增强，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。</li><li>大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）。</li><li>基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）。<br>……</li></ul><p>这些都会导致方法区溢出，报出<code>java.lang.OutOfMemoryError: PermGen space</code>。</p><big><strong>JDK 1.8的元空间（Metaspace）—— 书中没有的内容</strong></big><p>在JDK 1.8中，HotSpot虚拟机设计团队为了促进<strong>HotSpot</strong>与 <strong>JRockit</strong>的融合，修改了方法区的实现，移除了永久代，选择使用<strong>本地化的内存空间</strong>（而不是JVM的内存空间）存放类的元数据，这个空间叫做<strong>元空间（Metaspace）</strong>。</p><p>做了这个改动以后，<code>java.lang.OutOfMemoryError: PermGen</code>的空间问题将不复存在，并且不再需要调整和监控这个内存空间。且虚拟机需要为方法区设计额外的GC策略：如果类元数据的空间占用达到参数<strong>“MaxMetaspaceSize”</strong>设置的值，将会触发对死亡对象和类加载器的垃圾回收。 为了限制垃圾回收的频率和延迟，适当的监控和调优<strong>元空间</strong>是非常有必要的。元空间过多的垃圾收集可能表示类、类加载器内存泄漏或对你的应用程序来说空间太小了。</p><p>元空间的内存管理由<strong>元空间虚拟机</strong>来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。<strong>在元空间中，类和其元数据的生命周期</strong>和<strong>其对应的类加载器</strong>是相同的。话句话说，<strong>只要类加载器存活，其加载的类的元数据也是存活的</strong>，因而不会被回收掉。</p><p>我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，<strong>每一个<em>类加载器的存储区域</em>都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。</strong>当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p><p><strong>元空间虚拟机</strong>负责元空间的分配，其采用的形式为<strong>组块分配</strong>。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个<strong>全局的空闲组块列表</strong>。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块<strong>是线性分配（指针碰撞分配形式）</strong>。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</p><center><img src="https://pic.yupoo.com/crowhawk/cdaea117/7bdf00c4.png"></center><p>上图展示的是虚拟内存映射区域如何进行元组块的分配。类加载器1和3表明使用了反射或者为匿名类加载器，他们使用了特定大小组块。 而类加载器2和4根据其内部条目的数量使用小型或者中型的组块。</p><big><strong>运行时常量池（Runtime Constant Pool）</strong></big><p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。<strong>Class文件</strong>中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池（Constant Pool Table）</strong>，用于存放编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后进入方法区的运行时常量池存放</strong>。</p><p>Java虚拟机对Class文件每一部分（自然包括常量池）的格式有严格规定，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。但<strong>对于运行时常量池，Java虚拟机规范没有做任何有关细节的要求</strong>，不同的提供商实现的虚拟机可以按照自己的需求来实现此内存区域。不过一般而言，除了保存<strong>Class文件中的描述符号引用</strong>外，还会把<strong>翻译出的直接引用</strong>也存储在运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译器才能产生，也就是<strong>并非置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</strong>，此特性被开发人员利用得比较多的便是String类的<code>intern()</code>方法。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p><strong>直接内存（Direct Memory）</strong>并不是虚拟机<strong>运行时数据区</strong>的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁运用，而却可能导致<strong>OutOfMemoryError</strong>异常出现，所以这里放到一起讲解。</p><p>以<strong>NIO（New Input/Output）</strong>类为例，NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能避免在Java堆和Native堆中来回复制数据，在一些场景里显著提高性能。</p><p>本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，还是会受到本机总内存（包括RAM以及SWAP区或分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现<strong>OutOfMemoryError</strong>异常。</p><h1 id="HotSpot中的对象"><a href="#HotSpot中的对象" class="headerlink" title="HotSpot中的对象"></a>HotSpot中的对象</h1><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>Java的对象创建大致有如下四种方式：</p><ul><li><strong>new关键字</strong><br>这应该是我们最常见和最常用最简单的创建对象的方式。</li><li><strong>使用<code>newInstance()</code>方法</strong><br>这里包括<strong>Class</strong>类的<code>newInstance()</code>方法和<strong>Constructor</strong>类的<code>newInstance()</code>方法（前者其实也是调用的后者）。</li><li><strong>使用<code>clone()</code>方法</strong><br>要使用<code>clone()</code>方法我们必须实现实现<strong>Cloneable</strong>接口，用<code>clone()</code>方法创建对象并不会调用任何构造函数。即我们所说的<strong>浅拷贝</strong>。</li><li><strong>反序列化</strong><br>要实现反序列化我们需要让我们的类实现<strong>Serializable</strong>接口。当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。即我们所说的<strong>深拷贝</strong>。</li></ul><p>上面的四种创建对象的方法除了第一种使用new指令之外，其他三种都是使用<strong>invokespecial(构造函数的直接调用)</strong>。这里我们只说new创建对象的方式，关于invokespecial的内容将在后续文章中介绍。下面我们来看看当虚拟机遇到new指令的时候对象是如何创建的。</p><big><strong>1. 类加载检查</strong></big><p>虚拟机遇到一条new指令时，首先将去检查<strong>这个指令的参数是否能在常量池中定位到一个类的符号引用</strong>，并且检查<strong>这个符号引用代表的类是否已被加载、解析和初始化过的</strong>，如果没有，则必须先执行相应的类加载过程，关于类加载机制和类加载器的详细内容将在后续文章中介绍。</p><big><strong>2. 分配内存</strong></big><p>在类加载检查通过后，虚拟机就将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定在下一节对象内存布局时再详细讲解），为对象分配空间的任务具体便等同于<strong>从Java堆中划出一块大小确定的内存空间</strong>，可以分如下两种情况讨论：</p><ul><li><strong>Java堆中内存绝对规整</strong><br>所有用过的内存都被放在一边，空闲的内存被放在另一边，<strong>中间放着一个指针作为分界点的指示器</strong>，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为<strong>“指针碰撞”（Bump The Pointer）</strong>。</li><li><strong>Java堆中的内存不规整</strong><br>已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须<strong>维护一个列表，记录哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>“空闲列表”（Free List）</strong>。</li></ul><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的<strong>垃圾收集器是否带有压缩整理功能</strong>决定。因此在使用Serial、ParNew等带<strong>Compact</strong>过程的收集器时，系统采用的分配算法是<strong>指针碰撞</strong>，而使用CMS这种基于<strong>Mark-Sweep</strong>算法的收集器时（说明一下，CMS收集器可以通过UseCMSCompactAtFullCollection或CMSFullGCsBeforeCompaction来整理内存），就通常采用<strong>空闲列表</strong>。关于垃圾收集器的具体内容将在下一篇文章中介绍。</p><p>除如何划分可用空间之外，另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也<strong>并非线程安全</strong>的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。解决这个问题有如下两个方案：</p><ul><li><strong>对分配内存空间的动作进行同步</strong><br>实际上虚拟机是采用<strong>CAS</strong>配上<strong>失败重试</strong>的方式保证更新操作的原子性。</li><li><strong>把内存分配的动作按照线程划分在不同的空间之中进行</strong><br>即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲（TLAB ，Thread Local Allocation Buffer）</strong>，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过<strong>-XX:+/-UseTLAB</strong>参数来设定。</li></ul><big><strong>3. 初始化</strong></big><p>内存分配完成之后，虚拟机需要<strong>将分配到的内存空间都初始化为零值（不包括对象头）</strong>，如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。</p><big><strong>4. 设置对象头</strong></big><p>接下来，虚拟机要<strong>设置对象的信息</strong>（如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息）并存放在对象的<strong>对象头（Object Header）</strong>中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，在下一节再详细介绍。</p><big><strong>5. 执行<code>&lt;init&gt;</code>方法</strong></big><p>在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，对象创建才刚刚开始——<code>&lt;init&gt;</code>方法还没有执行，所有的字段都还为零值。所以一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着执行<code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong>和<strong>对齐填充（Padding）</strong>。</p><big><strong>1. 对象头</strong></big><p>HotSpot虚拟机的对象头包括两部分信息：</p><ul><li><strong>对象自身的运行时数据 “Mark Word”</strong><br>如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为<strong>“Mark Word”</strong>。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个<strong>非固定的数据结构</strong>以便在极小的空间内存储尽量多的信息，它会<strong>根据对象的状态复用自己的存储空间</strong>。例如在32位的HotSpot虚拟机中对象<strong>未被锁定</strong>的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下图所示：</li></ul><center><img src="https://pic.yupoo.com/crowhawk/4f006175/8be38542.png"></center><ul><li><strong>类型指针</strong><br>类型指针即<strong>对象指向它的类元数据的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说<strong>查找对象的元数据信息并不一定要经过对象本身</strong>，这点我们在下一节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于<strong>记录数组长度</strong>的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</li></ul><big><strong>2. 实例数据</strong></big><p>实例数据是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p><big><strong>3. 对齐填充</strong></big><p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头部分正好似8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>我们的Java程序需要通过<strong>栈上的对象引用（reference）数据（存储在栈上的局部变量表中）</strong>来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面也只规定了是一个指向对象的引用，并没有定义这个引用的具体实现，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><big><strong>1. 使用句柄访问</strong></big><p>如果使用句柄访问的话，<strong>Java堆中</strong>将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了<strong>对象实例数据</strong>与<strong>类型数据</strong>的各自的<strong>具体地址信息</strong>。如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.yupoo.com/crowhawk/af3c02ef/bfd967c5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><big><strong>2. 使用直接指针访问</strong></big><p>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.yupoo.com/crowhawk/5c1acdb8/f5086a4d.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>这两种对象访问方式各有优势，下面分别来谈一谈：</p><ul><li><strong>句柄</strong><br>使用句柄访问的最大好处就是<strong>reference中存储的是稳定的句柄地址</strong>，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时<strong>只会改变句柄中的实例数据指针，而reference本身不需要被修改</strong>。</li><li><strong>直接指针</strong><br>使用直接指针来访问最大的好处就是<strong>速度更快</strong>，它<strong>节省了一次指针定位的时间开销</strong>，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项 非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，<strong>HotSpot是使用直接指针进行对象访问的</strong>，不过在整个软件开发的范围来 看，各种语言、框架中使用句柄来访问的情况也十分常见。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://meandni.com/2019/01/05/winter_vacation/&quot;&gt;2019大三的寒假计划&lt;/a&gt;——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="读书" scheme="https://meandni.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="jvm" scheme="https://meandni.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>2019年寒假计划</title>
    <link href="https://meandni.com/2019/01/05/winter_vacation/"/>
    <id>https://meandni.com/2019/01/05/winter_vacation/</id>
    <published>2019-01-05T09:30:52.000Z</published>
    <updated>2019-01-10T03:22:09.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><ul><li style="list-style: none"><input type="checkbox"> 细读《Android进阶之光》</li><li style="list-style: none"><input type="checkbox"> 细读《Android群英传》</li><li style="list-style: none"><input type="checkbox"> 读《Android开发艺术探索》</li><li style="list-style: none"><input type="checkbox"> 读《Android音视频开发》</li><li style="list-style: none"><input type="checkbox"> 读《深入理解JAVA虚拟机》</li><li style="list-style: none"><input type="checkbox"> 读《kotlin实战》</li><li style="list-style: none"><input type="checkbox"> 读《深度学习入门：基于python的理论与实现》</li><li style="list-style: none"><input type="checkbox"> 重温细读《第一行代码》</li><li style="list-style: none"><input type="checkbox"> 重温细读《The Modern Javascript Tutorial》</li></ul><p>阅读是不能停的，除了以上书籍还有大量技术博客博文代码的阅读。</p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ul><li><p>[ ] Android基础总结（依据第一行代码）</p></li><li><p>[ ] Android进阶总结（依据进阶书籍）</p></li><li><p>[ ] 跟着Google学习架构系列</p></li><li><p>[ ] 5篇以上Flutter实战文章</p></li><li><p>[ ] 待续….</p></li></ul><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><ul><li style="list-style: none"><input type="checkbox"> 剑指Java面试</li><li style="list-style: none"><input type="checkbox"> 全面系统 Python3入门+进阶课程</li><li style="list-style: none"><input type="checkbox"> Python3入门机器学习 经典算法与应用(波波)</li><li style="list-style: none"><input type="checkbox"> FFmpeg音视频核心技术精讲与实战</li><li style="list-style: none"><input type="checkbox"> ……</li></ul><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li style="list-style: none"><input type="checkbox"> android架构组件实战 —— MVP、MVVM</li><li style="list-style: none"><input type="checkbox"> Flutter样例实战</li><li style="list-style: none"><input type="checkbox"> Redux实战</li><li style="list-style: none"><input type="checkbox"> 待续….</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;读书&quot;&gt;&lt;a href=&quot;#读书&quot; class=&quot;headerlink&quot; title=&quot;读书&quot;&gt;&lt;/a&gt;读书&lt;/h2&gt;&lt;ul&gt;
&lt;li style=&quot;list-style: none&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt; 细读《Android进阶之光》
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>实战中学习Flutter1：简易聊天AppUI</title>
    <link href="https://meandni.com/2019/01/04/flutter-practice1/"/>
    <id>https://meandni.com/2019/01/04/flutter-practice1/</id>
    <published>2019-01-04T14:12:57.000Z</published>
    <updated>2019-01-13T10:51:13.683Z</updated>
    
    <content type="html"><![CDATA[<p>希望尽一点点薄力让大家有兴趣学习这门新技术。</p><p>这里暂不介绍环境配置等操作，不了解的朋友请先移步官网：<a href="https://flutter.io/" target="_blank" rel="noopener">https://flutter.io/</a></p><p>开发环境：VS Code</p><p>本套课程适合直接上手，无需各种基础，dart基础也不需要～～</p><h2 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h2><p>废话不多说了，看下这次我们需要开发的UI界面吧：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Flutter.gif" alt="Flutter" title="">                </div>                <div class="image-caption">Flutter</div>            </figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="首先我们替换入口文件lib-main-dart下的代码"><a href="#首先我们替换入口文件lib-main-dart下的代码" class="headerlink" title="首先我们替换入口文件lib/main.dart下的代码"></a>首先我们替换入口文件<code>lib/main.dart</code>下的代码</h3><p>代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>import &#39;package:flutter/material.dart&#39;;</code></p><p> Flutter默认帮我们导入了<code>flutter/material.dart</code>包，这个包也是我们开发FlutterApp必备的包，其实也是一个UI库，其内部实现了大量优秀炫酷的组件(Widgets)，有App结构和导航、按钮、输入框和选择框、对话框、Alert、Panel、动画等等等等Material Design风格的控件。</p><p>   Material Design：熟悉Android开发的童鞋一定非常了解了，是谷歌推出的一套视觉设计语言。其风格简单大方是我个人非常喜欢的设计风格，有兴趣的同学可以学习了解一下<a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material Design官方原版</a>和<a href="http://wiki.jikexueyuan.com/project/material-design/material-design-intro/introduction.html" target="_blank" rel="noopener">Material Design中文翻译版</a>。</p><p>   在本项目中还需倒入其他哦两个库：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/cupertino.dart'</span>;  <span class="comment">//IOS风格适配</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/foundation.dart'</span>; <span class="comment">//flutter核心库之一</span></span><br></pre></td></tr></table></figure></li><li><p><code>void main() =&gt; runApp(new MyApp());</code></p><p>是Dart程序的入口，也就是说，Flutter程序在运行的时候，第一个执行的函数就是main()函数，Flutter默认会找到<code>lib</code>目录下的<code>main.dart</code>并运行<code>void main() =&gt; runApp(new MyApp());</code></p></li><li><p>第一个组件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>   这是我们在主函数中调用的第一个控件(Widget)。</p></li></ul><h3 id="定义添加两种Theme-主题-分别适配Android和IOS"><a href="#定义添加两种Theme-主题-分别适配Android和IOS" class="headerlink" title="定义添加两种Theme(主题)分别适配Android和IOS"></a>定义添加两种Theme(主题)分别适配Android和IOS</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/cupertino.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/foundation.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ThemeData iOSTheme = <span class="keyword">new</span> ThemeData(</span><br><span class="line">  primarySwatch: Colors.red,</span><br><span class="line">  primaryColor: Colors.grey[<span class="number">400</span>],</span><br><span class="line">  primaryColorBrightness: Brightness.dark,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ThemeData androidTheme = <span class="keyword">new</span> ThemeData(</span><br><span class="line">  primarySwatch: Colors.blue,</span><br><span class="line">  accentColor: Colors.green,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">String</span> defaultUserName = <span class="string">"MeandNi"</span>; <span class="comment">//默认用户名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关注一下其中的primary颜色对双平台的设置，并且我们将ThemeData变量设置为final不可变的变量。</p><h3 id="定义一个无状态StatelessWidget组件"><a href="#定义一个无状态StatelessWidget组件" class="headerlink" title="定义一个无状态StatelessWidget组件"></a>定义一个无状态<code>StatelessWidget</code>组件</h3><p><strong>继承 StatelessWidget，通过 build 方法返回一个布局好的静态控件</strong>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext ctx) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">      title: <span class="string">"Chat Application"</span>,</span><br><span class="line">      theme: defaultTargetPlatform == TargetPlatform.iOS</span><br><span class="line">          ? iOSTheme</span><br><span class="line">          : androidTheme,</span><br><span class="line">      home: <span class="keyword">new</span> Chat(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在这里返回了一个MaterialApp，其中可以设置<code>title(标题)</code>、<code>theme(主题)</code>、<code>home(主页)</code>等属性。</p><p>其他属性参考：<a href="https://docs.flutter.io/flutter/widgets/WidgetsApp-class.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/widgets/WidgetsApp-class.html</a></p><p><code>title</code>：App标题</p><p><code>theme</code>：App主题</p><p><code>home</code>：App根路径</p><p>我们通过判断用户平台给出不同的主题。</p><h3 id="定义一个有状态StatefulWidget组件-——-Chat"><a href="#定义一个有状态StatefulWidget组件-——-Chat" class="headerlink" title="定义一个有状态StatefulWidget组件 —— Chat"></a>定义一个有状态<code>StatefulWidget</code>组件 —— Chat</h3><p><strong>继承 <code>StatefulWidget</code>，通过 build 方法返回一个布局好的动态控件</strong>。所谓动态控件，这里我们主要关注<figure class="highlight plain"><figcaption><span>State 的 `build` 方法去构建控件。在 State 中，你可以动态改变数据，这类似 MVVM 实现，在 `setState` 之后，改变的数据会触发 Widget 重新构建刷新。而下方代码中，我们咋State中定义了_messages、_textController、_isWriting三个变量，我们需要在改变着三个变量时触发 Widget 重新刷新。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```dart</span><br><span class="line">class Chat extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  State createState() =&gt; new ChatWindow();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ChatWindow extends State&lt;Chat&gt; with TickerProviderStateMixin &#123;</span><br><span class="line">  final List&lt;Msg&gt; _messages = &lt;Msg&gt;[];</span><br><span class="line">  final TextEditingController _textController = new TextEditingController();</span><br><span class="line">  bool _isWriting = false;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext ctx) &#123;</span><br><span class="line">    return new Scaffold(</span><br><span class="line">      appBar: new AppBar(</span><br><span class="line">        title: new Text(&quot;Chat Application&quot;),</span><br><span class="line">        elevation:</span><br><span class="line">        Theme.of(ctx).platform == TargetPlatform.iOS ? 0.0 : 6.0,</span><br><span class="line">      ),</span><br><span class="line">      body: new Column(children: &lt;Widget&gt;[</span><br><span class="line">        new Flexible(</span><br><span class="line">            child: new ListView.builder(</span><br><span class="line">              itemBuilder: (_, int index) =&gt; _messages[index],</span><br><span class="line">              itemCount: _messages.length,</span><br><span class="line">              reverse: true,</span><br><span class="line">              padding: new EdgeInsets.all(6.0),</span><br><span class="line">            )),</span><br><span class="line">        new Divider(height: 1.0),</span><br><span class="line">        new Container(</span><br><span class="line">          child: _buildComposer(),</span><br><span class="line">          decoration: new BoxDecoration(color: Theme.of(ctx).cardColor),</span><br><span class="line">        ),</span><br><span class="line">      ]),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="定义底部输入框和submit按钮："><a href="#定义底部输入框和submit按钮：" class="headerlink" title="定义底部输入框和submit按钮："></a>定义底部输入框和submit按钮：</h3><p>此Widget被放在ChatWindow的底部用于用户的输入提交。我们可以放关注点聚焦在<code>TextField</code>组件上，我们通过对输入值的监听修改_isWriting的值并对输入框组件和下方的按钮组件刷新达到一定用户体验。</p><p>对于放松按钮，我们在IOS端使用<code>CupertinoButton</code>，android端使用<code>IconButton</code>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Widget _buildComposer() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IconTheme(</span><br><span class="line">      data: <span class="keyword">new</span> IconThemeData(color: Theme.of(context).accentColor),</span><br><span class="line">      child: <span class="keyword">new</span> Container(</span><br><span class="line">          margin: <span class="keyword">const</span> EdgeInsets.symmetric(horizontal: <span class="number">9.0</span>),</span><br><span class="line">          child: <span class="keyword">new</span> Row(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              <span class="keyword">new</span> Flexible(</span><br><span class="line">                child: <span class="keyword">new</span> TextField(</span><br><span class="line">                  controller: _textController,</span><br><span class="line">                  onChanged: (<span class="built_in">String</span> txt) &#123;</span><br><span class="line">                    setState(() &#123;</span><br><span class="line">                      _isWriting = txt.length &gt; <span class="number">0</span>;</span><br><span class="line">                    &#125;);</span><br><span class="line">                  &#125;,</span><br><span class="line">                  onSubmitted: _submitMsg,</span><br><span class="line">                  decoration:</span><br><span class="line">                  <span class="keyword">new</span> InputDecoration.collapsed(hintText: <span class="string">"Enter some text to send a message"</span>),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">              <span class="keyword">new</span> Container(</span><br><span class="line">                  margin: <span class="keyword">new</span> EdgeInsets.symmetric(horizontal: <span class="number">3.0</span>),</span><br><span class="line">                  child: Theme.of(context).platform == TargetPlatform.iOS</span><br><span class="line">                      ? <span class="keyword">new</span> CupertinoButton(</span><br><span class="line">                      child: <span class="keyword">new</span> Text(<span class="string">"Submit"</span>),</span><br><span class="line">                      onPressed: _isWriting ? () =&gt; _submitMsg(_textController.text)</span><br><span class="line">                          : <span class="keyword">null</span></span><br><span class="line">                  )</span><br><span class="line">                      : <span class="keyword">new</span> IconButton(</span><br><span class="line">                    icon: <span class="keyword">new</span> Icon(Icons.message),</span><br><span class="line">                    onPressed: _isWriting</span><br><span class="line">                        ? () =&gt; _submitMsg(_textController.text)</span><br><span class="line">                        : <span class="keyword">null</span>,</span><br><span class="line">                  )</span><br><span class="line">              ),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">          decoration: Theme.of(context).platform == TargetPlatform.iOS</span><br><span class="line">              ? <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">              border:</span><br><span class="line">              <span class="keyword">new</span> Border(top: <span class="keyword">new</span> BorderSide(color: Colors.brown))) :</span><br><span class="line">          <span class="keyword">null</span></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="定义发送数据的函数"><a href="#定义发送数据的函数" class="headerlink" title="定义发送数据的函数"></a>定义发送数据的函数</h3><p>通过<code>_textController</code>清除输入框的旧数据。定义<code>Msg</code>插入到<code>_messages</code>数组中。</p><p>这里我们可以关注动画效果的操作,<code>animationController</code>将作为传输传递到<code>Msg</code>组件当中。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _submitMsg(<span class="built_in">String</span> txt) &#123;</span><br><span class="line">    _textController.clear();</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _isWriting = <span class="keyword">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Msg msg = <span class="keyword">new</span> Msg(</span><br><span class="line">      txt: txt,</span><br><span class="line">      animationController: <span class="keyword">new</span> AnimationController(</span><br><span class="line">          vsync: <span class="keyword">this</span>,</span><br><span class="line">          duration: <span class="keyword">new</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">800</span>)</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _messages.insert(<span class="number">0</span>, msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    msg.animationController.forward();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="定义Msg消息的模版组件"><a href="#定义Msg消息的模版组件" class="headerlink" title="定义Msg消息的模版组件"></a>定义<code>Msg</code>消息的模版组件</h3><p>实际上我们点击Submit消息发送时，发送的就是这样一个<code>StatelessWidget</code>，其中携带两个变量：<code>txt</code>消息内容、<code>animationController</code>动画控制器。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Msg</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  Msg(&#123;<span class="keyword">this</span>.txt, <span class="keyword">this</span>.animationController&#125;);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> txt;</span><br><span class="line">  <span class="keyword">final</span> AnimationController animationController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext ctx) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SizeTransition(</span><br><span class="line">      sizeFactor: <span class="keyword">new</span> CurvedAnimation(</span><br><span class="line">          parent: animationController, curve: Curves.easeOut),</span><br><span class="line">      axisAlignment: <span class="number">0.0</span>,</span><br><span class="line">      child: <span class="keyword">new</span> Container(</span><br><span class="line">        margin: <span class="keyword">const</span> EdgeInsets.symmetric(vertical: <span class="number">8.0</span>),</span><br><span class="line">        child: <span class="keyword">new</span> Row(</span><br><span class="line">          crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Container(</span><br><span class="line">              margin: <span class="keyword">const</span> EdgeInsets.only(right: <span class="number">18.0</span>),</span><br><span class="line">              child: <span class="keyword">new</span> CircleAvatar(child: <span class="keyword">new</span> Text(defaultUserName[<span class="number">0</span>])),</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> Expanded(</span><br><span class="line">              child: <span class="keyword">new</span> Column(</span><br><span class="line">                crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">                children: &lt;Widget&gt;[</span><br><span class="line">                  <span class="keyword">new</span> Text(defaultUserName, style: Theme.of(ctx).textTheme.subhead),</span><br><span class="line">                  <span class="keyword">new</span> Container(</span><br><span class="line">                    margin: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">6.0</span>),</span><br><span class="line">                    child: <span class="keyword">new</span> Text(txt),</span><br><span class="line">                  ),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们的第一个实战App旧大功告成了，是不是很简单的样子，没错，就是这么简单就能做出这么漂亮的UI，其中有些Flutter基础可能没有涉及，如果又需要会尽量更新！</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/MeandNi/Flutter1-Chat_APP" target="_blank" rel="noopener">github demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;希望尽一点点薄力让大家有兴趣学习这门新技术。&lt;/p&gt;
&lt;p&gt;这里暂不介绍环境配置等操作，不了解的朋友请先移步官网：&lt;a href=&quot;https://flutter.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://flutter.io/
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="自学" scheme="https://meandni.com/tags/%E8%87%AA%E5%AD%A6/"/>
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>经验：Flutter项目IOS真机部署及问题</title>
    <link href="https://meandni.com/2019/01/04/5671/"/>
    <id>https://meandni.com/2019/01/04/5671/</id>
    <published>2019-01-04T12:12:57.000Z</published>
    <updated>2019-01-04T12:42:21.401Z</updated>
    
    <content type="html"><![CDATA[<p>用flutter开发ios应用在真机调试时出现的问题以及处理方式</p><h2 id="无法连接iphone手机"><a href="#无法连接iphone手机" class="headerlink" title="无法连接iphone手机"></a>无法连接iphone手机</h2><p>flutter找不到真机，已经安装Xcode，Xcode里面可以打开真机运行，但Android Studio环境和Vscode环境下，不能找到连接的iPhone真机，其实很简单，终端运行一下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p>即可，控制台提示如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pan.94ht.com/image-20190104201612194.png" alt="image-20190104201612194" title="">                </div>                <div class="image-caption">image-20190104201612194</div>            </figure><p>按照提示终端执行 截图绿色部分的命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install --HEAD usbmuxd</span><br><span class="line">brew link usbmuxd</span><br><span class="line">brew install --HEAD libimobiledevice</span><br><span class="line">brew install ideviceinstaller</span><br></pre></td></tr></table></figure><h2 id="Signing-for-“xxx”-requires-a-development-team-Select-a-development-team"><a href="#Signing-for-“xxx”-requires-a-development-team-Select-a-development-team" class="headerlink" title="Signing for “xxx” requires a development team. Select a development team"></a>Signing for “xxx” requires a development team. Select a development team</h2><p>首次用vscode连上真机以后，点击调试，会出现如下问题：</p><blockquote><p>No Provisioning Profile was found for your project’s Bundle Identifier or your<br>device. You can create a new Provisioning Profile for your project in Xcode for<br>your team by:<br>  1- Open the Flutter project’s Xcode target with<br>       open ios/Runner.xcworkspace<br>  2- Select the ‘Runner’ project in the navigator then the ‘Runner’ target<br>     in the project settings<br>  3- In the ‘General’ tab, make sure a ‘Development Team’ is selected.<br>     You may need to:</p><pre><code>- Log in with your Apple ID in Xcode first- Ensure you have a valid unique Bundle ID- Register your device with your Apple Developer Account- Let Xcode automatically provision a profile for your app</code></pre><p>  4- Build or run your project again<br>It’s also possible that a previously installed app with the same Bundle<br>Identifier was signed with a different certificate.<br>For more information, please visit:<br>  <a href="https://flutter.io/setup/#deploy-to-ios-devices" target="_blank" rel="noopener">https://flutter.io/setup/#deploy-to-ios-devices</a><br>Or run on an iOS simulator without code signing<br>════════════════════════════════════════════════════════════════════════════════<br>2018-10-27 12:09:29.004 ios-deploy[91734:221562][ !! ] Error 0xe8008015: A valid provisioning profile for this executable was not found. AMDeviceSecureInstallApplication(0, device, url, options, install_callback, 0)<br>Could not install build/ios/iphoneos/Runner.app on b53d6902af4ac5d5166a3125b9013886739c92d2.<br>Try launching Xcode and selecting “Product &gt; Run” to fix the problem:<br>  open ios/Runner.xcworkspace<br>Error launching application on xxx的 iPhone.<br>Exited (sigterm)</p></blockquote><p>用xcode打开 flutter项目<code>/ios/Runner.xcworkspace</code> 这个文件，好，我们手动打开，点击编译，此时会编译不通过～</p><p>出现这个问题的原因是你的xcode project 中的team没有选择，选择方法如下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pan.94ht.com/QQ20190104-203008.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h2 id="不受信任的开发者"><a href="#不受信任的开发者" class="headerlink" title="不受信任的开发者"></a>不受信任的开发者</h2><p>解决方式：打开手机上的”设置-&gt;通用-&gt;设备管理-&gt;开发者应用”，进入以后，点击”信任 <a href="mailto:xxxxx@xxx.com" target="_blank" rel="noopener">xxxxx@xxx.com</a>“</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>官方链接：<a href="https://flutter.io/docs/get-started/install/macos" target="_blank" rel="noopener">https://flutter.io/docs/get-started/install/macos</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用flutter开发ios应用在真机调试时出现的问题以及处理方式&lt;/p&gt;
&lt;h2 id=&quot;无法连接iphone手机&quot;&gt;&lt;a href=&quot;#无法连接iphone手机&quot; class=&quot;headerlink&quot; title=&quot;无法连接iphone手机&quot;&gt;&lt;/a&gt;无法连接iphone
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="总结" scheme="https://meandni.com/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="问题" scheme="https://meandni.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Android进阶之路</title>
    <link href="https://meandni.com/2018/12/25/644b/"/>
    <id>https://meandni.com/2018/12/25/644b/</id>
    <published>2018-12-25T07:15:58.000Z</published>
    <updated>2019-01-03T15:17:49.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读书进阶Android"><a href="#读书进阶Android" class="headerlink" title="读书进阶Android"></a>读书进阶Android</h2><p>已读：《Android群英传》</p><p>正读：《Android进阶之光》</p><p>未读：《Android开发艺术探索》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;读书进阶Android&quot;&gt;&lt;a href=&quot;#读书进阶Android&quot; class=&quot;headerlink&quot; title=&quot;读书进阶Android&quot;&gt;&lt;/a&gt;读书进阶Android&lt;/h2&gt;&lt;p&gt;已读：《Android群英传》&lt;/p&gt;
&lt;p&gt;正读：《Android
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="Android" scheme="https://meandni.com/tags/Android/"/>
    
      <category term="读书" scheme="https://meandni.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Android 框架组件(Android Architecture Components)使用指南</title>
    <link href="https://meandni.com/2018/11/21/86ef/"/>
    <id>https://meandni.com/2018/11/21/86ef/</id>
    <published>2018-11-21T06:17:01.833Z</published>
    <updated>2019-01-03T13:51:48.033Z</updated>
    
    <content type="html"><![CDATA[<p>面对越来越复杂的 App 需求，Google 官方发布了Android 框架组件库（Android Architecture Components ）。为开发者更好的开发 App 提供了非常好的样本。这个框架里的组件是配合 Android 组件生命周期的，所以它能够很好的规避组件生命周期管理的问题。今天我们就来看看这个库的使用。</p><h4 id="0x00-通用的框架准则"><a href="#0x00-通用的框架准则" class="headerlink" title="0x00 通用的框架准则"></a>0x00 通用的框架准则</h4><p>官方建议在架构 App 的时候遵循以下两个准则：</p><ol><li><p><strong>关注分离</strong></p><p>其中早期开发 App 最常见的做法是在 Activity 或者 Fragment 中写了大量的逻辑代码，导致 Activity 或 Fragment 中的代码很臃肿，十分不易维护。现在很多 App 开发者都注意到了这个问题，所以前两年 MVP 结构就非常有市场，目前普及率也很高。</p></li><li><p><strong>模型驱动UI</strong></p><p>模型持久化的好处就是：即使系统回收了 App 的资源用户也不会丢失数据，而且在网络不稳定的情况下 App 依然可以正常地运行。从而保证了 App 的用户体验。</p></li></ol><h4 id="0x01-App-框架组件"><a href="#0x01-App-框架组件" class="headerlink" title="0x01 App 框架组件"></a>0x01 App 框架组件</h4><p>框架提供了以下几个核心组件，我们将通过一个实例来说明这几个组件的使用。</p><ul><li>ViewModel</li><li>LiveData</li><li>Room</li></ul><p>假设要实现一个用户信息展示页面。这个用户信息是通过REST API 从后台获取的。</p><h4 id="0x02-建立UI"><a href="#0x02-建立UI" class="headerlink" title="0x02 建立UI"></a>0x02 建立UI</h4><p>我们使用 fragment (UserProfileFragment.java) 来实现用户信息的展示页面。为了驱动 UI，我们的数据模型需要持有以下两个数据元素</p><ul><li><strong>用户ID</strong>: 用户的唯一标识。可以通过 fragment 的 arguments 参数进行传递这个信息。这样做的好处就是如果系统销毁了应用，这个参数会被保存并且下次重新启动时可以恢复之前的数据。</li><li><strong>用户对象数据</strong>：POJO 持有用户数据。</li></ul><p>我们要创建 <strong>ViewModel</strong> 对象用于保存以上数据。</p><p>那什么是 ViewModel 呢？</p><blockquote><p>A <strong>ViewModel</strong> provides the data for a specific UI component, such as a fragment or activity, and handles the communication with the business part of data handling, such as calling other components to load the data or forwarding user modifications. The ViewModel does not know about the View and is not affected by configuration changes such as recreating an activity due to rotation.</p></blockquote><p>ViewModel 是一个框架组件。它为 UI 组件 (fragment或activity) 提供数据，并且可以调用其它组件加载数据或者转发用户指令。ViewModel 不会关心 UI 长什么样，也不会受到 UI 组件配置改变的影响，例如不会受旋转屏幕后 activity 重新启动的影响。因此它是一个与 UI 组件无关的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileFragment</span> <span class="keyword">extends</span> <span class="title">LifecycleFragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UID_KEY = <span class="string">"uid"</span>;</span><br><span class="line">    <span class="keyword">private</span> UserProfileViewModel viewModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        String userId = getArguments().getString(UID_KEY);</span><br><span class="line">        viewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(UserProfileViewModel.class);</span><br><span class="line">        viewModel.init(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater,</span></span></span><br><span class="line"><span class="function"><span class="params">                @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.user_profile, container, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要的是：由于框架组件目前还处于预览版本，这里<code>UserProfileFragment</code> 是继承于 <code>LifecycleFragment</code> 而不是 <code>Fragment</code>。待正式发布版本之后 Android Support 包中的 <code>Fragment</code> 就会默认实现 <code>LifecycleOwner</code> 接口。而 <code>LifecycleFragment</code> 也是实现了 <code>LifecycleOwner</code> 接口的。即正式版本发布时 Support 包中的 UI 组件类就是支持框架组件的。</p><p>现在已经有了 UI 组件和 ViewModel，那么我们如何将它们进行连接呢？这时候就需要用到 LiveData 组件了。</p><blockquote><p><strong>LiveData</strong> is an observable data holder. It lets the components in your app observe <a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener"><code>LiveData</code></a> objects for changes without creating explicit and rigid dependency paths between them. LiveData also respects the lifecycle state of your app components (activities, fragments, services) and does the right thing to prevent object leaking so that your app does not consume more memory.</p></blockquote><p>LiveData 的使用有点像 RxJava。因此完全可以使用 RxJava 来替代 LiveData 组件。</p><p>现在我们修改一下 <code>UserProfileViewModel</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> LiveData&lt;User&gt; user;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 <code>User user</code> 替换成  <code>LiveData&lt;User&gt; user</code></p><p>然后再修改 <code>UserProfileFragment</code> 类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    viewModel.getUser().observe(<span class="keyword">this</span>, user -&gt; &#123;</span><br><span class="line">      <span class="comment">// update UI</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户数据发生改变时，就会通知 UI 进行更新。ViewModel 与 UI 组件的交互就是这么简单。</p><p>但细心的朋友可能发现了：fragment 在 <code>onActivityCreated</code> 方法中添加了相应的监听，但是没有在其它对应的生命周期中移除监听。有经验的朋友就会觉得这是不是有可能会发生引用泄露问题呢？其实不然，LiveData 组件内部已经为开发者做了这些事情。即 LiveData 会再正确的生命周期进行回调。</p><h4 id="0x03-获取数据"><a href="#0x03-获取数据" class="headerlink" title="0x03 获取数据"></a>0x03 获取数据</h4><p>现在已经成功的把 ViewModel 与 UI 组件（fragment）进行了通信。那么 ViewModel 又是如何获取数据的呢？</p><p>假设我们的数据是通过REST API 从后天获取的。我们使用 <a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a> 库实现网络请求。</p><p>以下是请求网络接口 <code>Webservice</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Webservice</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@GET</span> declares an HTTP GET request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Path</span>("user") annotation on the userId parameter marks it as a</span></span><br><span class="line"><span class="comment">     * replacement for the &#123;user&#125; placeholder in the <span class="doctag">@GET</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/users/&#123;user&#125;"</span>)</span><br><span class="line">    <span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewModel 可以引用 <code>Webservice</code> 接口，但是这样做违背了我们在上文提到的<strong>关注分离</strong>准则。因为我们推荐使用 <code>Repository</code> 模型对 <code>Webservice</code> 进行封装。</p><blockquote><p><strong>Repository</strong> modules are responsible for handling data operations. They provide a clean API to the rest of the app. They know where to get the data from and what API calls to make when data is updated. You can consider them as mediators between different data sources (persistent model, web service, cache, etc.).</p></blockquote><p>关于 Repository 模式可以参考我的上一篇《App 组件化/模块化之路——Repository模式》</p><p>以下是使用 Repository 封装 <code>WebService</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Webservice webservice;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// This is not an optimal implementation, we'll fix it below</span></span><br><span class="line">        <span class="keyword">final</span> MutableLiveData&lt;User&gt; data = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">        webservice.getUser(userId).enqueue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// error case is left out for brevity</span></span><br><span class="line">                data.setValue(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Respository 模式抽象数据源接口，也可以很方便地替换其它数据。这样 ViewModel 也不用知道数据源到底是来自哪里。</p><h4 id="0x04-组件间的依赖管理"><a href="#0x04-组件间的依赖管理" class="headerlink" title="0x04 组件间的依赖管理"></a>0x04 组件间的依赖管理</h4><p>从上文我们知道 <code>UserRepository</code> 类需要有一个 <code>WebService</code> 实例才能工作。我们可以直接创建它，但这么做我们就必须知道它的依赖，而且会由很多重复的创建对象的代码。这时候我们可以使用依赖注入。本例中我们将使用 Dagger 2 来管理依赖。</p><h4 id="0x05-连接-ViewModel-和-Repository"><a href="#0x05-连接-ViewModel-和-Repository" class="headerlink" title="0x05 连接 ViewModel 和 Repository"></a>0x05 连接 ViewModel 和 Repository</h4><p>修改 <code>UserProfileViewModel</code> 类，引用 Repository 并且通过 Dagger 2 对 Repository 的依赖进行管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LiveData&lt;User&gt; user;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span> <span class="comment">// UserRepository parameter is provided by Dagger 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProfileViewModel</span><span class="params">(UserRepository userRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepo = userRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ViewModel is created per Fragment so</span></span><br><span class="line">            <span class="comment">// we know the userId won't change</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        user = userRepo.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x06-缓存数据"><a href="#0x06-缓存数据" class="headerlink" title="0x06 缓存数据"></a>0x06 缓存数据</h4><p>前面我们实现的 Repository 是只有一个网络数据源的。这样做每次进入用户信息页面都需要去查询网络，用户需要等待，体验不好。因此在 Repository 中加一个缓存数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span>  <span class="comment">// informs Dagger that this class should be constructed once</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Webservice webservice;</span><br><span class="line">    <span class="comment">// simple in memory cache, details omitted for brevity</span></span><br><span class="line">    <span class="keyword">private</span> UserCache userCache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        LiveData&lt;User&gt; cached = userCache.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cached;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MutableLiveData&lt;User&gt; data = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">        userCache.put(userId, data);</span><br><span class="line">        <span class="comment">// this is still suboptimal but better than before.</span></span><br><span class="line">        <span class="comment">// a complete implementation must also handle the error cases.</span></span><br><span class="line">        webservice.getUser(userId).enqueue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">                data.setValue(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x07-持久化数据-（Room-组件）"><a href="#0x07-持久化数据-（Room-组件）" class="headerlink" title="0x07 持久化数据 （Room 组件）"></a>0x07 持久化数据 （Room 组件）</h4><p>Android 框架提供了 Room 组件，为 App 数据持久化提供了解决方案。</p><blockquote><p><strong>Room</strong> is an object mapping library that provides local data persistence with minimal boilerplate code. At compile time, it validates each query against the schema, so that broken SQL queries result in compile time errors instead of runtime failures. Room abstracts away some of the underlying implementation details of working with raw SQL tables and queries. It also allows observing changes to the database data (including collections and join queries), exposing such changes via <em>LiveData</em> objects. In addition, it explicitly defines thread constraints that address common issues such as accessing storage on the main thread.</p></blockquote><p>Room 组件提供了数据库操作，配合 LiveData 使用可以监听数据库的变化，进而更新 UI 组件。</p><p>要使用 Room 组件，需要以下步骤：</p><ul><li>使用注解 <code>@Entity</code> 定义实体</li><li>创建 <code>RoomDatabase</code> 子类</li><li>创建数据访问接口（DAO）</li><li>在 <code>RoomDatabase</code> 中引用 DAO</li></ul><ol><li><strong>用注解 <code>@Entity</code> 定义实体类</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="meta">@PrimaryKey</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="comment">// getters and setters for fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>创建 <code>RoomDatabase</code>子类</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 <code>MyDatabase</code> 是抽象类，Room 组件为我们提供具体的实现。</p><ol start="3"><li><p><strong>创建 DAO</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(onConflict = REPLACE)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE id = :userId"</span>)</span><br><span class="line">    <span class="function">LiveData&lt;User&gt; <span class="title">load</span><span class="params">(String userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>在 <code>RoomDatabase</code> 中引用 DAO</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>现在有了 Room 组件，那么我们可以修改 <code>UserRepository</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Webservice webservice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRepository</span><span class="params">(Webservice webservice, UserDao userDao, Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webservice = webservice;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        refreshUser(userId);</span><br><span class="line">        <span class="comment">// return a LiveData directly from the database.</span></span><br><span class="line">        <span class="keyword">return</span> userDao.load(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshUser</span><span class="params">(<span class="keyword">final</span> String userId)</span> </span>&#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// running in a background thread</span></span><br><span class="line">            <span class="comment">// check if user was fetched recently</span></span><br><span class="line">            <span class="keyword">boolean</span> userExists = userDao.hasUser(FRESH_TIMEOUT);</span><br><span class="line">            <span class="keyword">if</span> (!userExists) &#123;</span><br><span class="line">                <span class="comment">// refresh the data</span></span><br><span class="line">                Response response = webservice.getUser(userId).execute();</span><br><span class="line">                <span class="comment">// TODO check for error etc.</span></span><br><span class="line">                <span class="comment">// Update the database.The LiveData will automatically refresh so</span></span><br><span class="line">                <span class="comment">// we don't need to do anything else here besides updating the database</span></span><br><span class="line">                userDao.save(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前为止我们的代码就基本完成了。UI 组件通过 ViewModel 访问数据，而 ViewModel 通过 LiveData 监听数据的变化，并且使用 Repository 模式封装数据源。这些数据源可以是网络数据，缓存以及持久化数据。</p><h4 id="0x08-框架结构图"><a href="#0x08-框架结构图" class="headerlink" title="0x08 框架结构图"></a>0x08 框架结构图</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/final-architecture.png" alt="final-architecture" title="">                </div>                <div class="image-caption">final-architecture</div>            </figure><h4 id="0x09-参考文档"><a href="#0x09-参考文档" class="headerlink" title="0x09 参考文档"></a>0x09 参考文档</h4><p><a href="https://developer.android.com/topic/libraries/architecture/guide.html#recommended_app_architecture" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/architecture/guide.html#recommended_app_architecture</a></p><p><a href="https://github.com/googlesamples/android-architecture-components" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture-components</a></p>]]></content>
    
    <summary type="html">
    
      面对越来越复杂的 App 需求，Google 官方发布了Android 框架组件库（Android Architecture Components ）。为开发者更好的开发 App 提供了非常好的样本。
    
    </summary>
    
      <category term="非原创" scheme="https://meandni.com/categories/%E9%9D%9E%E5%8E%9F%E5%88%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>跟着Google学习架构2：todo‑mvp代码分析</title>
    <link href="https://meandni.com/2018/11/11/3b09/"/>
    <id>https://meandni.com/2018/11/11/3b09/</id>
    <published>2018-11-11T14:01:00.000Z</published>
    <updated>2019-01-03T15:16:53.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、MVP简介"><a href="#一、MVP简介" class="headerlink" title="一、MVP简介"></a>一、MVP简介</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3985563-25731fb5c707f5d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/416/format/webp" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><ul><li>Model: 数据层，负责与网络层和数据库层的逻辑交互。</li><li>View: UI层，显示数据, 并向Presenter报告用户行为。</li><li>Presenter: 从Model拿数据，应用到UI层，管理UI的状态，响应用户的行为。</li></ul><h2 id="二、MVP优势"><a href="#二、MVP优势" class="headerlink" title="二、MVP优势"></a>二、MVP优势</h2><p>在学习todo-mvp之前，先了解一下MVP的优势。</p><ul><li>分离了视图逻辑和业务逻辑，降低了耦合。</li><li>Activity只处理生命周期的任务，代码变得更加简洁。</li><li>视图逻辑和业务逻辑分别抽象到了View和Presenter的接口中，提高代码的阅读性。</li><li>Presenter被抽象成接口，可以有多种具体的实现，所以方便进行单元测试。</li><li>把业务逻辑抽到Presenter中去，避免后台线程引用着Activity导致Activity的资源无法被系统回收从而引起内存泄露和OOM。</li></ul><h2 id="三、todo-mvp结构解析"><a href="#三、todo-mvp结构解析" class="headerlink" title="三、todo-mvp结构解析"></a>三、todo-mvp结构解析</h2><h3 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1.项目结构"></a>1.项目结构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3985563-bf64641065361b3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/950/format/webp" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>从上图可以看出，todo-mvp是按照功能模块划分的。</p><p>其中tasks, taskdetail, addedittask, statistics是四个业务模块。</p><p>data是数据模块，其中具体的类<code>TasksRepository</code>担任Model层，负责远程和本地数据的获取。</p><p><code>BasePresenter</code>和<code>BaseView</code>是presenter 和 view 的基类，在具体模块承担实际功能。最后，util是工具类集合。</p><h3 id="2-具体解析"><a href="#2-具体解析" class="headerlink" title="2.具体解析"></a>2.具体解析</h3><p>在todoapp中，MVP的具体结构如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3985563-4634a04a1a55cd1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/584/format/webp" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>下面以tasks模块具体阐述上述图片中的实际作用关系。</p><p><strong>基类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface BasePresenter &#123;</span><br><span class="line"></span><br><span class="line">    void start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>start()</code>方法的作用是presenter开始获取数据并调用view中方法改变界面显示，其调用时机是在Fragment类的<code>onResume</code>方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface BaseView&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    void setPresenter(T presenter);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>setPresenter()</code>方法作用是在将presenter实例传入view中，其<strong>调用时机是presenter实现类的构造函数中</strong>。</p><p><strong>契约类</strong></p><p>与之前使用的MVP实现不同，官方的实现中加入了契约类来统一管理view与presenter的所有的接口，这种方式使得view与presenter中有哪些功能，一目了然，维护起来也方便，同时使得view与presenter一一对应，并有效地减少类的数目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public interface TasksContract &#123;</span><br><span class="line"></span><br><span class="line">    interface View extends BaseView&lt;Presenter&gt; &#123;</span><br><span class="line"></span><br><span class="line">        void setLoadingIndicator(boolean active);</span><br><span class="line"></span><br><span class="line">        void showTasks(List&lt;Task&gt; tasks);</span><br><span class="line"></span><br><span class="line">        void showAddTask();</span><br><span class="line"></span><br><span class="line">        void showTaskDetailsUi(String taskId);</span><br><span class="line"></span><br><span class="line">        void showTaskMarkedComplete();</span><br><span class="line"></span><br><span class="line">        void showTaskMarkedActive();</span><br><span class="line"></span><br><span class="line">        void showCompletedTasksCleared();</span><br><span class="line"></span><br><span class="line">        void showLoadingTasksError();</span><br><span class="line"></span><br><span class="line">        void showNoTasks();</span><br><span class="line"></span><br><span class="line">        void showActiveFilterLabel();</span><br><span class="line"></span><br><span class="line">        void showCompletedFilterLabel();</span><br><span class="line"></span><br><span class="line">        void showAllFilterLabel();</span><br><span class="line"></span><br><span class="line">        void showNoActiveTasks();</span><br><span class="line"></span><br><span class="line">        void showNoCompletedTasks();</span><br><span class="line"></span><br><span class="line">        void showSuccessfullySavedMessage();</span><br><span class="line"></span><br><span class="line">        boolean isActive();</span><br><span class="line"></span><br><span class="line">        void showFilteringPopUpMenu();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface Presenter extends BasePresenter &#123;</span><br><span class="line"></span><br><span class="line">        void result(int requestCode, int resultCode);</span><br><span class="line"></span><br><span class="line">        void loadTasks(boolean forceUpdate);</span><br><span class="line"></span><br><span class="line">        void addNewTask();</span><br><span class="line"></span><br><span class="line">        void openTaskDetails(@NonNull Task requestedTask);</span><br><span class="line"></span><br><span class="line">        void completeTask(@NonNull Task completedTask);</span><br><span class="line"></span><br><span class="line">        void activateTask(@NonNull Task activeTask);</span><br><span class="line"></span><br><span class="line">        void clearCompletedTasks();</span><br><span class="line"></span><br><span class="line">        void setFiltering(TasksFilterType requestType);</span><br><span class="line"></span><br><span class="line">        TasksFilterType getFiltering();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TasksActivity</strong></p><p>Activity 在项目中是一个全局的控制者，负责创建 view 以及 presenter 实例，并将二者联系起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> TasksFragment tasksFragment =</span><br><span class="line">         (TasksFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</span><br><span class="line"> if (tasksFragment == null) &#123;</span><br><span class="line">     // 创建 fragment</span><br><span class="line">     tasksFragment = TasksFragment.newInstance();</span><br><span class="line">     ActivityUtils.addFragmentToActivity(</span><br><span class="line">             getSupportFragmentManager(), tasksFragment, R.id.contentFrame);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 创建 presenter，TasksPresenter是TasksContract.Presenter 的实现类</span><br><span class="line">// 传入两个参数 </span><br><span class="line">//1.TasksRepository实例，负责数据层  </span><br><span class="line">//2.tasksFragment，是TasksContract.View的实现类，即view实例</span><br><span class="line"> mTasksPresenter = new TasksPresenter(</span><br><span class="line">         Injection.provideTasksRepository(getApplicationContext()), tasksFragment);</span><br></pre></td></tr></table></figure><p>其中，通过实例化<code>TasksPresenter</code>时，传入<code>tasksFragment</code>，使得在<code>TasksPresenter</code>中拥有view实例。同时，在实例化时初始化构造函数，调用了<code>setPresenter()</code>方法，使得view实例中拥有了presenter实例对象，使得两者联系起来。</p><p><code>TasksPresenter</code>构造函数如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public TasksPresenter(@NonNull TasksRepository tasksRepository, @NonNull TasksContract.View tasksView) &#123;</span><br><span class="line">    mTasksRepository = checkNotNull(tasksRepository, &quot;tasksRepository cannot be null&quot;);</span><br><span class="line">    mTasksView = checkNotNull(tasksView, &quot;tasksView cannot be null!&quot;);</span><br><span class="line"></span><br><span class="line">    mTasksView.setPresenter(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TasksFragment</strong></p><p>将Fragment作为view层的实现类，使得Activity作为一个全局控制类来创建对象，而Fragment作为view，两者各司其职。同时，Fragment比较灵活，能够方便的处理界面适配的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TasksFragment extends Fragment implements TasksContract.View &#123;</span><br><span class="line">    ...........</span><br><span class="line">    public static TasksFragment newInstance() &#123;</span><br><span class="line">        return new TasksFragment();</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">    @Override</span><br><span class="line">    public void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        mPresenter.start();</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">    @Override</span><br><span class="line">    public void setPresenter(@NonNull TasksContract.Presenter presenter) &#123;</span><br><span class="line">        mPresenter = checkNotNull(presenter);</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isActive() &#123;</span><br><span class="line">        return isAdded();</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 view 的实现TasksFragment，只挑一部分重要的方法来看。</p><ul><li><code>newInstance ()</code>方法，实例化TasksFragment对象。</li><li><code>setPresenter()</code>方法继承于父类，通过该方法，view 获得了 presenter 得实例，从而可以调用 presenter 代码来处理业务逻辑。</li><li>在<code>onResume()</code>中，调用了 presenter 得<code>start()</code>方法，获取数据并操作view界面的显示。</li><li><code>isActive()</code>方法，通过<code>isAdded()</code>判断对应Activity是否销毁。在Fragment在执行异步耗时操作后，如果调用Activity实例，应当先使用<code>isActive()</code>方法加以判断。</li></ul><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>通过对todo-mvp分析，再次了解学习了MVP。从google提供的例子中可以看出，MVP的实现较为简单，model、view和presenter各个职责明确，便于扩展维护。contract契约类的出现，使得model和presenter结构更加清晰明了。Activity和Fragment的配合，使得Activity职能更为简化，同时View的实现更加灵活。</p><p>参考文章：<br><a href="https://www.jianshu.com/p/e219ebd1572a" target="_blank" rel="noopener">https://www.jianshu.com/p/e219ebd1572a</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、MVP简介&quot;&gt;&lt;a href=&quot;#一、MVP简介&quot; class=&quot;headerlink&quot; title=&quot;一、MVP简介&quot;&gt;&lt;/a&gt;一、MVP简介&lt;/h2&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div cl
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Android" scheme="https://meandni.com/tags/Android/"/>
    
      <category term="架构" scheme="https://meandni.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="模块化" scheme="https://meandni.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>跟着Google学习架构1：todo‑mvp和todo‑mvp‑clean</title>
    <link href="https://meandni.com/2018/11/10/33d5/"/>
    <id>https://meandni.com/2018/11/10/33d5/</id>
    <published>2018-11-10T14:01:00.000Z</published>
    <updated>2019-01-03T15:16:46.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>这里一定要说明一下，对于MVP,MVC,MVVM,Clean Architecture 等都只是设计思想，并不是代码框架，具体的框架需要来使用上述的设计思想来实现。就比如下面的MVP实现中，View是Activity,Fragment，Presenter是单独的类来处理逻辑，REPOSITORY可以看做是Model。</p><h1 id="android-architecture-todoapp-mvp"><a href="#android-architecture-todoapp-mvp" class="headerlink" title="android-architecture-todoapp-mvp"></a>android-architecture-todoapp-mvp</h1><p>google官方推荐的Android框架MVP例子。自己添加了一些注释和心得。<br>基于 Model-View-Presenter的机构模式。</p><p>核心思想就再下面这张图里面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pan.94ht.com/mvp.png" alt="ss" title="">                </div>                <div class="image-caption">ss</div>            </figure><p>图中的REPOSITORY 也就是数据层，相当于Model。</p><p>谷歌仓库：<br><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">https://github.com/googlesamples/android-architecture</a></p><h1 id="android-architecture-todoapp-mvp-clean"><a href="#android-architecture-todoapp-mvp-clean" class="headerlink" title="android-architecture-todoapp-mvp-clean"></a>android-architecture-todoapp-mvp-clean</h1><p><strong>下面的内容来自<a href="http://www.jianshu.com/p/c6a1a5c9a49b" target="_blank" rel="noopener">简书</a></strong></p><p>首先看一个Clean Architecture构想图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pan.94ht.com/CleanArchitecture.jpg" alt="mvp" title="">                </div>                <div class="image-caption">mvp</div>            </figure></p><p>约定，从最里面的圈向外依次为1、2、3、4。</p><ul><li>第一个圈，是代表App的业务对象（business objects of the application），我的理解也就是相当于数据层。</li><li>第二个圈，是编排数据从 Entity 入或出的流，也叫交互器(Interactors)，基本上所有业务逻辑都在这里。</li><li>第三个圈，把 Use Cases 或者 Entity 使用的数据结构转换成需要的形式。Presenters 和 Controllers 都属于这里。</li><li>第四个圈，框架和驱动：处理细节的地方：UI、工具（tools）、框架（framework）等。</li></ul><p>上面只是一个设计规范，那么具体到代码实现应该怎么设计呢？<br>下图是一个大概的框架：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pan.94ht.com/CleanCode.png" alt="CleanCode" title="">                </div>                <div class="image-caption">CleanCode</div>            </figure></p><h4 id="Presentation-Layer"><a href="#Presentation-Layer" class="headerlink" title="Presentation Layer"></a>Presentation Layer</h4><p>这一层是处理UI、动画逻辑的地方，它使用了MVP（Model View Presenter）模式， 你也可以使用 MVC、MVVM（不再深究）。</p><p>在这里 Activity和Fragment都是Views，不处理除UI逻辑之外的任何逻辑，许多的渲染操作都在这里完成。</p><p>在这一层 Presenters 是由各种 interactors (use cases) 组成的，他们负责执行一个异步任务，并通过回调取回需要的数据给UI渲染。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pan.94ht.com/CleanCodeMvp.png" alt="CleanCodeMvp" title="">                </div>                <div class="image-caption">CleanCodeMvp</div>            </figure><p>Model就相当于各种interactors(use cases)，可以把多个interactors(use cases)封装一下来实现一个页面的逻辑，这样封装好的就是Model了，当然如果不封装也可以。</p><p>如果你想看一看一些比较酷的MVP、MVVM例子，可以参考 <a href="https://github.com/pedrovgs/EffectiveAndroidUI/" target="_blank" rel="noopener">Effective Android UI</a> 。</p><h4 id="Domain-Layer"><a href="#Domain-Layer" class="headerlink" title="Domain Layer"></a>Domain Layer</h4><p>所有的业务逻辑都是在这层处理的。考虑到Android工程，你会看到所有的 interactors (use cases) 也是在这里实现的。</p><p>这层是一个纯Java的模块，不包含任何Android依赖，所有的外部交互都是通过接口来实现。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://pan.94ht.com/CleanCodeDomain.png" alt="CleanCodeDomain" title="">                </div>                <div class="image-caption">CleanCodeDomain</div>            </figure></p><p>通过上图可以发现，这一层即包含与 Presentation Layer交互的接口（interactors / use cases），也包含与 Data Layer交互的接口（Repository Interface）。</p><h4 id="Data-Layer"><a href="#Data-Layer" class="headerlink" title="Data Layer"></a>Data Layer</h4><p>所有App需要的数据都是通过这层的 UserRepository （实现了DomainLayer的接口）提供的，它使用了 <a href="http://martinfowler.com/eaaCatalog/repository.html" target="_blank" rel="noopener">Repository Pattern</a> 的策略—— 通过一个工厂，根据不同的条件抓取不同的数据源。比如，当通过 id 来获取一个 user 时，如果这个 user 在缓存中不存在，那么它会选择磁盘缓存作为数据源，如果磁盘缓存也不存在它会通过云端接口获取数据，并保存在本地缓存中。</p><h4 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h4><p>这是一个值得讨论的话题，非常欢迎任何分享。我的策略是实用回调机制。如果 DataRepo 发生变化，回调接口提供两个方法：onResponse() 和 onError(), 后者把错误封装在 ErrorBundle 类里面：这种处理方式带来一个问题，错误通过层层传递（就是异步编程中常见的 <a href="http://callbackhell.com/" target="_blank" rel="noopener">CallbackHell</a> 问题 ）导致代码可读性变差。</p><p>或者可以使用 EventBus 来处理，但是这种方式有点像 <a href="http://www.drdobbs.com/jvm/programming-with-reason-why-is-goto-bad/228200966" target="_blank" rel="noopener">GOTO</a> 会导致代码逻辑混乱。</p><p>github代码示例：<br><a href="https://github.com/android10/Android-CleanArchitecture" target="_blank" rel="noopener">Here is the github link</a></p><hr><p>基于 android-architecture-todoapp-mvp，使用Clean Architecture的概念来实现。参见链接：<br><a href="https://github.com/stateofzhao/android-architecture-todoapp-mvp-clean" target="_blank" rel="noopener">https://github.com/stateofzhao/android-architecture-todoapp-mvp-clean</a></p><p>在这里唠叨下MVP和MVP-Clean的不同：</p><ul><li>MVP，Presenter直接持并操作数据层UserRepository，数据层就被看做是MVP中的M了。由于Presenter对业务逻辑至关重要，所以Presenter不光起到隔离Model与View的作用，还起到具体业务逻辑实现的作用，导致Presenter比较臃肿，不便于业务功能的扩展。</li><li>MVP-Clean，这个是MVP结合Clean Architecture来使用的，不让Presenter直接处理数据层，而是使用Domain Layer把数据层与上层（Presenter和View）彻底隔离起来，所有的业务逻辑都是在这层处理的，考虑到Android工程，你会看到所有的 interactors (use cases) 也是在这里实现的，这一层是纯java模块，不包含任何Android依赖；Presenter是由各种interactors (use cases) 组成，Presenter其实就是起到一个数据转换作用，把数据层的数据封装成View需要显示的数据；数据层UserRepository（实现了DomainLayer的接口）与上面的基本MVP数据层一样，就是提供APP需要的各种数据，注意数据层需要实现DomainLayer层提供的接口，但是在官方例子中，数据层接口直接放到数据层里面。</li></ul><p>通过上面的理解，可以看出俩MVP中的M是一个相当泛类的指代，它并不是指具体的一个类，比如在基本MVP中它指数据层；而在MVP-Clean中指UseCase层的各种useCase。</p><h1 id="与MVP很相近的MVC模式"><a href="#与MVP很相近的MVC模式" class="headerlink" title="与MVP很相近的MVC模式"></a>与MVP很相近的MVC模式</h1><p>参见知乎上的一个链接：<br><a href="https://www.zhihu.com/question/22886622" target="_blank" rel="noopener">https://www.zhihu.com/question/22886622</a></p><p>回答中讲解的非常好，看了后发现我之前理解的Model和Controller完全是错误的！</p><p>参考文章：<br><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h1&gt;&lt;p&gt;这里一定要说明一下，对于MVP,MVC,MVVM,Clean Architecture 等都只是设计思想，并不是代码框架，具体的框架需要来使
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="Android" scheme="https://meandni.com/tags/Android/"/>
    
      <category term="架构" scheme="https://meandni.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="模块化" scheme="https://meandni.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>理解 IntelliJ IDEA 的项目配置和Web部署</title>
    <link href="https://meandni.com/2018/10/10/a03f/"/>
    <id>https://meandni.com/2018/10/10/a03f/</id>
    <published>2018-10-10T04:37:00.230Z</published>
    <updated>2019-01-03T13:43:16.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、项目配置的理解"><a href="#1、项目配置的理解" class="headerlink" title="1、项目配置的理解"></a>1、项目配置的理解</h1><p>IDEA 中最重要的各种设置项，就是这个 Project Structre 了，关乎你的项目运行，缺胳膊少腿都不行。最近学校正好也是用之前自己比较熟悉的IDEA而不是Eclipse，为了更深入理解和使用，就找来各种资料再研究一下，这里整理后来个输出。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="1-1-Project"><a href="#1-1-Project" class="headerlink" title="1.1 Project"></a>1.1 Project</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol><li><strong>Project name</strong>：定义项目的名称；</li><li><strong>Project SDK</strong>：设置该项目使用的JDK，也可以在此处新添加其他版本的JDK；</li><li><strong>Project language level</strong>：这个和JDK的类似，区别在于，假如你设置了JDK1.8，却只用到1.6的特性，那么这里可以设置语言等级为1.6，这个是限定项目编译检查时最低要求的JDK特性；</li><li><strong>Project compiler output</strong>：项目中的默认编译输出总目录，如图黄色部分，实际上每个模块可以自己设置特殊的输出目录（Modules - (project) - Paths - Use module compile output path），所以这个设置有点鸡肋。</li></ol><h2 id="1-2-Modules"><a href="#1-2-Modules" class="headerlink" title="1.2 Modules"></a>1.2 Modules</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-2-1-增删子项目"><a href="#1-2-1-增删子项目" class="headerlink" title="1.2.1 增删子项目"></a>1.2.1 增删子项目</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>一个项目中可以有多个子项目，每个子项目相当于一个模块。一般我们项目只是单独的一个，IntelliJ IDEA 默认也是单子项目的形式，所以只需要配置一个模块。</p><p>（此处的两个项目引入仅作示例参考）</p><h3 id="1-2-2-子项目配置"><a href="#1-2-2-子项目配置" class="headerlink" title="1.2.2 子项目配置"></a>1.2.2 子项目配置</h3><p>每个子项目都对应了Sources、Paths、Dependencies 三大配置选项：</p><ul><li><strong>Sources</strong>：显示项目的目录资源，那些是项目部署的时候需要的目录，不同颜色代表不同的类型；</li><li><strong>Paths</strong>：可以指定项目的编译输出目录，即项目类和测试类的编译输出地址（替换掉了Project的默认输出地址）</li><li><strong>Dependencies</strong>：项目的依赖</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-2-3-增删框架（Web部署-1）"><a href="#1-2-3-增删框架（Web部署-1）" class="headerlink" title="1.2.3 增删框架（Web部署-1）"></a>1.2.3 增删框架（Web部署-1）</h3><p>每个子项目之下都可以定义它所使用的框架，这里重点说明一下Web部分的设置。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="1-3-Libraries"><a href="#1-3-Libraries" class="headerlink" title="1.3 Libraries"></a>1.3 Libraries</h2><p>这里可以显示所添加的jar包，同时也可以添加jar包，并且可以把多个jar放在一个组里面，类似于jar包整理。</p><p>这里默认将每个jar包做为了一个单独的组（未测试，待定）。</p><h2 id="1-4-Facets"><a href="#1-4-Facets" class="headerlink" title="1.4 Facets"></a>1.4 Facets</h2><p>官方的解释是：</p><p>When you select a framework (a facet) in the element selector pane, the settings for the framework are shown in the right-hand part of the dialog.</p><p>（当你在左边选择面板点击某个技术框架，右边将会显示这个框架的一些设置）</p><p>说实话，并没有感觉到有什么作用。</p><h2 id="1-5-Artifacts（Web部署-2）"><a href="#1-5-Artifacts（Web部署-2）" class="headerlink" title="1.5 Artifacts（Web部署-2）"></a>1.5 Artifacts（Web部署-2）</h2><p>项目的打包部署设置，这个是项目配置里面比较关键的地方，重点说一下。</p><p>先理解下它的含义，来看看官方定义的artifacts：</p><p>An artifact is an assembly of your project assets that you put together to test, deploy or distribute your software solution or its part. Examples are a collection of compiled Java classes or a Java application packaged in a Java archive, a Web application as a directory structure or a Web application archive, etc.</p><p>即编译后的Java类，Web资源等的整合，用以测试、部署等工作。再白话一点，就是说某个module要如何打包，例如war exploded、war、jar、ear等等这种打包形式。某个module有了 Artifacts 就可以部署到应用服务器中了。</p><p><em>（</em></p><p><strong>*jar</strong>：Java ARchive，通常用于聚合大量的Java类文件、相关的元数据和资源（文本、图片等）文件到一个文件，以便分发Java平台应用软件或库；*</p><p><strong>*war</strong>：Web application ARchive，一种JAR文件，其中包含用来分发的JSP、Java Servlet、Java类、XML文件、标签库、静态网页（HTML和相关文件），以及构成Web应用程序的其他资源；*</p><p><strong>*exploded</strong>：在这里你可以理解为展开，不压缩的意思。也就是war、jar等产出物没压缩前的目录结构。建议在开发的时候使用这种模式，便于修改了文件的效果立刻显现出来。*</p><p><em>）</em></p><p>默认情况下，IDEA的 Modules 和 Artifacts 的 output目录已经设置好了，不需要更改，打成war包的时候会自动在 WEB-INF目录下生成classes，然后把编译后的文件放进去。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>你可能对这里的输出目录不太理解，之前不是配置过了文件编译的输出目录了吗？为什么这里还有一个整合这些资源的目录呢？它又做了哪些事呢？ </p><p>==其实，实际上，当你点击运行tomcat时，默认就开始做以下事情：==</p><ul><li>编译，IDEA在保存/自动保存后不会做编译，不像Eclipse的保存即编译，因此在运行server前会做一次编译。编译后class文件存放在指定的项目编译输出目录下（见1.2.2）；</li><li>根据artifact中的设定对目录结构进行创建；</li><li>拷贝web资源的根目录下的所有文件到artifact的目录下（见1.2.3）；</li><li>拷贝编译输出目录下的classes目录到artifact下的WEB-INF下（见1.2.2）；</li><li>拷贝lib目录下所需的jar包到artifact下的WEB_INF下；</li><li>运行server，运行成功后，如有需要，会自动打开浏览器访问指定url。</li></ul><p>在这里还要注意的是，配置完成的artifact，需要在tomcat中进行添加：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="2、参考链接"><a href="#2、参考链接" class="headerlink" title="2、参考链接"></a>2、参考链接</h1><ul><li><a href="http://whudoc.qiniudn.com/2016/IntelliJ-IDEA-Tutorial/project-composition-introduce.html" target="_blank" rel="noopener">IntelliJ IDEA 项目相关的几个重要概念介绍</a></li><li><a href="https://www.jetbrains.com/help/idea/2016.3/dependencies-tab.html?search=project%20structure" target="_blank" rel="noopener">Dependencies Tab</a></li><li><a href="https://www.jetbrains.com/help/idea/2016.3/facet-page.html?search=project%20structure" target="_blank" rel="noopener">Facet Page</a></li><li><a href="https://www.jetbrains.com/help/idea/2016.3/working-with-artifacts.html#artifact_def" target="_blank" rel="noopener">Working with Artifacts</a></li><li><a href="http://www.cnblogs.com/52php/p/5677661.html" target="_blank" rel="noopener">Intellij IDEA 14.x 中的Facets和Artifacts的区别</a></li><li><a href="http://white-crucifix.iteye.com/blog/2070830" target="_blank" rel="noopener">IntelliJ使用指南—— 深入理解IntelliJ的Web部署逻辑</a></li><li><a href="https://my.oschina.net/lujianing/blog/186737" target="_blank" rel="noopener">IntelliJ IDEA WEB项目的部署配置</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、项目配置的理解&quot;&gt;&lt;a href=&quot;#1、项目配置的理解&quot; class=&quot;headerlink&quot; title=&quot;1、项目配置的理解&quot;&gt;&lt;/a&gt;1、项目配置的理解&lt;/h1&gt;&lt;p&gt;IDEA 中最重要的各种设置项，就是这个 Project Structre 了，关乎
      
    
    </summary>
    
      <category term="非原创" scheme="https://meandni.com/categories/%E9%9D%9E%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="软件" scheme="https://meandni.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="IntelliJ IDEA" scheme="https://meandni.com/tags/IntelliJ-IDEA/"/>
    
      <category term="javaweb" scheme="https://meandni.com/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>2018.10.5有感！</title>
    <link href="https://meandni.com/2018/10/05/3a4f/"/>
    <id>https://meandni.com/2018/10/05/3a4f/</id>
    <published>2018-10-05T14:33:37.782Z</published>
    <updated>2019-01-03T13:38:52.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>本来想着不回家的，我可能已经被击垮了，但在他们的诱导下还是去了苏州准备和他们一起回去，在苏州车站一个人等郑来接我的时候就感觉到了一个人的孤独（现在我时刻感觉孤独），如果以后都是我一个人面对将来的生活和各种痛苦我该怎么活，我不想像我的一些朋友一样毕业了就开始了孤单落寞颓废的生活，先把bug立在这边，<strong>毕业后不能孤单。</strong></p><p>现在唯一能做的是什么？？？我觉得未来比较迷茫 ^ ^，我觉得现在能做的还得是把自己的欲望收敛起来，这可能比较困难，已不复当年了，过去是多么的美好，但现在回想起来我怎么错过了那么多美好的东西和机会。再立一个bug，<strong>把握住美好的机会啊。</strong></p><p>后悔过去很多事情，事实是不能重来了！做梦都不能想！但我本来就不能做到我表现出来的那么洒脱啊（我尽量都表现的洒脱），我好像失去出去的动力了，感觉如果不能改变现状，我宁愿一直平平淡淡的呆在家里！但还是要锻炼身体的啊（已成习惯，不练练肌肉感觉自己就废了！“告诉他们我还能 <em> </em>”），奉劝自己啊，<strong>不要再做让自己后悔的事情。</strong></p><p>我可能就是一个现实和理想大幅度不同的人，想到就很不自信，但又不想承认，有时看到身边的消极人物竟还为我有这种心思而自豪（是我太优秀了吗？别人都不这么想的吗？），我看似活的越来越像想象中的自己了，但我眼界好像越来越窄了，我面对别的人物过于高傲了，过于把自己放在太高的位置了，我面对的都些什么人啊！对于我的不自信我是真的不想承认的啊，不应该啊，我可能对自己要求过于严格 ^ ^。<strong>那就继续对自己严格  = =。</strong></p><hr><p>我希望啊，未来的生活都会是像我现在想的那样啊，没好啊，充实啊，有一点剧情啊！但现实又告诉我一切都不是尽如人意的，这有别人的原因，但错在自己！尽力把握自己能做到的，然后就是。。。。。该放弃的放弃！今天啊，我就重拾了我过去喜欢写怪文的习惯，但以前的找不到了= =。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生活&quot;&gt;&lt;a href=&quot;#生活&quot; class=&quot;headerlink&quot; title=&quot;生活&quot;&gt;&lt;/a&gt;生活&lt;/h2&gt;&lt;p&gt;本来想着不回家的，我可能已经被击垮了，但在他们的诱导下还是去了苏州准备和他们一起回去，在苏州车站一个人等郑来接我的时候就感觉到了一个人的孤独
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="感想" scheme="https://meandni.com/tags/%E6%84%9F%E6%83%B3/"/>
    
      <category term="人生" scheme="https://meandni.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>推荐一下Typora：极致简洁的markdown编辑器</title>
    <link href="https://meandni.com/2018/09/12/1011/"/>
    <id>https://meandni.com/2018/09/12/1011/</id>
    <published>2018-09-12T02:32:42.000Z</published>
    <updated>2019-01-03T13:44:55.793Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/1443947-bf3776592815de57.png" alt="typora" title="">                </div>                <div class="image-caption">typora</div>            </figure><p>官网：<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p><p>如果你还不了解 Markdown 及相关背景知识，可以参见：</p><ul><li><a href="https://sspai.com/25137" target="_blank" rel="noopener">《认识与入门 Markdown》</a></li><li><a href="https://sspai.com/27792" target="_blank" rel="noopener">《解决作者们的焦虑：7 款优秀 Markdown 编辑工具推荐》</a></li></ul><hr><p>然而看看市面上现在比较流行的 Markdown 编辑器，都基本采用了「写字」和「预览」相分离的策略，无论是像 Mou 这样将窗口左右排列，还是像 Typed 一样两种状态需要切换显示，都似乎离 Markdown 的初衷渐行渐远：优雅可控的格式是为了让文字本身更易读。然而，在实际使用的时候，由于文字的输入源和文字的输出源是割裂的，这件事情本身就显得不纯粹，再加上众多 Markdown 编辑器始终没有着手解决表格、代码等格式的编辑，也使 Markdown 变得不那么优雅。是的，如果你用 Markdown 原生格式去编辑过一个表格，你应该懂我的</p><h2 id="看看-Typora-是怎么解决这个问题的"><a href="#看看-Typora-是怎么解决这个问题的" class="headerlink" title="看看 Typora 是怎么解决这个问题的"></a>看看 Typora 是怎么解决这个问题的</h2><p>无意中发现了 Typora 这款 Markdown 编辑器。第一眼看上去它就像任何一款 Markdown 编辑器的同类，尤其是 Mou，但再看一眼，你就发现，它是如此的不同。</p><p>因为它将「写字」和「预览」这两件事情合并了，你输入的地方，也是输出的地方，即现在很流行的 WYSIWYG（What You See Is What You Get）。其实转念一想，这不就是回到了 Office Word 嘛，只不过编辑文本时不用再去工具栏上点选，一切的格式都能通过符号来控制。</p><p>用 Typora 官方的介绍视频，你就懂这一切是多么的自然。没错，所有的行内元素（如加粗、斜体）都会根据当前是否在编辑态而智能地在编辑态和预览态切换，而区块级元素（如标题、列表）则会在按下 Enter 后即时渲染，不能再次编辑。</p><p>一切都变得如此干净、纯粹。</p><p> 当然，Typora 的强大之处不仅仅在于颠覆了 Markdown 编辑器传统的交互模式，它还引入了一系列强大的功能，一起看看吧。</p><h2 id="Typora中MarkDown的使用"><a href="#Typora中MarkDown的使用" class="headerlink" title="Typora中MarkDown的使用"></a>Typora中MarkDown的使用</h2><p>官网演示地址：<a href="https://support.typora.io/Markdown-Reference/" target="_blank" rel="noopener">https://support.typora.io/Markdown-Reference/</a></p><p><strong>最大的特点应该就是即时预览，我主要觉得非常简洁漂亮！</strong></p><h3 id="我自己在博客中的测试"><a href="#我自己在博客中的测试" class="headerlink" title="我自己在博客中的测试"></a>我自己在博客中的测试</h3><ul><li style="list-style: none"><input type="checkbox"> 没有完成</li><li style="list-style: none"><input type="checkbox" checked> 已完成</li></ul><table><thead><tr><th>first</th><th>second</th></tr></thead><tbody><tr><td>Hashes</td><td>shshh</td></tr></tbody></table><p>Here is the <em>text</em> of the <strong>footnote</strong>.</p><h2 id="Pandoc的安装与使用"><a href="#Pandoc的安装与使用" class="headerlink" title="Pandoc的安装与使用"></a>Pandoc的安装与使用</h2><p>官网地址： <a href="https://support.typora.io/Install-and-Use-Pandoc/" target="_blank" rel="noopener">https://support.typora.io/Install-and-Use-Pandoc/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="非原创" scheme="https://meandni.com/categories/%E9%9D%9E%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="markdown" scheme="https://meandni.com/tags/markdown/"/>
    
      <category term="软件" scheme="https://meandni.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>《The Modern Javascript Tutorial》：javascript中的&quot;this&quot;</title>
    <link href="https://meandni.com/2018/09/08/f1a1/"/>
    <id>https://meandni.com/2018/09/08/f1a1/</id>
    <published>2018-09-08T03:25:47.000Z</published>
    <updated>2019-01-03T15:17:09.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象方法与-“this”"><a href="#对象方法与-“this”" class="headerlink" title="对象方法与 “this”"></a>对象方法与 “this”</h1><p>对象通常被用来表示真实世界中的实体，比如用户、订单等等：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>另外，在现实世界中，用户可以<strong>操作</strong>：从购物车中挑选某物、登录、注销等。</p><p>在 JavaScript 中，操作通过属性中的函数来表示。</p><h2 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h2><p>刚开始，我们来让 <code>user</code> 说 hello：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line">user.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">user.sayHi(); /</span><span class="regexp">/ Hello!</span></span><br></pre></td></tr></table></figure><p>这里我们使用函数表达式创建了函数，并将其指定给对象的 <code>user.sayHi</code> 属性。</p><p>随后我们调用它。用户现在可以说话了！</p><p>作为对象属性的函数称之为<strong>方法</strong>。</p><p>那么，现在 <code>user</code> 对象有了一个 <code>sayHi</code> 方法。</p><p>当然我们也可以使用预先定义的函数作为方法，就像这样：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line"><span class="comment">// 首先声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将其作为一个方法</span></span><br><span class="line">user.sayHi = sayHi;</span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">user.sayHi(); /</span><span class="regexp">/ Hello!</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>header</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当我们在代码中用对象表示实体时，这就是所谓的[面向对象编程](https://en.wikipedia.org/wiki/Object-oriented_programming)，简称为 &quot;OOP&quot;。</span><br><span class="line"></span><br><span class="line">OOP 是一门很大的学问，也是一门有其本身乐趣的学问。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于此方面的书，例如 E.Gamma、R.Helm、R.Johnson 和 J.Vissides 所著的《设计模式：可复用面向对象软件的基础》、G.Booch 所著的《面向对象分析与设计》等等。在后面的 &lt;info:object-oriented-programming&gt; 一章中，我们将会触及这个主题的浅层内容。</span><br></pre></td></tr></table></figure><h3 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h3><p>在对象字面量中，有一种更短的（声明）方法的语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些对象作用一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法简写看起来更好，对吧？</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">*!*</span><br><span class="line">  sayHi() &#123; <span class="comment">// 与 "sayHi: function()" 一样</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">    alert("Hello");</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>如所示，我们可以省略 <code>&quot;function&quot;</code> 只写了 <code>sayHi()</code>。</p><p>说实话，这种表示法还是有些不同。与对象集成有关的细微差别（稍后将会介绍），但现在它们无关紧要。在几乎所有的情况下，较短的语法是最好的。</p><h2 id="方法中的-“this”"><a href="#方法中的-“this”" class="headerlink" title="方法中的 “this”"></a>方法中的 “this”</h2><p>对象方法需要访问对象中的存储的信息完成其工作是很常见的。</p><p>举个例子，<code>user.sayHi()</code> 中的代码可能需要用到 <code>user</code> 的 name 属性。</p><p><strong>为了访问该对象，方法中可以使用 <code>this</code> 关键字。</strong></p><p><code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p><p>举个例子：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">*!*</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">user.sayHi(); /</span><span class="regexp">/ John</span></span><br></pre></td></tr></table></figure><p>在这里 <code>user.sayHi()</code> 执行过程中，<code>this</code> 的值是 <code>user</code>。</p><p>技术上讲，也可以在不使用 <code>this</code> 的情况下，通过外部变量名来引用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">*!*</span><br><span class="line">    alert(user.name); <span class="comment">// "user" 替代 "this"</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p>但这样的代码是不可靠的。如果我们将 <code>user</code> 复制给另一个变量。例如 <code>admin = user</code>，并赋另外的值给 <code>user</code>，那么它将访问到错误的对象。</p><p>如下所示：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">*!*</span><br><span class="line">    alert( user.name ); <span class="comment">// 导致错误</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let admin = user;</span></span><br><span class="line"><span class="regexp">user = null; /</span><span class="regexp">/ 覆盖让其更易懂</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">admin.sayHi(); /</span><span class="regexp">/ 噢哟！在 sayHi() 使用了旧的变量名。错误！</span></span><br></pre></td></tr></table></figure><p>如果在 <code>alert</code> 中以 <code>this.name</code> 替换 <code>user.name</code>，那么代码就会正常运行。</p><h2 id="“this”-不受限制"><a href="#“this”-不受限制" class="headerlink" title="“this” 不受限制"></a>“this” 不受限制</h2><p>在 JavaScript 中，”this” 关键字与大多数其他编程语言中的不同。首先，它可以用于任何函数。</p><p>这样的代码没有语法错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( *!*<span class="keyword">this</span>*<span class="regexp">/!*.name );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>this</code> 是在运行时求值的。它可以是任何值。</p><p>例如，从不同的对象中调用同一个函数可能会有不同的 “this” 值：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">"John"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">"Admin"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="keyword">this</span>.name );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line"><span class="comment">// 在两个对象中使用的是相同的函数</span></span><br><span class="line">user.f = sayHi;</span><br><span class="line">admin.f = sayHi;</span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 它们调用时有不同的 this 值。</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 函数内部的 "this" 是点之前的这个对象。</span></span><br><span class="line"><span class="regexp">user.f(); /</span><span class="regexp">/ John  (this == user)</span></span><br><span class="line"><span class="regexp">admin.f(); /</span><span class="regexp">/ Admin  (this == admin)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">admin['f'](); /</span><span class="regexp">/ Admin（使用点或方括号语法来访问这个方法，都没有关系。）</span></span><br></pre></td></tr></table></figure><p>实际上，我们可以在没有任何对象的情况下调用函数：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。如果我们尝试访问 <code>this.name</code>，将会出现错误。</p><p>在非严格模式（没有使用 <code>use strict</code>）的情况下，<code>this</code> 将会是<strong>全局对象</strong>（浏览器中的 <code>window</code>，我们稍后会进行讨论）。<code>&quot;use strict&quot;</code> 可以修复这个历史行为。</p><p>请注意，通常在没有对象的情况下使用 <code>this</code> 的函数调用是不常见的，会（导致）编程错误。如果函数中有 <code>this</code>，那么通常意味着它是在对象上下文环境中被调用的。</p><figure class="highlight plain"><figcaption><span>header</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果你来自其他的编程语言，那么你可能熟悉『绑定 `this`』的概念。在对象定义的方法中，`this` 总是指向该对象。</span><br><span class="line"></span><br><span class="line">在 JavaScript 中，`this` 是『自由』的，它的值是在调用时进行求值的，它的值并不取决于方法声明的位置，而是（取决）于在『点之前』的是什么对象。</span><br><span class="line"></span><br><span class="line">在运行时对 `this` 求值的这个想法有其优缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性给错误留下了余地。</span><br><span class="line"></span><br><span class="line">这里我们的立场并不是要评判编程语言的这个想法的好坏，而是要了解怎样使用它，如何趋利避害。</span><br></pre></td></tr></table></figure><h2 id="内部：引用类型"><a href="#内部：引用类型" class="headerlink" title="内部：引用类型"></a>内部：引用类型</h2><p>​<figure class="highlight plain"><figcaption><span>header</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本文介绍一个进阶的主题，来更好地理解一些特殊情况。</span><br><span class="line"></span><br><span class="line">如果你想学得更快，这部分你可以跳过或过后来读。</span><br></pre></td></tr></table></figure></p><p>『复杂』的方法调用可能会失去 <code>this</code>，比如：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  hi() &#123; alert(<span class="keyword">this</span>.name); &#125;,</span><br><span class="line">  bye() &#123; alert(<span class="string">"Bye"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.hi(); <span class="comment">// John (the simple call works)</span></span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line"><span class="comment">// 现在我们要判断 name 属性，来决定调用 user.hi 或是 user.bye。</span></span><br><span class="line">(user.name == <span class="string">"John"</span> ? user.hi : user.bye)(); <span class="comment">// Error!</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br></pre></td></tr></table></figure><p>最后一行中有一个三元运算符，它要判断是 <code>user.hi</code> 或 <code>user.bye</code>。在这种情况下，结果会是 <code>user.hi</code>。</p><p>该方法立即被括号 <code>()</code> 调用。但它无效。</p><p>你可以看到该调用导致了错误，因为调用中的 <code>&quot;this&quot;</code> 为 <code>undefined</code>。</p><p>这样是正确的（对象点方法）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.hi();</span><br></pre></td></tr></table></figure><p>这样没有效果（对方法求值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(user.name == <span class="string">"John"</span> ? user.hi : user.bye)(); <span class="comment">// 错误！</span></span><br></pre></td></tr></table></figure><p>原因是什么？如果我们想了解为什么会这样，那么我们要深入理解 <code>obj.method()</code> 调用的原理。</p><p>仔细看，我们可能注意到 <code>obj.method()</code> 语句中有两个操作符。</p><ol><li>首先，点 <code>&#39;.&#39;</code> 取得这个 <code>obj.method</code> 属性。</li><li>其后的括号 <code>()</code> 调用它。</li></ol><p>那么，<code>this</code> 是如何从第一部分传递到第二部分的呢？</p><p>如果把这些操作分离开，那么 <code>this</code> 肯定会丢失：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  hi() &#123; alert(<span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line"><span class="comment">// 将赋值与方法调用拆分为两行</span></span><br><span class="line"><span class="keyword">let</span> hi = user.hi;</span><br><span class="line">hi(); <span class="comment">// 错误，因为 this 未定义</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br></pre></td></tr></table></figure><p>这里 <code>hi = user.hi</code> 把函数赋值给变量，其后的最后一行是完全独立的，所以它没有 <code>this</code>。</p><p><strong>为了让 <code>user.hi()</code> 有效，JavaScript 用一个技巧 —— 这个 <code>&#39;.&#39;</code> 点返回的不是一个函数, 而是一种特殊的[引用类型]的值(<a href="https://tc39.github.io/ecma262/#sec-reference-specification-type)" target="_blank" rel="noopener">https://tc39.github.io/ecma262/#sec-reference-specification-type)</a>.</strong></p><p>引用类型是一种『规范中有的类型』。我们不能明确地指定它，但是可以在语言内部使用。</p><p>引用类型的值是三点的结合 <code>(base, name, strict)</code>，如下：</p><ul><li><code>base</code> 是对象。</li><li><code>name</code> 是属性。</li><li>当 <code>use strict</code> 生效，<code>strict</code> 为真。</li></ul><p><code>user.hi</code> 属性访问的值不是函数，而是引用类型的值。在严格模式下，<code>user.hi</code> 是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用类型值</span></span><br><span class="line">(user, <span class="string">"hi"</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>当在引用类型上用 <code>()</code> 调用时，它们接收到这个对象和它的方法的所有信息，并且设定正确的 <code>this</code> 值（这里等于 <code>user</code>）。</p><p><code>hi = user.hi</code> 赋值等其他的操作，将引用类型作为一个整体丢弃，只获取 <code>user.hi</code>（一个函数）的值进行传递。因此，进一步操作『失去』了 <code>this</code>（值）。</p><p>所以如果直接使用点 <code>obj.method()</code> 或方括号语法 <code>obj[method]()</code>（它们在这里并无差别）调用函数，那么作为结果，<code>this</code> 值会以正确的方式进行传递。</p><h2 id="箭头函数没有自己的-“this”"><a href="#箭头函数没有自己的-“this”" class="headerlink" title="箭头函数没有自己的 “this”"></a>箭头函数没有自己的 “this”</h2><p>箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部『正常的』函数。</p><p>举个例子，这里的 <code>arrow()</code> 使用的 <code>this</code> 来自外部的 <code>user.sayHi()</code> 方法：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">"Ilya"</span>,</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="keyword">let</span> arrow = <span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="keyword">this</span>.firstName);</span><br><span class="line">    arrow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.sayHi(); <span class="comment">// Ilya</span></span><br></pre></td></tr></table></figure><p>这是箭头函数的一个特征，当我们并不想要一个独立的 <code>this</code> 值，反而想从外部上下文中获取时，它很有用。在后面的章节 <a href="info:arrow-functions" target="_blank" rel="noopener">info:arrow-functions</a> 中我们将更深入地介绍箭头函数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>存储在对象中函数称之为『方法』。</li><li>对象执行方法进行『操作』，比如 <code>object.doSomething()</code>。</li><li>方法可以将该对象引用为 <code>this</code>。</li></ul><p><code>this</code> 的值是在运行时求值的。</p><ul><li>函数声明使用的 <code>this</code> 只有等到调用时才会有值。</li><li>函数可以在对象之间进行共用。</li><li>当函数使用『方法』语法 <code>object.method()</code> 调用时，调用过程中的 <code>this</code> 总是指向 <code>object</code>。</li></ul><p>请注意箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问的都是来自外部的 <code>this</code> 值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对象方法与-“this”&quot;&gt;&lt;a href=&quot;#对象方法与-“this”&quot; class=&quot;headerlink&quot; title=&quot;对象方法与 “this”&quot;&gt;&lt;/a&gt;对象方法与 “this”&lt;/h1&gt;&lt;p&gt;对象通常被用来表示真实世界中的实体，比如用户、订单等等：&lt;/
      
    
    </summary>
    
      <category term="非原创" scheme="https://meandni.com/categories/%E9%9D%9E%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="https://meandni.com/tags/javascript/"/>
    
      <category term="读书" scheme="https://meandni.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《The Modern Javascript Tutorial》：javascript递归函数的分析</title>
    <link href="https://meandni.com/2018/09/07/f1a1/"/>
    <id>https://meandni.com/2018/09/07/f1a1/</id>
    <published>2018-09-07T03:25:47.000Z</published>
    <updated>2019-01-03T15:17:22.098Z</updated>
    
    <content type="html"><![CDATA[<p>递归和堆栈</p><p>我们回到函数，深入研究一下。</p><p>我们的第一个主题是<strong>递归</strong>。</p><p>如果你不是刚接触编程，那么你可能已经很熟悉它，可以跳过这一章了。</p><p>递归是一种编程模式，用于一个任务可以被分割为多个相似的更简单的任务的场景。或者用于一个任务可以被简化为一个容易的行为加上更简单的任务变体。或者像我们随后会看到的，用来处理特定类型的数据结构。</p><p>当一个函数解决一个任务时，在该过程中它可以调用很多其它函数。那么当一个函数调用<strong>自身</strong>时，就称其为<strong>递归</strong>。</p><h2 id="两种思考方式"><a href="#两种思考方式" class="headerlink" title="两种思考方式"></a>两种思考方式</h2><p>简单起见，我们写一个函数 <code>pow(x, n)</code>，它可以计算 <code>x</code> 的 <code>n</code> 次方，即用 <code>x</code> 乘以自身 <code>n</code> 次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pow(<span class="number">2</span>, <span class="number">2</span>) = <span class="number">4</span></span><br><span class="line">pow(<span class="number">2</span>, <span class="number">3</span>) = <span class="number">8</span></span><br><span class="line">pow(<span class="number">2</span>, <span class="number">4</span>) = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>有两种实现方式。</p><ol><li><p>迭代思路：<code>for</code> 循环：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在循环中用 x 乘以 result</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    result *= x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( pow(<span class="number">2</span>, <span class="number">3</span>) ); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></li><li><p>递归思路：简化任务，调用自身：</p><figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * pow(x, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert( pow(<span class="number">2</span>, <span class="number">3</span>) ); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></li></ol><p>注意递归方式完全不相同。</p><p>当 <code>pow(x, n)</code> 被调用时，执行分为两个分支：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">              <span class="keyword">if</span> n==<span class="number">1</span>  = x</span><br><span class="line">             /</span><br><span class="line">pow(x, n) =</span><br><span class="line">             \       </span><br><span class="line">              <span class="keyword">else</span>     = x * pow(x, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ol><li>如果 <code>n == 1</code>，所有事情都会很简单，这叫做递归的<strong>基础</strong>，因为它立即得到显而易见的结果：<code>pow(x, 1)</code> 等于 <code>x</code>。</li><li>否则，我们可以用 <code>x * pow(x, n - 1)</code> 表示 <code>pow(x, n)</code>。在数学里，可能会这么写 <code>x<sup>n</sup> = x * x<sup>n-1</sup></code>。这叫做<strong>一个递归步骤</strong>：我们将任务转变为更简单的行为（<code>x</code> 的乘法）和更简单的同类任务调用（更小的 <code>n</code> 给 <code>pow</code>）。后面步骤继续简化直到 <code>n</code> 等于 <code>1</code>。</li></ol><p>我们也可以说 <code>pow</code> <strong>递归的调用自身</strong> 直到 <code>n == 1</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;递归和堆栈&lt;/p&gt;
&lt;p&gt;我们回到函数，深入研究一下。&lt;/p&gt;
&lt;p&gt;我们的第一个主题是&lt;strong&gt;递归&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果你不是刚接触编程，那么你可能已经很熟悉它，可以跳过这一章了。&lt;/p&gt;
&lt;p&gt;递归是一种编程模式，用于一个任务可以被分割为多个相
      
    
    </summary>
    
      <category term="非原创" scheme="https://meandni.com/categories/%E9%9D%9E%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="javascript" scheme="https://meandni.com/tags/javascript/"/>
    
      <category term="读书" scheme="https://meandni.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>跨平台方案：Weex使用小记</title>
    <link href="https://meandni.com/2018/08/22/3a79/"/>
    <id>https://meandni.com/2018/08/22/3a79/</id>
    <published>2018-08-22T03:25:47.000Z</published>
    <updated>2019-01-03T14:34:55.709Z</updated>
    
    <content type="html"><![CDATA[<p>还记得刚接触ReactNative时有多激动，此前还没想过能有这么强大的框架，后来对看多了混合开发的资料发现这真的已经成了不许要学会的一个技能，于是招收学习起了React，效果不尽人意，可能是先接触了Vue，已经习惯了它的开放方式，对React总是用不习惯，有些知识点甚至不能掌握更别提做出格完整的项目了，于是就我而言React是没有Vue好用的，之前也在网上找过Vue有没有类似Native的框架，了解了NativeScript发现国内用的人比较少，文档都是全英文（虽并无大碍）但坑太多我自己安装起来也比较吃力，于是有放弃了对VueNative的探索，继续学习RN～～～还算入门了，但就是不习惯啊，偶然想到另一门技术Weex，之前看到过但并不知道它是基于Vue的跨平台框架于是没去学习，了解后发现它原来是阿里开发的，它原来是基于Vue的，虽然用的人还不多，但他原来有那么全的中文文档～～～卧槽。。。。</p><p>用所有的东西都是有坑的，但我坚信对我而言国内人开发的东西会极大的亲近我们，于是开始了搭建环境、学习的旅程。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>相比NativeScript，Weex简直是水到渠成，web端一下子就能运行起来，而且代码是那么的熟悉，Vue在心中已有一席之地，想想以后的混合开发会是如此的畅快！</p><ol><li>安装脚手架</li></ol><p><code>npm install weex-toolkit -g</code></p><ol start="2"><li>创建项目</li></ol><p><code>weex create awesome-app</code></p><ol start="3"><li>运行项目</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd awesome-app</span><br><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://weex.apache.org/guide/images/toolkit-preview.png" alt="Weex" title="">                </div>                <div class="image-caption">Weex</div>            </figure><h2 id="android端运行"><a href="#android端运行" class="headerlink" title="android端运行"></a>android端运行</h2><ul><li>添加特定平台的项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weex platform add ios</span><br><span class="line">weex platform add android</span><br></pre></td></tr></table></figure><p>官网都说了：</p><blockquote><p>由于网络环境的不同，安装过程可能需要一些时间，请耐心等待。如果安装失败，请确保自己的网络环境畅通。</p></blockquote><p>所以昨晚在这一步发生的错误应该就是网络的原因，今天早上网络流畅点就好了</p><ul><li>在本地机器上打开 Android 和 iOS 项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weex run ios</span><br><span class="line">weex run android</span><br><span class="line">weex run web</span><br></pre></td></tr></table></figure><p>下面是运行中遇到的一些问题：</p><h3 id="studio3-0对其的不兼容"><a href="#studio3-0对其的不兼容" class="headerlink" title="studio3.0对其的不兼容"></a>studio3.0对其的不兼容</h3><p>坑都在这里了，我想这些坑原因应该都来自于Android Studio 3.0新版特性</p><h4 id="无法下载到版本所对应的gradle"><a href="#无法下载到版本所对应的gradle" class="headerlink" title="无法下载到版本所对应的gradle"></a>无法下载到版本所对应的gradle</h4><blockquote><p>Error: Error: Command failed: ./gradlew  assembleDebug<br>Exception in thread “main” javax.net.ssl.SSLException: Connection has been shutdown: javax.net.ssl.SSLException: SSL peer shut down incorrectly</p></blockquote><p>原因：<br>由于网络被墙，无法下载到版本所对应的gradle。</p><p>解决：<br>将<code>app/platforms/android/gradle/wrapper</code>下的<code>distributionUrl</code>改为本地对应的版本号</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/QQ20180908-121118.png" alt="distributionUrl" title="">                </div>                <div class="image-caption">distributionUrl</div>            </figure><h4 id="Gradle自定义apk名称报错"><a href="#Gradle自定义apk名称报错" class="headerlink" title="Gradle自定义apk名称报错"></a>Gradle自定义apk名称报错</h4><blockquote><p>Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=debug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl.</p></blockquote><p>AS 3.0之前自定义apk名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.each &#123; output -&gt;</span><br><span class="line">    def fileName = &quot;$&#123;variant.versionName&#125;_release.apk&quot;</span><br><span class="line">    def outFile = output.outputFile</span><br><span class="line">    if (outFile != null &amp;&amp; outFile.name.endsWith(&apos;.apk&apos;)) &#123;</span><br><span class="line">        output.outputFile =newFile(outFile.parent, fileName)</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.all &#123; output -&gt;  // each 改为 all</span><br><span class="line">    def fileName = &quot;$&#123;variant.versionName&#125;_release.apk&quot;</span><br><span class="line">    def outFile = output.outputFile</span><br><span class="line">    if (outFile != null &amp;&amp; outFile.name.endsWith(&apos;.apk&apos;)) &#123;</span><br><span class="line">        outputFileName = fileName  //  output.outputFile 改为 outputFileName </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把<code>each</code>修改为<code>all</code>，然后通过<code>outputFileName</code>修改生成apk的名称。此外，AS 3.0后打包完，除了apk包文件，还会多一个 <code>output.json</code> 参数文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/QQ20180908-122053.png" alt="/awesome-app/platforms/android/app" title="">                </div>                <div class="image-caption">/awesome-app/platforms/android/app</div>            </figure><h2 id="学习！"><a href="#学习！" class="headerlink" title="学习！"></a>学习！</h2><p>下面就开始各种使用它了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还记得刚接触ReactNative时有多激动，此前还没想过能有这么强大的框架，后来对看多了混合开发的资料发现这真的已经成了不许要学会的一个技能，于是招收学习起了React，效果不尽人意，可能是先接触了Vue，已经习惯了它的开放方式，对React总是用不习惯，有些知识点甚至不
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="混合开发" scheme="https://meandni.com/tags/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>尝试翻译React英文文档</title>
    <link href="https://meandni.com/2018/08/17/react-tutorial/"/>
    <id>https://meandni.com/2018/08/17/react-tutorial/</id>
    <published>2018-08-17T12:58:00.000Z</published>
    <updated>2019-01-03T13:37:29.684Z</updated>
    
    <content type="html"><![CDATA[<p>虽然发现React是有中文网的，但是奈何一直打不开中文文档，即使我已经开了VPN，自己现在又习惯性的想看更专业的官方文档，国内的一些教程实在看不下去了，所以想着自己尝试翻译他的文档，帮助一些和我一样有强迫症患者的朋友。</p><hr><p>官网就是官网，教程真的是牛逼，react教程分为两种，实践教程（practical tutorial）和概念教程（guide to main concepts），都很好，我这里就先翻译实践教程吧！</p><hr><h2 id="实践教程-practical-tutorial"><a href="#实践教程-practical-tutorial" class="headerlink" title="实践教程(practical tutorial)"></a>实践教程(practical tutorial)</h2><h3 id="在开始实践教程之前-Before-We-Start-the-Tutorial"><a href="#在开始实践教程之前-Before-We-Start-the-Tutorial" class="headerlink" title="在开始实践教程之前(Before We Start the Tutorial)"></a>在开始实践教程之前(Before We Start the Tutorial)</h3><p>在这个教程中，我们将做一个小游戏，<strong>你千万别被吓到，你怎么这么快就能做一个游戏了，我要说的是，你并不是在做一个很厉害的游戏，我们也只是给你一个这样的机会</strong>，在这个方法的教程中,你将会学习到用react构建基础的应用并且熟练地掌握它，它也将让你充分理解React。</p><blockquote><p><strong>建议</strong><br>这个教程被设计为那些想要通过亲自动手边做边学的人，如果你更喜欢去一步一步学习概念，你可以去另一套教程里，一会发现这两套教程可以互补的学习，大家可以取他们各自的长处！</p></blockquote><p>这个教程可以被分为下面几个部分</p><ul><li>教程构建 将给你一个如何开始这个教程的指导</li><li>概述 将教你一些React的基础内容：components, props和state</li><li>小游戏项目 将教你一些在React开发过程中最通用的一些技能</li><li>历史回流 将让你对React有更深的理解，体会到React强大之处</li></ul><p>你没必要立刻掌握以上所有的部分，你可以尝试先去学你能学会的部分，没必要纠结是否自己基础是否太薄弱。</p><p>有时跟着教程拷贝代码是好事，但我们还是建议你去一步一步的去手写，那将帮助你更好的记忆和更深的理解！</p><h4 id="我们在做什么（这部分可以不看吧，有点啰嗦了）"><a href="#我们在做什么（这部分可以不看吧，有点啰嗦了）" class="headerlink" title="我们在做什么（这部分可以不看吧，有点啰嗦了）"></a>我们在做什么（这部分可以不看吧，有点啰嗦了）</h4><p>在这个教程中，我们将为你展示如何去用React开发一个交互的小游戏。</p><p>你可以先看一下游戏做出后<a href="https://codepen.io/gaearon/pen/gWWZgR?editors=0010" target="_blank" rel="noopener">最后的成果</a>，如果你不能理解代码，还不熟悉它如何做出来的，别担心，这个教程的目标就是教会你这些东西，不然你可以走了。</p><p>我们建议你继续教程之前先熟悉一下这个游戏，你可以注意到在游戏面板的右面有一个数字列表，他将记录你游戏的每一步，并且可以实时更新。</p><p>熟悉了之后就Ok了，下面我们一下来开发这个游戏！</p><h4 id="前提条件-Prerequisites"><a href="#前提条件-Prerequisites" class="headerlink" title="前提条件(Prerequisites)"></a>前提条件(Prerequisites)</h4><p>我们假设你已经熟练掌握了HTMl和JavaScript了，虽然有其他语言基础也可以，但那些基础还是要掌握的，我们也假设你熟悉了一些例如<code>functions`</code>objects<code></code>arrays<code>这些Js里面的概念，并且有一些对</code>classes`有一定的理解。</p><p>如果你需要去重新学习JavaScript，我们推荐阅读<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">这个教程</a>，注意：我们也使用一些ES6的语法，例如尖头函数、<code>classes</code>、<code>let</code>、<code>const</code>，你可以使用<a href="https://babeljs.io/repl/#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2016%2Creact&amp;prettier=false&amp;targets=&amp;version=6.26.0&amp;envVersion=" target="_blank" rel="noopener">Babel REPL</a>核实ES6代码规范。</p><h3 id="教程构建-Setup-for-the-Tutorial"><a href="#教程构建-Setup-for-the-Tutorial" class="headerlink" title="教程构建(Setup for the Tutorial)"></a>教程构建(Setup for the Tutorial)</h3><p>有两个方法学习这个教程：</p><ul><li>你可以在浏览器中再现编写代码</li><li>也可以搭建本地的开发环境</li></ul><h4 id="方法一：浏览器在线编写"><a href="#方法一：浏览器在线编写" class="headerlink" title="方法一：浏览器在线编写"></a>方法一：浏览器在线编写</h4><p>这是很快的入门方法</p><p>首先打开<a href="https://codepen.io/gaearon/pen/oWWQNa?editors=0010" target="_blank" rel="noopener">Starter Code</a>,这里还没有把游戏显示出来，我们可以在这里在线编辑学习。</p><p>确定是痛这种方法的话，我们可以跳过下面第二种方法去看<code>概述</code>部分了</p><h4 id="方法二：-搭建本地开发环境"><a href="#方法二：-搭建本地开发环境" class="headerlink" title="方法二： 搭建本地开发环境"></a>方法二： 搭建本地开发环境</h4><p>虽然我们这个教程中并不需要这种方法，但他也很重要！<br>（This is completely optional and not required for this tutorial!，原文显得很不重要一样）</p><p>这个方法需要更大的工作量，但是可以在本地选择自己的编辑器来学习本套课程，下面是步骤：</p><ol><li>确定你已经安装了Node.Js</li><li><p>跟着下面安装指导来创建新的工程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app my-app</span><br></pre></td></tr></table></figure></li><li><p>删除新项目中<code>src/</code>目录下所有的文件（文件夹保留）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-app</span><br><span class="line">rm -f src/*</span><br></pre></td></tr></table></figure></li><li><p>在<code>src/</code>文件夹中新建一个名为<code>index.css</code>的文件，用于编写css代码</p></li><li><p>在<code>src/</code>文件夹中新建一个名为<code>index.js</code>的文件，用于编写js代码</p></li><li><p>在<code>index.js</code>中添加下面三行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &apos;./index.css&apos;;</span><br></pre></td></tr></table></figure></li></ol><p>现在你可以运行<code>npm start</code>，浏览器打开<code>http://localhost:3000</code>，你可以看见一个空的页面,这样，本地的开发环境就搭建好了。</p><h4 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h4><p>如果你在构建环境的过程中有什么问题，可以直接找我～～～</p><blockquote><p><strong>原文</strong><br><em>If you get stuck, check out the <a href="https://reactjs.org/community/support.html" target="_blank" rel="noopener">community support</a> resources. In particular, <a href="https://discord.gg/0ZcbPKXt5bZjGY5n" target="_blank" rel="noopener">Reactiflux Chat</a> is a great way to get help quickly. If you don’t receive an answer, or if you remain stuck, please file an issue, and we’ll help you out.</em></p></blockquote><h3 id="概述-Overview"><a href="#概述-Overview" class="headerlink" title="概述(Overview)"></a>概述(Overview)</h3><h4 id="React是什么？-What-Is-React"><a href="#React是什么？-What-Is-React" class="headerlink" title="React是什么？(What Is React?)"></a>React是什么？(What Is React?)</h4><p>React是开源、高效、灵活的Js框架，它能够让你李用一个个脱离的片段（被叫做组件<code>components</code>）来构建出一个复杂的UI。</p><p>React有一部分不同种类的组件，但是它们都继承自<code>React.Component</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"shopping-list"</span>&gt;</span><br><span class="line">        &lt;h1&gt;Shopping List <span class="keyword">for</span> &#123;<span class="keyword">this</span>.props.name&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;Instagram&lt;/</span>li&gt;</span><br><span class="line">          &lt;li&gt;WhatsApp&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          &lt;li&gt;Oculus&lt;/</span>li&gt;</span><br><span class="line">        &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage: &lt;ShoppingList name="Mark" /&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到类似XML标签的代码，我们使用组件去告诉React我们将在屏幕中显示什么，当我们数据改变React也将高效的更新这个组件。</p><p>这里，<code>ShoppingList</code>是一个组件（ React component class, or React component type）,组件里包含一些参数，叫做<code>props</code>(propertie的缩写),并且通过<code>render</code>方法返回一个试图层（hierarchy of views）.</p><p><code>render</code>方法返回一个你想在网页中看到的“描述”，React拿到这个“描述”并且展示出来，大部分React开发者使用一种特殊的语法“JSX”来写<code>render</code>的内容，极其方便。在JSX语法中<br><code>&lt;div /&gt;</code>句式被转换成<code>React.createElement(&#39;div&#39;)</code>，这样我们可以在JS代码中方便的写入类似HTML标签的语法了。<br><code>React.createElement(&#39;div&#39;)</code>写<code>render</code>内容Example:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> React.createElement(<span class="string">'div'</span>, &#123;<span class="attr">className</span>: <span class="string">'shopping-list'</span>&#125;,</span><br><span class="line">  React.createElement(<span class="string">'h1'</span>, <span class="comment">/* ... h1 children ... */</span>),</span><br><span class="line">  React.createElement(<span class="string">'ul'</span>, <span class="comment">/* ... ul children ... */</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p><a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=DwEwlgbgBAxgNgQwM5IHIILYFMC8AiJACwHsAHUsAOwHMBaOMJAFzwD4AoKKYQgRlYDKJclWpQAMoyZQAZsQBOUAN6l5ZJADpKmLAF9gAej4cuwAK5wTXbg1YBJSswTV5mQ7c7XgtgOqEETEgAguTuYFamtgDyMBZmSGFWhhYchuAQrADc7EA" target="_blank" rel="noopener">完整的例子</a>（可见，很繁琐）</p><p>如果你想了解更多<code>createElement()</code>的内容，请查阅<a href="https://reactjs.org/docs/react-api.html#createelement" target="_blank" rel="noopener">API文档</a>，在实际开发中我们不常使用到它，而是用更为方便的JSX语法。</p><p>JSX自带Javascript的全部功能，你可以把任何JS表达式放在JSX的代码块中，每个React组件是一个Js对象，你可以在其中使用一些变量和函数。</p><p>上面的<code>ShoppingList</code>组件仅仅在DOM树中渲染了<code>&lt;div /&gt;</code>和<code>&lt;li /&gt;</code>，你也可以渲染出自定义的React组件。比如说，你可以通过写<code>&lt;ShoppingList /&gt;</code>来显示<code>ShoppingList</code>的全部内容，每个React组件被独立的分离，这样，你就可以通过简单的组件构建出一个复杂的UI界面。</p><h4 id="浏览-the-Starter-Code（Inspecting-the-Starter-Code）"><a href="#浏览-the-Starter-Code（Inspecting-the-Starter-Code）" class="headerlink" title="浏览 the Starter Code（Inspecting the Starter Code）"></a>浏览 the Starter Code（Inspecting the Starter Code）</h4><p>如果你是在线学习编写代码，打开这个代码页面：<a href="https://codepen.io/gaearon/pen/oWWQNa?editors=0010" target="_blank" rel="noopener">Starter Code</a>,如果你是在本地编写代码，打开<code>src/index.js</code></p><p>这个代码是你以后进行后续编写的基础，我们已经提供了CSS样式，你可以专注于学习React来开发这个游戏。</p><p>通过阅读这段代码，你会发现其中有三个组件：</p><ul><li>Square</li><li>Board</li><li>Game</li></ul><p>Square组件仅渲染了单个的<code>&lt;button&gt;</code>，Board组件渲染了9个Square组件，Game组件渲染了一个board组件和一个以后将要修改了占位代码，现在还没有能够交互的组件。</p><h4 id="通过props传递数据-Passing-Data-Through-Props"><a href="#通过props传递数据-Passing-Data-Through-Props" class="headerlink" title="通过props传递数据(Passing Data Through Props)"></a>通过props传递数据(Passing Data Through Props)</h4><p>趁热打铁！让我们试着将数据从Board组件传递到Square组件。</p><p>在Board组件的<code>renderSquare</code>方法中，修改代码让一个叫做<code>value</code>的变量传递到Square组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  renderSquare(i) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> <span class="attr">value</span>=<span class="string">&#123;i&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br></pre></td></tr></table></figure><p>将Square<code>render</code>方法中的<code>{/* TODO */}</code>修改为<code>{this.props.value}</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=<span class="string">"square"</span>&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>修改之前界面是：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/tictac-empty-1566a4f8490d6b4b1ed36cd2c11fe4b6-a9336.png" alt="界面视图" title="">                </div>                <div class="image-caption">界面视图</div>            </figure><p>修改之后，你将可以在每个Square组件中看见一个数字：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/tictac-numbers-685df774da6da48f451356f33f4be8b2-be875.png" alt="界面视图" title="">                </div>                <div class="image-caption">界面视图</div>            </figure><p><a href="https://codepen.io/gaearon/pen/aWWQOG?editors=0010" target="_blank" rel="noopener">看此部分完整代码</a></p><p>祝贺你！你已经成功将数据从Board组件(父zujian)传递到Square组件(子组件)，props传递是React中从父到子的数据流动的方式。</p><h4 id="制作一个交互组件-Making-an-Interactive-Component"><a href="#制作一个交互组件-Making-an-Interactive-Component" class="headerlink" title="制作一个交互组件(Making an Interactive Component)"></a>制作一个交互组件(Making an Interactive Component)</h4><p>功能：当我们点击时，能将Square组件中的值变为“X”。<br>首先，改变组件中的<code>render()</code>方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=<span class="string">"square"</span> onClick=&#123;<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">'click'</span>); &#125;&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>现在点击一个Square组件，你将看到一个alert框。</p><blockquote><blockquote><p><strong>Note</strong><br>为了保存类型并且避免<a href="https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">对this不能理解</a>，我们将使用尖头函数的句式（<code>arrow function syntax</code>）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;button className=<span class="string">"square"</span> onClick=&#123;() =&gt; alert(<span class="string">'click'</span>)&#125;&gt;</span><br><span class="line">       &#123;<span class="keyword">this</span>.props.value&#125;</span><br><span class="line">     &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">   );</span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p></blockquote></blockquote><blockquote><p>请看这边<code>onClick={() =&gt; alert(&#39;click&#39;)}</code>，我们传递一个<em>函数</em>作为<code>onClick</code>的参数，这个函数将在我们点击的时候执行，大家通常会忘了写<code>() =&gt;</code>而写成<code>onClick={alert(&#39;click&#39;)}</code>，如果这样的话，大家可以看看会发生什么。</p></blockquote><p>下一步，我们想要让Square“记住”我们点击的行为，并且在其中放入一个“X”字符。要让组件“记住”，<br>我们要用到<strong>state</strong></p><p>React组件可以通过在构造函数中设置<code>this.state</code>来定义state，<code>this.state</code>被认为是React组件中被私有的。让我们在<code>this.state</code>中储存当前Square的value，点击的时候能瘦改变。</p><p>首先，写一个构造函数去初始化state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=<span class="string">"square"</span> onClick=&#123;() =&gt; alert(<span class="string">'click'</span>)&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Note</strong><br>在<code>JavaScript classes</code>中，当定义一个子类的时候，你需要去调用<code>super</code>方法。所有的React组件的类都应该有一个<code>constructor</code>并在其中调用<code>super(props)</code></p></blockquote><p>现在我们将改变Square的<code>render</code>方法去实现当我们点击时展示当前的state的值：</p><ul><li>在<code>&lt;button&gt;</code>标签中用<code>this.state.value</code>替换<code>this.props.value</code></li><li>用<code>() =&gt; this.setState({value: &#39;X&#39;})</code>替换<code>() =&gt; alert()</code></li><li>将<code>className</code>和<code>onClick</code>各占一行以便更好的阅读</li></ul><p>改变以后<code>&lt;button&gt;</code>标签应该是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button</span><br><span class="line">        className=<span class="string">"square"</span></span><br><span class="line">        onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="string">'X'</span>&#125;)&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.value&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>通过调用Square中的<code>onClick</code>方法执行<code>this.setState</code>方法，我们高速React去重新渲染这个组件。更新之后Square的<code>this.state.value</code>将变成<code>X</code>，这样，如果我们点击任何一个Square，将会在其中展示一个<code>&#39;X&#39;</code>。</p><p>当我们在组件中调用<code>setState</code>方法，React也将自动更新其中的子组件。</p><p><a href="[看此部分完整代码](https://codepen.io/gaearon/pen/aWWQOG?editors=0010">看此部分完整代码</a></p><h4 id="开发工具-Developer-Tools"><a href="#开发工具-Developer-Tools" class="headerlink" title="开发工具(Developer Tools)"></a>开发工具(Developer Tools)</h4><p>这里介绍的是React在<code>Chrome</code>和<code>Firefox</code>的插件，先不翻译</p><h3 id="完成小游戏项目"><a href="#完成小游戏项目" class="headerlink" title="完成小游戏项目"></a>完成小游戏项目</h3><p>有了这个游戏的基础框架，要完成这个游戏，我们需要去瓤“X”和“O”能够在游戏面板中交替下棋，并且需要一个方法去决定谁是赢家。</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>目前，每个Square组件都有一个游戏的State，为了一决定谁是赢家，我们将在同一个地方构建每一个Square的value。</p><p>我们可以认为Board仅仅是询问了每一个Square的state，尽管在React中这种方法可以实现，我们也不将使用，因为它这样代码将相对难以理解，更容易产生bug并且难遇维护。储存游戏状态更好的方法是在父组件Board中储存，而不是在每一个Square中储存，Board组件通过传递props能够告诉每一个Square该去显示什么,<a href="#通过props传递数据-Passing-Data-Through-Props">就像我们之前用props传递数据一样</a>。</p><p>去采集来自数个子组件的数据，或者让两个子组件相互通信交流，你需要去共享父组件的state，父组件可以用props向下传递state；这能让子组件随着父组件相互同步。</p><p>当React组件被复用时，将state拿到父组件中在React中是一个常见的方法，让我们把握这个机会试一下！<br>我们在Board增加一个构造方法，并且初始化state，包含含有9个null的数组，这9个null分别对应9个方块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      squares: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  renderSquare(i) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> <span class="attr">value</span>=<span class="string">&#123;i&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    const status = 'Next player: X';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className="status"&gt;&#123;status&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div className="board-row"&gt;</span><br><span class="line">          &#123;this.renderSquare(0)&#125;</span><br><span class="line">          &#123;this.renderSquare(1)&#125;</span><br><span class="line">          &#123;this.renderSquare(2)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className="board-row"&gt;</span><br><span class="line">          &#123;this.renderSquare(3)&#125;</span><br><span class="line">          &#123;this.renderSquare(4)&#125;</span><br><span class="line">          &#123;this.renderSquare(5)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className="board-row"&gt;</span><br><span class="line">          &#123;this.renderSquare(6)&#125;</span><br><span class="line">          &#123;this.renderSquare(7)&#125;</span><br><span class="line">          &#123;this.renderSquare(8)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>当我们以后填满棋盘，我们将看到类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &apos;O&apos;, null, &apos;X&apos;,</span><br><span class="line">  &apos;X&apos;, &apos;X&apos;, &apos;O&apos;,</span><br><span class="line">  &apos;O&apos;, null, null,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Board组件中的<code>renderSquare</code>方法现在是这样的；<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renderSquare(i) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> <span class="attr">value</span>=<span class="string">&#123;i&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br></pre></td></tr></table></figure></p><p>之前我们传递0-8九个数字给每一个方块，不同于之前的步骤，我们用Square中state中的值“X”代替数字，这是我们数字不能显示的原因。</p><p>我们现在将再次使用props传递机制。我们现在修改Board去指导每个独立的方块。我们已经定义了<code>squares</code>数组，然后我们将修改Board的renderSquare的方法去拿到它：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renderSquare(i) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> <span class="attr">value</span>=<span class="string">&#123;this.state.squares[i]&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br></pre></td></tr></table></figure></p><p><a href="[看此部分完整代码](https://codepen.io/gaearon/pen/gWWQPY?editors=0010">看此部分完整代码</a></p><p>每个方块现在将接收到一个<code>value</code>prop，它将是<code>&#39;X&#39;</code>,<code>&#39;O&#39;</code>,<code>null</code>其中一个值。</p><p> 下一步，我们需要去对方块点击后发生的事件做改变，Board组件现在决定那写方块被填满，我们需要去用一个方法让Square组件能够更新Board的state，既然state对每个组件来说是私有的。我们不能直接在square组件中修改Board组件的state。</p><p> 为了维持state的私有性，我们需要从Board向下传递一个方法，这个方法将被调用。下面我们改变Board组件中的<code>renderSquare</code>方法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">renderSquare(i) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Square</span><br><span class="line">      value=&#123;this.state.squares[i]&#125;</span><br><span class="line">      onClick=&#123;() =&gt; this.handleClick(i)&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Note</strong><br>  为了更好的可读性，我们把元素分行，并且我们加了一个圆括号解决能让<code>return</code>之后架上分号，并且结束代码。</p></blockquote><p>  下载我们从Board传了两个props给Square:<code>value</code>和<code>onClick</code>. 这个<code>onClick</code>是一个Square组件被点击时可以调用的一个方法，我们对Square做如下的工作：</p><ul><li>在Square的<code>render</code>方法中，用<code>this.props.value</code>替换<code>this.state.value</code></li><li>在Square的<code>render</code>方法中，用<code>this.props.onClick()</code>替换<code>this.setState()</code></li><li><p>删除Square的<code>constructor</code>，因为它不再用来跟踪游戏的状态了</p><p>改变之后的Square组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  class Square extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button</span><br><span class="line">        className=&quot;square&quot;</span><br><span class="line">        onClick=&#123;() =&gt; this.props.onClick()&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;this.props.value&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当一个方块被点击，Board传过来的<code>onClick</code>方法将被调用，下面来看看为什么：</p><ol><li>在<code>&lt;button&gt;</code>组件中的<code>onClick</code>属性通知React创建了一个点击事件的监听事件</li><li>当按钮被点击，React将调用在Square组件的<code>render()</code>方法中的<code>onClick</code>事件处理器 </li><li>这个事件处理器再调用<code>this.props.onClick()</code>，这个Square的<code>onClick</code>属性具体的内容在Board组件中</li><li>既然Board组件传递<code>onClick={() =&gt; this.handleClick(i)}</code>给Square，那个这个Square当被点击时调用的是<code>this.handleClick(i)</code></li><li>我们还没定义<code>handleClick()</code>方法，那么我们就开始干咯。</li></ol><blockquote><p><strong>Note</strong><br>DOM下的<code>&lt;button&gt;</code>元素的<code>onClick</code>内置的组件. 对于像Square一样的自定义标签，命名是取决于你的, 我们完全可以将Square的<code>onClick</code>属性或者Board的<code>handleClick</code>方法命名成别的名字. 然而在React中为一些代表事件的属性使用<code>on[Event]</code>这样的命名格式是一种约定而成的习惯, <code>handle[Event]</code>作为处理方法的名称也是这个道理。</p></blockquote><p>当我们试着去点击一个方块，应该会报一个error，因为我们还没定义<code>handleClick</code>方法，我们现在开始在Board class中写<code>handleClick</code>方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      squares: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(i) &#123;</span><br><span class="line">    <span class="keyword">const</span> squares = <span class="keyword">this</span>.state.squares.slice();</span><br><span class="line">    squares[i] = <span class="string">'X'</span>;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">squares</span>: squares&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  renderSquare(i) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Square</span><br><span class="line">        value=&#123;<span class="keyword">this</span>.state.squares[i]&#125;</span><br><span class="line">        onClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick(i)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> status = <span class="string">'Next player: X'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className=<span class="string">"status"</span>&gt;&#123;status&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="board-row"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(0)&#125;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(1)&#125;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(2)&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;div className=<span class="string">"board-row"</span>&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.renderSquare(<span class="number">3</span>)&#125;</span><br><span class="line">          &#123;<span class="keyword">this</span>.renderSquare(<span class="number">4</span>)&#125;</span><br><span class="line">          &#123;<span class="keyword">this</span>.renderSquare(<span class="number">5</span>)&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="board-row"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(6)&#125;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(7)&#125;</span></span><br><span class="line"><span class="regexp">          &#123;this.renderSquare(8)&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="[看此部分完整代码](https://codepen.io/gaearon/pen/ybbQJX?editors=0010">看此部分完整代码</a></p><p>这样之后，我们又能够点击且填满方块了，但是现在它们的状态<code>state</code>被储存在Board组件而不是每个独立的Square组件中。当我们Boare的state改变，Square组件将自动重新渲染，让所有方块的状态的状态<code>state</code>都放在Board组件中将让我们之后的开发中可以决定谁是赢家。</p><p>既然方块组件（Square components）不再有state，它仅仅做的是接收来自棋盘组件（Board component）的values值并且当被点击时通知棋盘组件。在React中，方块组件现在叫做被控制组件，棋盘完全控制着它们。</p><p>注意在<code>handleClick</code>中，我们调用了<code>.slice()</code>来创建一个<code>squares</code>数组的copy，然后修改它而不是直接修改之前就存在的，下面我们将解释我们为什么要这么做。</p><h4 id="为什么不变性如此重要（Why-Immutability-Is-Important）"><a href="#为什么不变性如此重要（Why-Immutability-Is-Important）" class="headerlink" title="为什么不变性如此重要（Why Immutability Is Important）"></a>为什么不变性如此重要（Why Immutability Is Important）</h4><p> 在之前的代码中，我们推荐使用<code>.slice()</code>去创建<code>squares</code>数组的copy，然后修改它而不是直接修改之前就存在的。我们现在讨论为何不改变之前的数组，为何踏实重要的。</p><p> 我们知道，改变数据有两个方法一个是直接改变数据的值，还有就是修改一个数据拷贝的副本。</p><p> <em>直接改变数据</em></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> player = &#123;<span class="attr">score</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Jeff'</span>&#125;;</span><br><span class="line">player.score = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// Now player is &#123;score: 2, name: 'Jeff'&#125;</span></span><br></pre></td></tr></table></figure><p><em>间接得到改变的数据</em><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> player = &#123;<span class="attr">score</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'Jeff'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newPlayer = <span class="built_in">Object</span>.assign(&#123;&#125;, player, &#123;<span class="attr">score</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="comment">// Now player is unchanged, but newPlayer is &#123;score: 2, name: 'Jeff'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Or if you are using object spread syntax proposal, you can write:</span></span><br><span class="line"><span class="comment">// var newPlayer = &#123;...player, score: 2&#125;;</span></span><br></pre></td></tr></table></figure></p><p><em>复杂的功能变简单</em></p><p>不可变性是复杂的功能实现起来变得更简单，在之后的教程中，我们将实现一个<code>time travel</code>的功能，可以允许我们玩游戏的过程中回顾之前的步骤，还有悔棋，这是这个游戏的普通需求，避免去直接改变数据让我们能够完好无损回到游戏游戏的历史界面。</p><p><em>观察变动</em></p><p>数据直接改变后想去观察是困难的，这种观察房需要可变的对象与之前他本身的的各种copy版本进行比较</p><p>观察改变在不变的对象的情况下是更容易的，如果当前的不变对象与之前的是不同的，那么说明已经改变。</p><p><em>决定何时重新加载</em></p><p>不可变的主要益处设市能够帮助我们构建一个<em>pure components</em>(纯净的组件？？)，不便数据可以是我们易于发现改变何时发生并且帮助我们决定何时重新加载。</p><p>你可以学习更多关于<code>shouldComponentUpdate()</code>并且通过阅读<a href="https://reactjs.org/docs/optimizing-performance.html#examples" target="_blank" rel="noopener">Optimizing Performance</a>学习如何构建<em>pure components</em></p><h4 id="功能组件（Functional-Components）"><a href="#功能组件（Functional-Components）" class="headerlink" title="功能组件（Functional Components）"></a>功能组件（Functional Components）</h4><p>我们现在让Square变成一个<strong>functional component</strong>.</p><p>在react中，<strong>功能组件（functional component）</strong>是一个写组件的简单方式，其中仅包含一个<code>render</code>方法，并且没有自己的state，代替定义一个继承自<code>React.Component</code>的类，我们可以写一个function，<code>props</code>作为参数，并且返回我们想要渲染的内容，比起组件类功能组件是单调的，许多简单的组件可以写成这样的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button className=<span class="string">"square"</span> onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">      &#123;props.value&#125;</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们将其中的两处<code>this.props</code>替换成<code>this.props</code></p><p><a href="[看此部分完整代码](https://codepen.io/gaearon/pen/QvvJOv?editors=0010">看此部分完整代码</a></p><blockquote><p><strong>Note</strong><br>当我们将Square修改成功能组件时，我们也将<code>onClick={() =&gt; this.props.onClick()}</code>变为<code>更简短的onClick={props.onClick}</code>（不要缺少两边的括号），在类中我们需要用箭头函数去使用正确的<code>this</code>的值，但是在功能组件中我们无需担心<code>this</code>。</p></blockquote><h4 id="轮流下棋"><a href="#轮流下棋" class="headerlink" title="轮流下棋"></a>轮流下棋</h4><p>我们现在需要去改善游戏中一个明显的bug：“O”不能在标记在棋盘中</p><p>我们将默认第一步下“X”，我们可以在Board组件中修改这个默认值:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      squares: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>),</span><br><span class="line">      xIsNext: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>每次一个玩家移动完，<code>xIsNext</code>(boolean)将被迅速取反曲决定下一步的玩家，并且游戏的state将被保存，我们修改Board的<code>handleClick</code>方法，加入<code>xIsNext</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleClick(i) &#123;</span><br><span class="line">    <span class="keyword">const</span> squares = <span class="keyword">this</span>.state.squares.slice();</span><br><span class="line">    squares[i] = <span class="keyword">this</span>.state.xIsNext ? <span class="string">'X'</span> : <span class="string">'O'</span>;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      squares: squares,</span><br><span class="line">      xIsNext: !<span class="keyword">this</span>.state.xIsNext,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>通过这个改变，“X”和“O”可轮流切换，让我们也改变在棋盘状态文本<code>status</code>去展示下一步的玩家：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    const status = &apos;Next player: &apos; + (this.state.xIsNext ? &apos;X&apos; : &apos;O&apos;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      // the rest has not changed</span><br></pre></td></tr></table></figure><p>做了这个改变之后，你的棋盘组件应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Board extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      squares: Array(9).fill(null),</span><br><span class="line">      xIsNext: true,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(i) &#123;</span><br><span class="line">    const squares = this.state.squares.slice();</span><br><span class="line">    squares[i] = this.state.xIsNext ? &apos;X&apos; : &apos;O&apos;;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      squares: squares,</span><br><span class="line">      xIsNext: !this.state.xIsNext,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  renderSquare(i) &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Square</span><br><span class="line">        value=&#123;this.state.squares[i]&#125;</span><br><span class="line">        onClick=&#123;() =&gt; this.handleClick(i)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const status = &apos;Next player: &apos; + (this.state.xIsNext ? &apos;X&apos; : &apos;O&apos;);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className=&quot;status&quot;&gt;&#123;status&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div className=&quot;board-row&quot;&gt;</span><br><span class="line">          &#123;this.renderSquare(0)&#125;</span><br><span class="line">          &#123;this.renderSquare(1)&#125;</span><br><span class="line">          &#123;this.renderSquare(2)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=&quot;board-row&quot;&gt;</span><br><span class="line">          &#123;this.renderSquare(3)&#125;</span><br><span class="line">          &#123;this.renderSquare(4)&#125;</span><br><span class="line">          &#123;this.renderSquare(5)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div className=&quot;board-row&quot;&gt;</span><br><span class="line">          &#123;this.renderSquare(6)&#125;</span><br><span class="line">          &#123;this.renderSquare(7)&#125;</span><br><span class="line">          &#123;this.renderSquare(8)&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="宣布赢家"><a href="#宣布赢家" class="headerlink" title="宣布赢家"></a>宣布赢家</h4><p>既然我们已经展示了下一步玩家是哪一位，我们也应当展示游戏何时分出胜负并且结束游戏，我们可以通过增加下面这个帮助函数放在文件尾部实现这个功:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function calculateWinner(squares) &#123;</span><br><span class="line">  const lines = [</span><br><span class="line">    [0, 1, 2],</span><br><span class="line">    [3, 4, 5],</span><br><span class="line">    [6, 7, 8],</span><br><span class="line">    [0, 3, 6],</span><br><span class="line">    [1, 4, 7],</span><br><span class="line">    [2, 5, 8],</span><br><span class="line">    [0, 4, 8],</span><br><span class="line">    [2, 4, 6],</span><br><span class="line">  ];</span><br><span class="line">  for (let i = 0; i &lt; lines.length; i++) &#123;</span><br><span class="line">    const [a, b, c] = lines[i];</span><br><span class="line">    if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123;</span><br><span class="line">      return squares[a];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将在Board的<code>render</code>中调用这个<code>calculateWinner(squares)</code>函数去何时游戏时候分出胜负，如果有玩家胜出了我们将展示出来，例如“Winner: X”，我们将在Board的<code>render</code>方法中替换<code>status</code>通过下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    const winner = calculateWinner(this.state.squares);</span><br><span class="line">    let status;</span><br><span class="line">    if (winner) &#123;</span><br><span class="line">      status = &apos;Winner: &apos; + winner;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      status = &apos;Next player: &apos; + (this.state.xIsNext ? &apos;X&apos; : &apos;O&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      // the rest has not changed</span><br></pre></td></tr></table></figure><p>我们现在可以修改Board的<code>handleClick</code>函数，如果有玩家赢了游戏，去提前return去不响应点击事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleClick(i) &#123;</span><br><span class="line">    const squares = this.state.squares.slice();</span><br><span class="line">    if (calculateWinner(squares) || squares[i]) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    squares[i] = this.state.xIsNext ? &apos;X&apos; : &apos;O&apos;;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      squares: squares,</span><br><span class="line">      xIsNext: !this.state.xIsNext,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>[看此部分完整代码]<a href="https://codepen.io/gaearon/pen/LyyXgK?editors=0010" target="_blank" rel="noopener">看此部分完整代码</a></p><p>祝贺你！你现在已经差不多完成了这个游戏了，并且你也已经学习到了react的基础知识，到这里，你可能已经是一个真正的赢家了！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然发现React是有中文网的，但是奈何一直打不开中文文档，即使我已经开了VPN，自己现在又习惯性的想看更专业的官方文档，国内的一些教程实在看不下去了，所以想着自己尝试翻译他的文档，帮助一些和我一样有强迫症患者的朋友。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;官网就是官网，教程真的是牛逼，
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="自学" scheme="https://meandni.com/tags/%E8%87%AA%E5%AD%A6/"/>
    
      <category term="react" scheme="https://meandni.com/tags/react/"/>
    
      <category term="翻译" scheme="https://meandni.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>跨平台方案：将ReactNative集成到现有原生应用(Android)</title>
    <link href="https://meandni.com/2018/08/15/integration-with-existing-apps/"/>
    <id>https://meandni.com/2018/08/15/integration-with-existing-apps/</id>
    <published>2018-08-15T11:59:00.000Z</published>
    <updated>2019-01-03T14:35:04.988Z</updated>
    
    <content type="html"><![CDATA[<p>如果你正准备从头开始制作一个新的应用，那么 React Native 会是个非常好的选择。但如果你只想给现有的原生应用中添加一两个视图或是业务流程，React Native 也同样不在话下。只需简单几步，你就可以给原有应用加上新的基于 React Native 的特性、画面和视图等。</p><p>具体的步骤根据你所开发的目标平台不同而不同。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>把 React Native 组件集成到 Android 应用中有如下几个主要步骤：</p><ol><li>配置好 React Native 依赖和项目结构。</li><li>创建 js 文件，编写 React Native 组件的 js 代码。</li><li>在应用中添加一个<code>RCTRootView</code>。这个<code>RCTRootView</code>正是用来承载你的 React Native 组件的容器。</li><li>启动 React Native 的 Packager 服务，运行应用。</li><li>验证这部分组件是否正常工作。</li></ol><h2 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h2><p>首先按照<a href="getting-started.md">开发环境搭建教程</a>来安装 React Native 在 Android 平台上所需的一切依赖软件。</p><h3 id="1-配置项目目录结构"><a href="#1-配置项目目录结构" class="headerlink" title="1. 配置项目目录结构"></a>1. 配置项目目录结构</h3><p>首先创建一个空目录用于存放 React Native 项目，然后在其中创建一个<code>/android</code>子目录，把你现有的 Android 项目拷贝到<code>/android</code>子目录中。</p><h3 id="2-安装-JavaScript-依赖包"><a href="#2-安装-JavaScript-依赖包" class="headerlink" title="2. 安装 JavaScript 依赖包"></a>2. 安装 JavaScript 依赖包</h3><p>在项目根目录下创建一个名为<code>package.json</code>的空文本文件，然后填入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;MyReactNativeApp&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>示例中的<code>version</code>字段没有太大意义（除非你要把你的项目发布到 npm 仓库）。<code>scripts</code>中是用于启动 packager 服务的命令。</p></blockquote><p>接下来我们使用 yarn 或 npm（两者都是 node 的包管理器）来安装 React 和 React Native 模块。请打开一个终端/命令提示行，进入到项目目录中（即包含有 package.json 文件的目录），然后运行下列命令来安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add react-native</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save react-native</span><br></pre></td></tr></table></figure></p><p>这样默认会安装最新版本的 React Native，同时会打印出类似下面的警告信息（你可能需要滚动屏幕才能注意到）：</p><blockquote><p>warning “<a href="mailto:react-native@0.52.2" target="_blank" rel="noopener">react-native@0.52.2</a>“ has unmet peer dependency “<a href="mailto:react@16.2.0" target="_blank" rel="noopener">react@16.2.0</a>“.</p></blockquote><p>这是正常现象，意味着我们还需要安装指定版本的 React：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add react@16.2.0</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save react</span><br></pre></td></tr></table></figure></p><p>注意必须严格匹配警告信息中所列出的版本，高了或者低了都不可以。</p><blockquote><p>如果你使用多个第三方依赖，可能这些第三方各自要求的 react 版本有所冲突，此时应优先满足<code>react-native</code>所需要的<code>react</code>版本。其他第三方能用则用，不能用则只能考虑选择其他库。</p></blockquote><p>所有 JavaScript 依赖模块都会被安装到项目根目录下的<code>node_modules/</code>目录中（这个目录我们原则上不复制、不移动、不修改、不上传，随用随装）。</p><p>把<code>node_modules/</code>目录记录到<code>.gitignore</code>文件中（即不上传到版本控制系统，只保留在本地）。</p><h2 id="把-React-Native-添加到你的应用中"><a href="#把-React-Native-添加到你的应用中" class="headerlink" title="把 React Native 添加到你的应用中"></a>把 React Native 添加到你的应用中</h2><h3 id="配置-maven"><a href="#配置-maven" class="headerlink" title="配置 maven"></a>配置 maven</h3><p>在你的 app 中 <code>build.gradle</code> 文件中添加 React Native 依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;com.android.support:appcompat-v7:23.0.1&apos;</span><br><span class="line">    ...</span><br><span class="line">    compile &quot;com.facebook.react:react-native:+&quot; // From node_modules</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果想要指定特定的 React Native 版本，可以用具体的版本号替换 <code>+</code>，当然前提是你从 npm 里下载的是这个版本。</p></blockquote><p>在项目的 <code>build.gradle</code> 文件中为 React Native 添加一个 maven 依赖的入口，必须写在 “allprojects” 代码块中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            // All of React Native (JS, Android binaries) is installed from npm</span><br><span class="line">            url &quot;$rootDir/../node_modules/react-native/android&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>确保依赖路径的正确！以免在 Android Studio 运行 Gradle 同步构建时抛出 “Failed to resolve: com.facebook.react:react-native:0.x.x” 异常。</p></blockquote><h3 id="配置权限"><a href="#配置权限" class="headerlink" title="配置权限"></a>配置权限</h3><p>接着，在 <code>AndroidManifest.xml</code> 清单文件中声明网络权限:</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code></pre><p>如果需要访问 <code>DevSettingsActivity</code> 界面（即开发者菜单），则还需要在 <code>AndroidManifest.xml</code> 中声明:</p><pre><code>&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;</code></pre><p>开发者菜单一般仅用于在开发时从 Packager 服务器刷新 JavaScript 代码，所以在正式发布时你可以去掉这一权限。</p><h3 id="代码集成"><a href="#代码集成" class="headerlink" title="代码集成"></a>代码集成</h3><p>Now we will actually modify the native Android application to integrate React Native.</p><h4 id="React-Native-组件"><a href="#React-Native-组件" class="headerlink" title="React Native 组件"></a>React Native 组件</h4><p>我们首先要写的是”High Score”（得分排行榜）的 JavaScript 端的代码。</p><h5 id="1-创建一个index-js文件"><a href="#1-创建一个index-js文件" class="headerlink" title="1. 创建一个index.js文件"></a>1. 创建一个<code>index.js</code>文件</h5><p>首先在项目根目录中创建一个空的<code>index.js</code>文件。(注意在 0.49 版本之前是 index.android.js 文件)</p><p><code>index.js</code>是 React Native 应用在 Android 上的入口文件。而且它是不可或缺的！它可以是个很简单的文件，简单到可以只包含一行<code>require/import</code>导入语句。本教程中为了简单示范，把全部的代码都写到了<code>index.js</code>里（当然实际开发中我们并不推荐这样做）。</p><h5 id="2-添加你自己的-React-Native-代码"><a href="#2-添加你自己的-React-Native-代码" class="headerlink" title="2. 添加你自己的 React Native 代码"></a>2. 添加你自己的 React Native 代码</h5><p>在<code>index.js</code>中添加你自己的组件。这里我们只是简单的添加一个<code>&lt;Text&gt;</code>组件，然后用一个带有样式的<code>&lt;View&gt;</code>组件把它包起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppRegistry, StyleSheet, Text, View &#125; <span class="keyword">from</span> <span class="string">"react-native"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.hello&#125;&gt;Hello, World&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> styles = StyleSheet.create(&#123;</span><br><span class="line">  container: &#123;</span><br><span class="line">    flex: <span class="number">1</span>,</span><br><span class="line">    justifyContent: <span class="string">"center"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  hello: &#123;</span><br><span class="line">    fontSize: <span class="number">20</span>,</span><br><span class="line">    textAlign: <span class="string">"center"</span>,</span><br><span class="line">    margin: <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(<span class="string">"MyReactNativeApp"</span>, () =&gt; HelloWorld);</span><br></pre></td></tr></table></figure><h5 id="3-配置权限以便开发中的红屏错误能正确显示"><a href="#3-配置权限以便开发中的红屏错误能正确显示" class="headerlink" title="3. 配置权限以便开发中的红屏错误能正确显示"></a>3. 配置权限以便开发中的红屏错误能正确显示</h5><p>如果你的应用会运行在 Android 6.0（API level 23）或更高版本，请确保你在开发版本中有打开<code>悬浮窗(overlay)</code>权限。你可以在代码中使用<code>Settings.canDrawOverlays(this);</code>来检查。之所以需要这一权限，是因为我们会把开发中的报错显示在悬浮窗中（仅在开发阶段需要）。在 Android 6.0（API level 23）中用户需要手动同意授权。具体请求授权的做法是在<code>onCreate()</code>中添加如下代码。其中<code>OVERLAY_PERMISSION_REQ_CODE</code>是用于回传授权结果的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERLAY_PERMISSION_REQ_CODE = <span class="number">1</span>;  <span class="comment">// 任写一个值</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Settings.canDrawOverlays(<span class="keyword">this</span>)) &#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,</span><br><span class="line">                                   Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">        startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Finally, the <code>onActivityResult()</code> method (as shown in the code below) has to be overridden to handle the permission Accepted or Denied cases for consistent UX.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode == OVERLAY_PERMISSION_REQ_CODE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Settings.canDrawOverlays(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="comment">// SYSTEM_ALERT_WINDOW permission not granted</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="掌握核心科技：ReactRootView"><a href="#掌握核心科技：ReactRootView" class="headerlink" title="掌握核心科技：ReactRootView"></a>掌握核心科技：<code>ReactRootView</code></h4><p>我们还需要添加一些原生代码来启动 React Native 的运行时环境并让它开始渲染。首先需要在一个<code>Activity</code>中创建一个<code>ReactRootView</code>对象，然后在这个对象之中启动 React Native 应用，并将它设为界面的主视图。</p><blockquote><p>如果你想在安卓 5.0 以下的系统上运行，请用 <code>com.android.support:appcompat</code> 包中的 <code>AppCompatActivity</code> 代替 <code>Activity</code> 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">DefaultHardwareBackBtnHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReactRootView mReactRootView;</span><br><span class="line">    <span class="keyword">private</span> ReactInstanceManager mReactInstanceManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mReactRootView = <span class="keyword">new</span> ReactRootView(<span class="keyword">this</span>);</span><br><span class="line">        mReactInstanceManager = ReactInstanceManager.builder()</span><br><span class="line">                .setApplication(getApplication())</span><br><span class="line">                .setBundleAssetName(<span class="string">"index.android.bundle"</span>)</span><br><span class="line">                .setJSMainModulePath(<span class="string">"index"</span>)</span><br><span class="line">                .addPackage(<span class="keyword">new</span> MainReactPackage())</span><br><span class="line">                .setUseDeveloperSupport(BuildConfig.DEBUG)</span><br><span class="line">                .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 注意这里的MyReactNativeApp必须对应“index.js”中的</span></span><br><span class="line">        <span class="comment">// “AppRegistry.registerComponent()”的第一个参数</span></span><br><span class="line">        mReactRootView.startReactApplication(mReactInstanceManager, <span class="string">"MyReactNativeApp"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        setContentView(mReactRootView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeDefaultOnBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>If you are using a starter kit for React Native, replace the “HelloWorld” string with the one in your index.js file (it’s the first argument to the <code>AppRegistry.registerComponent()</code> method).</p></blockquote><p>如果你使用的是 Android Studio , 可以使用<code>Alt + Enter</code>快捷键来自动为 MyReactActivity 类补上缺失的 import 语句。注意<code>BuildConfig</code>应该是在你自己的包中自动生成，无需额外引入。千万不要从<code>com.facebook...</code>的包中引入！</p><p>我们需要把 <code>MyReactActivity</code> 的主题设定为 <code>Theme.AppCompat.Light.NoActionBar</code> ，因为里面有许多组件都使用了这一主题。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">".MyReactActivity"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:theme</span>=<span class="string">"@style/Theme.AppCompat.Light.NoActionBar"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>一个<code>ReactInstanceManager</code>可以在多个 activities 或 fragments 间共享。 You will want to make your own <code>ReactFragment</code> or <code>ReactActivity</code> and have a singleton <em>holder</em> that holds a <code>ReactInstanceManager</code>. When you need the <code>ReactInstanceManager</code> (e.g., to hook up the <code>ReactInstanceManager</code> to the lifecycle of those Activities or Fragments) use the one provided by the singleton.</p></blockquote><p>下一步我们需要把一些 activity 的生命周期回调传递给<code>ReactInstanceManager</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mReactInstanceManager.onHostPause(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mReactInstanceManager.onHostResume(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mReactInstanceManager.onHostDestroy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mReactRootView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mReactRootView.unmountReactApplication();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要把后退按钮事件传递给 React Native：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mReactInstanceManager.onBackPressed();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This allows JavaScript to control what happens when the user presses the hardware back button (e.g. to implement navigation). When JavaScript doesn’t handle the back button press, your <code>invokeDefaultOnBackPressed</code> method will be called. By default this simply finishes your <code>Activity</code>.</p><p>Finally, we need to hook up the dev menu. By default, this is activated by (rage) shaking the device, but this is not very useful in emulators. So we make it show when you press the hardware menu button (use <code>Ctrl + M</code> if you’re using Android Studio emulator):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mReactInstanceManager.showDevOptionsDialog();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onKeyUp(keyCode, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 activity 已就绪，可以运行一些 JavaScript 代码了。</p><h3 id="测试集成结果"><a href="#测试集成结果" class="headerlink" title="测试集成结果"></a>测试集成结果</h3><p>You have now done all the basic steps to integrate React Native with your current application. Now we will start the React Native packager to build the <code>index.bundle</code> package and the server running on localhost to serve it.</p><h5 id="1-运行-Packager"><a href="#1-运行-Packager" class="headerlink" title="1. 运行 Packager"></a>1. 运行 Packager</h5><p>运行应用首先需要启动开发服务器（Packager）。你只需在项目根目录中执行以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn start</span><br></pre></td></tr></table></figure><h5 id="2-运行你的应用"><a href="#2-运行你的应用" class="headerlink" title="2. 运行你的应用"></a>2. 运行你的应用</h5><p>保持 packager 的窗口运行不要关闭，然后像往常一样编译运行你的 Android 应用(在命令行中执行<code>./gradlew installDebug</code>或是在 Android Studio 中编译运行)。</p><p>编译执行一切顺利进行之后，在进入到 MyReactActivity 时应该就能立刻从 packager 中读取 JavaScript 代码并执行和显示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/EmbeddedAppAndroid.png" alt="Screenshot" title="">                </div>                <div class="image-caption">Screenshot</div>            </figure><h2 id="在-Android-Studio-中打包"><a href="#在-Android-Studio-中打包" class="headerlink" title="在 Android Studio 中打包"></a>在 Android Studio 中打包</h2><p>你也可以使用 Android Studio 来打 release 包！其步骤基本和原生应用一样，只是在每次编译打包之前需要先执行 js 文件的打包(即生成离线的 jsbundle 文件)。具体的 js 打包命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ react-native bundle --platform android --dev false --entry-file index.js --bundle-output android/com/your-company-name/app-package-name/src/main/assets/index.android.bundle --assets-dest android/com/your-company-name/app-package-name/src/main/res/</span><br></pre></td></tr></table></figure><blockquote><p>注意把上述命令中的路径替换为你实际项目的路径。如果 assets 目录不存在，则需要提前自己创建一个。</p></blockquote><p>然后在 Android Studio 中正常生成 release 版本即可！</p><h2 id="我遇到的问题"><a href="#我遇到的问题" class="headerlink" title="我遇到的问题"></a>我遇到的问题</h2><p>就是一进入ReactNative的Activity就闪退到前面的页面，后查看log发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: couldn&apos;t find DSO to load: libreactnativejni</span><br></pre></td></tr></table></figure></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在两处添加配置：<br>app#build.gradle</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line"> //...</span><br><span class="line"> ndk &#123;</span><br><span class="line">     abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你正准备从头开始制作一个新的应用，那么 React Native 会是个非常好的选择。但如果你只想给现有的原生应用中添加一两个视图或是业务流程，React Native 也同样不在话下。只需简单几步，你就可以给原有应用加上新的基于 React Native 的特性、画面
      
    
    </summary>
    
      <category term="非原创" scheme="https://meandni.com/categories/%E9%9D%9E%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="android" scheme="https://meandni.com/tags/android/"/>
    
      <category term="混合开发" scheme="https://meandni.com/tags/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    
      <category term="reactnative" scheme="https://meandni.com/tags/reactnative/"/>
    
  </entry>
  
  <entry>
    <title>读《第一行代码》</title>
    <link href="https://meandni.com/2018/08/14/0/"/>
    <id>https://meandni.com/2018/08/14/0/</id>
    <published>2018-08-14T14:21:37.000Z</published>
    <updated>2019-01-03T13:34:01.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读书感受"><a href="#读书感受" class="headerlink" title="读书感受"></a>读书感受</h2><p>本着查漏补缺的态度，刚来学校随手拿到一本书看了起来，就这么一下子看完了，有一个感觉，技术之类的书还要是有点基础看的，不仅效率高而且获益确实不少。</p><p>也没有都看，前面已经接触太多的东西就没去看了，大概以后还会当工具书来翻一翻，主要是从我之前没接触的广播看起，看着看着发现之前不会的东西居然掌握了，着实让我倍感自信，有了继续看的动力，加上手头正在做一个自己感觉还算比较满意的项目，一下子感觉自己离大神的距离又近了一点（😆）。我是真的极其讨厌“大神”这个词，第一个原因是看过太多所谓的大神其实只是貌似或者说是被别人吹出来的，再说这个领域本来就没有多少真正大神，我暂时是这么想的，可能因为我的眼界还太窄，你不可能什么都会，就算你会的很多你也应该谦虚一点，所以我要谦虚一点😀。</p><p>用我前阵子非常喜欢说的话，就是学习编程跟学习英语其实没什么两样，你学了你就会了，你看过一样东西并且去练习了你自然也就会了，没什么天赋之类的（这也是我暂时的想法），只有你有没有兴趣！</p><p>我都不知道我要不要做这种程序员工作，兴趣我是有的，不然也不会投入到连吃饭上厕所的时间都忘记了，但有时真的是觉得我不想做这种办公室农民,极其违背我的本意～～我的本意其实可能是能有不劳而获，把梦里想的直接变现的东西。</p><hr><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="广播（Broadcast）"><a href="#广播（Broadcast）" class="headerlink" title="广播（Broadcast）"></a>广播（Broadcast）</h3><h4 id="接收广播（BroadReceiver）"><a href="#接收广播（BroadReceiver）" class="headerlink" title="接收广播（BroadReceiver）"></a>接收广播（BroadReceiver）</h4><p>看前面两小节，通俗的理解也不过是监听了某某事件（比如网络是否连接），之后发生一个动作。</p><p>网络变化这个广播通过<code>IntentFilter</code>的<code>addAction</code>方法拿到，然后通过<code>regosterReceiver</code>方法将该广播和我们自定义的广播接收器绑定起来。</p><p>这里的广播界接收器<code>regosterReceiver</code>就是我们写的一个类，广播发出来之后，我们的类实例化出来的对象的<code>onReceive</code>方法会被自动调用，这里我们想干嘛就干嘛了。</p><h4 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h4><p>方法类似于打开另一个<code>Activity</code>，用的是<code>intent</code>实例化的时候将自定义的广播传入参数，然后调用<code>sendBroadcast</code>方法。</p><p>其他的就是光波可以跨应用程序传播（当然，有时为了安全可以使用本地广播），有序广播可以设置优先权选择那个接收者先执行</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>这本书比较好的就是每一个章节的最佳实践，知识点全面而且有点难度、实践性比较大。</p><p>这一章是实现App登陆后发送广播强制退出登陆的功能，这里不多说了～</p><h3 id="手机多媒体"><a href="#手机多媒体" class="headerlink" title="手机多媒体"></a>手机多媒体</h3><h4 id="通知（Notification）"><a href="#通知（Notification）" class="headerlink" title="通知（Notification）"></a>通知（Notification）</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;读书感受&quot;&gt;&lt;a href=&quot;#读书感受&quot; class=&quot;headerlink&quot; title=&quot;读书感受&quot;&gt;&lt;/a&gt;读书感受&lt;/h2&gt;&lt;p&gt;本着查漏补缺的态度，刚来学校随手拿到一本书看了起来，就这么一下子看完了，有一个感觉，技术之类的书还要是有点基础看的，不仅效率
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="Android" scheme="https://meandni.com/tags/Android/"/>
    
      <category term="读书" scheme="https://meandni.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
</feed>
