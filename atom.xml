<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joker&#39;s Blog</title>
  
  <subtitle>个人分享博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://meandni.com/"/>
  <updated>2019-04-28T12:41:19.349Z</updated>
  <id>https://meandni.com/</id>
  
  <author>
    <name>Joker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第一次春招之旅！</title>
    <link href="https://meandni.com/2019/04/28/3aab/"/>
    <id>https://meandni.com/2019/04/28/3aab/</id>
    <published>2019-04-28T02:53:29.000Z</published>
    <updated>2019-04-28T12:41:19.349Z</updated>
    
    <content type="html"><![CDATA[<p>我相信这次也是第一次这么“轰轰烈烈”的求职之旅会给我一段很长的一段时间内都不会忘记的记忆。期间，经历过绝望和挣扎，但能怎么办，在社会，在家庭，你都是责任的载体，最终还是选择咬咬牙继续走下去。</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>双非渣本，专业：软件工程，投递岗位：客户端（Android）开发实习，有一段外包公司的实习经历，简历中大概有 4 个项目。</p><h2 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h2><p>春招中经历面试的公司：</p><ul><li>阿里（一面挂）</li><li>腾讯（三面+一面，两个部门）</li><li>头条（一面挂）</li><li>七牛云（offer）</li><li>蘑菇街（offer）</li></ul><p>笔试挂的公司：</p><ul><li>拼多多（2019-03-10）</li><li>百度（2019-04-02）</li><li>招行（2019-04-09）</li></ul><p>简历挂的公司：</p><ul><li>虎牙</li><li>虾皮</li><li>OPPO</li></ul><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>第一次面试，来自阿里。很感谢阿里给的这次面试，当时投递简历的第二天就接受到面试的邀请，期间大概 40 分钟。面试官的问题都引申自我简历的项目和技能（后来知道这叫简历面），全程我就很慌张，一直在抖（第一次面试标准姿势）！原以为面试就是问一些基础和编程题目，当碰到一些熟悉由陌生的项目问题时，我是懵的，然后极度紧张，耳边，面试官标准的普通话给我一种杯强大气场压制住的感觉。</p><p>这次面试对我影响之大，导致一直懊恼自己为什么没把简历好好准备，其中的项目为何不把他整理好，自我介绍怎么还说不流利，而后的几天就一直在准备这些，希望吃了这次教训以后能有改善，我准备了一段大概 3 分钟的较好的自我介绍，写下来并且背诵朗读，我把面试官问到并且没问到简历中提及的知识点缕了一遍也写成文让以后不会有话说不出来，最后就是又复习了常见面试算法和基础知识！</p><p>第二次面腾讯，这是时隔十天的电话，15 号看到有一个深圳的未接来电打回去知道是腾讯总部，因为阿里的面试对我打击蛮大的，所以之后就一直处于低沉状态，电话也没接到，到 20 号腾讯才又打来，是腾讯视频，又是简历面～～这次我当然不能怯场，面试的结果是满意的，我之前整理的东西大多派上了用场，有了一次的面试经历后我说话也变得流利起来，结果是收到了第二天就收到了二面视频面的邀请，二面的面试官很准时的到了人也很 nice，问的题目都比较常规，最后也撕了一道很简单的算法题，体验极好，当天一度认为我离腾讯不远了，我复习的还是我之前的内容～～再明天也就是 22 号，迎来的是三面，当时早上十点，我还在睡觉，接到电话很激动，说请面试官能不能给我二十分钟的整理时间，二十分钟后面试官打来电话上来问我你对学校教的操作系统还熟悉吗？我说我还没复习，这一句话影响了整个面试流程，面试官默认我就不会了，聊了不到 20 分钟就结束了通话，挂断不到半小时官网流程就灰了。当时的感觉就是从天上掉到了地下，我甚至没脸告诉我同学我挂了！</p><p>面完当天的下午和晚上，我一边叹气一边在复习操作系统，那一天把几乎一学期的操作系统都复习完了，我很后悔之前没重视这一块！到现在都后悔！</p><p>第三次面试来自头条，我不想说太多这一次的面试经历，我只想说这是我锁经历过体验最差的面试过程，面试官形象邋遢，对面还时不时有一堆噪音，问题极偏，我承认我不是什么大神，但那些问题是不是在故意刁难你还是感觉得到的啊！面完就挂了，可能也有我的原因吧，之后也有把他问到比较偏的问题也整理了一遍，希望以后也有用！</p><p>27 号下午，当时在图书馆，接到了 3 个电话，一个是七牛云的面试邀约，头条打过来问我面试体验（因为那次面试很多同学投诉，之后有一个问卷调查，我给了较差的评价），还有就是腾讯音乐打来的电话，当时天已傍晚，正收拾东西准备回去时腾讯的电话就来了，约了十分钟后面试，我急忙告知同学让他先帮我把书带回去，我随便找了个空教室等待面试官的来电，至此，我已大概知道了面试的套路，发挥的也比较好，聊了一个多小时，当晚收到了第二天下午两点面试的邀约，我也很激动希望能赶在提前批完完成流程，已经 28 号了提前批还来得及吗？结果是第二天我在实验室等了一个下午面试官也没来！我想应该还会有机会吧。隔天给我一面的面试官发了个短信：</p><blockquote><p>面试官，您好，我是前天面试 Android 实习的同学，我收到了昨天的面试通知但并没有收到面试官的来电，但是官网流程显示了复试，我想问一下是否过了四月一号简历会被释放不能面试了呢？</p></blockquote><p>隔天面试官回信：</p><blockquote><p>同学你好！你的能力很不错，比同期的许多人都要优秀，我们是认可的。但是不好意思，由于时间关系，这次提前批的招聘名额已经满了，所以很遗憾这次没有办法继续面试。不过请你不要放弃，目前还只是提前批，特别希望你能继续关注腾讯后续的实习生招聘和校招。</p></blockquote><p>很失望，4 月 1 号当天流程变灰，收到正式批的笔试通知， 但能怎么办呢，继续努力加油呗！</p><p>之后就是七牛的一面了，2019 年 4 月 2 号，面试官明显不是做 Android 的，问了一点基础知识都答的还好，而后又问我会 go 吗？我说不会，C++ 会多少，我说只写过算法，又问我有写过自己的博客吗？我说有，您可以看我的附件简历里面有我的 Github 地址和博客链接。二十一分钟，面试完就结束了，以为凉了，谁知道晚上再做百度笔试的时候收到了第二天二面的通知！</p><p>七牛的二面体验也很好，面试官很可爱的一个人，问的问题难度不小，勉强说得出来（主要是和面试官在讨论问题），后来又聊了聊项目和学校的经历，最后就开始聊天了（期间网很卡，我这边只管点头，没听清他说什么），二面很愉快的结束了，以我的经验来看我觉得是没问题的，过了一个清明假，之前加了我微信的 hr 就找我聊天，她说还不知道二面的情况，但隔天就又告诉我二面过了！</p><p>最近的一次是蘑菇街的一面了，2019 年 4 月 9 号，清明后的第一个面试，已经经历了这么多场面试的摧残，我显然已经对面试无所畏惧了，面试官人很也棒，中途给了我很多建议，主要问题来源是基础+简历，我答完问题后也告诉我哪里不足会给我一些较好的答案。昨天得知一面顺利过了，在等待二面的过程当中！</p><p>然后直到 4 月 16 号收到了七牛的正式 offer 邮箱，也算是一定程度上得到了肯定，感觉自己不放弃是对的！这句话应该同样适用于多有的人所有的事！邮箱中要求明天就要签 offer，我想着面完蘑菇街二面再看吧！</p><p>同一天，过了一整周，4 月 16 日，星期二，蘑菇街的 hr 才打来预约我的二面，第二天早上十点，为什么是早上，因为下午都难免都会有困意，还有一个原因就是之前面完头条后翻帖子我发现早上面试官的心情都比较好，问的问题都一般，我暂且是这么认为了！hr 通知之后面试官就立即加了我的微信，互相打了招呼，等到了第二天的面试，准时的开始了。不愧是传说中的疯狂怼项目，怼场景题，期间应该是没有任何基础的问题，从介绍项目到找出其中一个难点，在找给一个场景，发现问题，解决问题，也聊了一些学校经历和比赛，大概 45 分钟，中途被不熟悉的自定义 View 砍了很久的时间，一度很慌，也算是只有这个内容表现的不太好吧！面完心情很平静，毕竟已经身经百战，很迫不及待的找 hr 问了情况，当天没得到回应，为了保底，果断签了七牛的 offer 发给那边的 hr，隔天 hr 回应恭喜我通过了技术二面，同天，接到了 hr 面试的邀请！</p><hr><p>—————————-4.18 更新————————–</p><p>下午 17:39，此时，我正在准备这次春招的面筋，想着就次别过这次的春招吧，蘑菇街出差错的话就去七牛吧！然而，手机来了一个熟悉又陌生的号码！广东深圳？腾讯竟然又打来了，这不是又让我不能安眠吗？哇～这样，我说我现在不合适，约了晚上 19 点！</p><p>开始面试，面试官有那么一丝不知不这么标准的普通话让我感觉和善，然而问的问题并不和善，上来让我讲讲并发，单这四个字就开始讲了起来，我从各个关键字讲到内存模型，问我 java 内存模型这样设计的意义在哪里？问的深入很深入，反正全程我都是在边说边被锤，虽然很难，但不得不说确实是有点爽感的，让我有种焕然一新的感觉，可能心里已经没那么看中了吧（毕竟有 offer 了），现在还在等结果，还是希望能通过的！</p><p>—————————-4.18 结束————————–</p><p>—————————-4.27 更新————————–</p><p>25号 8:20，人在KTV和同学在唱歌，朋友提醒，有个电话，腾讯又打过来，伴随着歌声约了二十分钟后面试，我赶忙回到学校做好准备，大概 9:00 来了电话，一个小姐姐面试官，感觉极其和善，面试体验蛮好的，全程还时不时安慰我别紧张，然而问题真的很水，问题几个问题就说差不多了，也不懂我的岗位没自我介绍也没提问，全程 20 分钟，我断定这是在刷业绩。</p><p>然后今天看到官网毁了，至此我对腾讯已不报希望！</p><p>—————————-4.27 结束————————–</p><p>—————————-4.28 更新————————–</p><p>五一假期在家，吃完饭后发现错过两个电话，没错是蘑菇街的 offer call！</p><p>—————————-4.28 结束————————–</p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>上面有提到一些我在面试流程中的总结和教训，这些虽然会让你难过，但你可能也是因为他们变得更强的，经历了阿里一面，我书面写下了很长一段的项目介绍和总结，经历了腾讯的三面，我一天时间里复习了一学期的操作系统课程，而后面试真的显得如鱼得水（虽然代价大了一点）。但我相信只要你懂得吸取教训而不是被教训打倒，你下次就会成功！</p><h2 id="如何复习和教训"><a href="#如何复习和教训" class="headerlink" title="如何复习和教训"></a>如何复习和教训</h2><p>寒假期间我就开始无意识的复习了起来，期间看了《深入理解 java 虚拟机》、《算法4 第四版》、《java 并发编程的艺术》，Android 相关的看了《Android 开发艺术探索》还有等等的博文。</p><p>输出了：</p><p>6 篇《深入理解 java 虚拟机》的笔记：</p><ul><li><a href="https://meandni.com/2019/01/10/jvm_note1/">《深入理解java虚拟机》笔记1——Java内存区域与Java对象</a></li><li><a href="https://meandni.com/2019/01/11/jvm_note2/">《深入理解java虚拟机》笔记2——GC算法与内存分配策略</a></li><li><a href="https://meandni.com/2019/01/11/jvm_note3/">《深入理解Java虚拟机》笔记3——7种垃圾收集器</a></li><li><a href="https://meandni.com/2019/01/14/jvm_note4/">《深入理解Java虚拟机》笔记4——类文件结构</a></li><li><a href="https://meandni.com/2019/01/15/jvm_note5/">《深入理解Java虚拟机》笔记5——类加载机制与字节码执行引擎</a></li><li><a href="https://meandni.com/2019/01/18/jvm_note6/">《深入理解Java虚拟机》笔记6——高效并发</a></li></ul><p>《算法4 第四版》精华笔记：</p><p><a href="https://github.com/MeandNi/Algorithms4-Common" target="_blank" rel="noopener">https://github.com/MeandNi/Algorithms4-Common</a></p><p>两次阅读文章的记录：</p><ul><li><a href="https://meandni.com/2019/01/18/reading-record1/">2019第一次阅读记录</a></li><li><a href="https://meandni.com/2019/03/12/reading-record2/">2019第二次阅读记录</a></li></ul><p>几点教训：</p><ul><li>面试能力是有技巧的，是可以从面试中锻炼的，从表达能力到技术硬实力千万不要感到怯懦，要相信你是可以的，我从阿里和腾讯的面试中学到了很多，也很遗憾这次没能拿到它们的 offer，善于总结，你会变的更强！</li><li>笔试通常分为选择题和编程题（但也会是只有编程题），选择题大部分是学校的专业课基础（包括计网，数据结构，操作系统），所以夯实基础怼笔试面试都很重套，很多同学虽然编程题弱了一些但同样能拿到面试机会！</li><li>如果你有自己的博客，并且有一些质量较高的文章，一定要写在简历上面，有些面试官真的很看重这一块！七牛一面我只面了 20 min，我相信面试官最后是看到了我的博客觉得我还不错吧！</li></ul><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>春招准备知识框架：</p><ul><li>java<ul><li>基础（反射、泛型、异常、IO…<a href="https://github.com/MeandNi/Android_Learning" target="_blank" rel="noopener">Java 基础</a>）</li><li>集合（ArrayList、HashMap 等源码…<a href="https://github.com/MeandNi/Android_Learning" target="_blank" rel="noopener">Java 容器</a>）</li><li>虚拟机（深入理解 JVM…<a href="https://meandni.com/tags/jvm/">系列笔记</a>）</li><li>并发（并发编程艺术）</li></ul></li><li>计网<ul><li>TCP、UDP（握手挥手，滑动窗口，拥塞控制）</li><li>HTTP、HTTPS（区别、证书、请求过程，请求方法，缓存、响应码）</li></ul></li><li>操作系统<ul><li>进程与线程（定义、区别）</li><li>内存管理（虚拟内存、物理地址的映射，各种调度算法）</li></ul></li><li>数据结构<ul><li>线性表、栈和队、树、图</li><li>散列查找、排序</li><li>海量数据处理</li></ul></li><li>设计模式：<ul><li>创建型模式（6种）</li><li>结构型模式（7种）</li><li>行为型模式（11种）</li></ul></li><li>Android<ul><li>四大组件（Activity、Service…）</li><li>多线程（Handler、AsycTask、HandlerThread、线程池…）</li><li>View（分发事件、自定义 View、滑动冲突）</li><li>性能优化（内存泄漏、图片缓存、冷启动优化）</li><li>IPC（AIDL、Bind机制、其他方式）</li></ul></li></ul><p>推荐笔记：</p><ul><li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">Snailclimb/JavaGuide</a></li><li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CyC2018/CS-Notes</a></li><li><a href="https://github.com/yangchong211/YCBlogs" target="_blank" rel="noopener">yangchong211/YCBlogs</a></li><li><a href="https://github.com/linsir6/AndroidNote" target="_blank" rel="noopener">linsir6/AndroidNote</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我相信这次也是第一次这么“轰轰烈烈”的求职之旅会给我一段很长的一段时间内都不会忘记的记忆。期间，经历过绝望和挣扎，但能怎么办，在社会，在家庭，你都是责任的载体，最终还是选择咬咬牙继续走下去。&lt;/p&gt;
&lt;h2 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="生活" scheme="https://meandni.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="春招" scheme="https://meandni.com/tags/%E6%98%A5%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>一纸协议，全靠情谊！以及我对 996 的看法</title>
    <link href="https://meandni.com/2019/04/25/think-about/"/>
    <id>https://meandni.com/2019/04/25/think-about/</id>
    <published>2019-04-25T15:31:44.000Z</published>
    <updated>2019-04-28T12:16:13.034Z</updated>
    
    <content type="html"><![CDATA[<p>对与之前在博客分享的一些关于 Flutter 的文章获得了一些关注，有一家图书策划公司找了我说能不能合作写书，当时抱着尝试的心态写了目录跟样章，过了那边的审批后就开始要签合同了，然而，我就在考虑是否该签，一是是否有时间，最近都在忙春招，之后又要忙工作；二是这家机构是否专业，它们是否能保障我应有的权益；三是我自己能力是否足够，之后写不出来该怎么办；最后是我明明可以联系到人民邮电出版社，我是否要跟它们签约？我签了。我的理由是这是我第一次写书，可以先把它当作一次自我锻炼，入门书籍我相信我也是可以写出来的，我之前就知道写书是不挣钱的所以稿费方面我暂且也就不做考虑了，最后还是在于情谊吧，是人家鼓励的你写书并且花了很长时间帮我校对编辑，我在那边的编辑的劝说下还是选择跟他们合作了，因为拒绝后我也会感觉一阵的不适，这样做会让我觉得我太不负责任，这就是我所谓的<strong>“一纸协议，全靠情谊！”</strong>。</p><hr><p>同天，我接到的来自腾讯的第六次面试，我真不知道这是不是他们只是在刷 kpi，而且今天晚上问的问题都很水，她也没准备，根部不知道问什么，虽然面试体验极好，第一次遇到女面试官，全程还是不是安慰我别紧张，这就很暖心了！希望能有机会碰到腾讯的 HR，让我也期待一下腾讯的 offer call！</p><hr><p><strong>关于996的个人看法</strong></p><p>好多天前的夜里写的了，感觉写的蛮不错的！😊</p><blockquote><!--April 15, 2019 at 04:19--><p>最近好多大佬对闹的沸沸扬扬的 996 事件做了回应，马云老师是第一个也是最受关注的一个。<br>我个人一点都不反对他说的话，他说年轻人该为自己喜欢的事业而奋斗，我从字里行间都看到了我每天利用可自由支配时间去探究一些事物的情景，这些时间不止 996。我从小到大做事都骨骼一般，但好在对自己喜欢的事物和目前所学的专业有足够的专注力，兴趣使然，就像中学做网站那样，你去网吧都是为了写页面，当时包括现在都没有人逼我去做这些事情，也没有利益的引诱，全凭兴趣…..我深刻的能体会到这种感觉就是 —— 我工作就是在放松！<br>然而，我不确定以后我还能这么想….现在我也渐渐体会到高强度的工作带来的负面影响了，不提身体上的影响，你会发现这样也会远离真正的生活。<br>这本来就是一个悖论吧，马老师之前的采访也有说自己后悔当初沉迷工作，没有花更多的时间去生活，去陪孩子。<br>然而如今的文明社会给我们的定位是我们应该是在年轻时奋斗的，但这并不是指加班！现在我得出的结论很没有用….那就是全看个人选择，你是选择自己喜欢的事业并贡献大部分的时间还是去工作来改善生活质量，二选一的选择题…..不知道有没有第三个最优解？</p></blockquote><img src="/2019/04/25/think-about/996.PNG" title="thing-about-996">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对与之前在博客分享的一些关于 Flutter 的文章获得了一些关注，有一家图书策划公司找了我说能不能合作写书，当时抱着尝试的心态写了目录跟样章，过了那边的审批后就开始要签合同了，然而，我就在考虑是否该签，一是是否有时间，最近都在忙春招，之后又要忙工作；二是这家机构是否专业，
      
    
    </summary>
    
    
      <category term="生活" scheme="https://meandni.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="写书" scheme="https://meandni.com/tags/%E5%86%99%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>记一次在学校生气的经历</title>
    <link href="https://meandni.com/2019/04/12/angry-event/"/>
    <id>https://meandni.com/2019/04/12/angry-event/</id>
    <published>2019-04-12T06:03:42.000Z</published>
    <updated>2019-04-28T12:17:08.603Z</updated>
    
    <content type="html"><![CDATA[<p>事情最开始是我想要请公选课的假来做实习笔试，结果是学校不允许实习代替学校的实训？</p><p>再然后就是七牛 hr 问我最早的到岗时间，我想这一定关系到给不给 offer 吧？所以我找老师希望能有机会先实习再实训，希望能尽早先到公司然后给学校安排就安排吧～然而接收到的又是拒绝？暑期一开始就要实训，实训还要记入学分！引发了我一阵不满，现在看来，学校水的跟泡沫似的实训是一定要去咯？</p><p>我说：</p><blockquote><p>嗯嗯！好的好的！谢谢您。</p></blockquote><blockquote><p>嗯，好的，但秋招没经历不太好找大厂好像…..但也没事….</p></blockquote><p>翘课？</p><p>有个老师认识我～～还跟我有过节！</p><p>又想到一件事？关于考研分配考研教室的？虽然我现在决定不考研了，但之前还不太明确的时候也有去申请…最后是包括我很多人都没申请到，可能这是自己的原因吧？绩点不高？大一大二排名差了是该申请不到的。。。但我想反映一句，我考不考研还需要你分配？学校有那些条件的话能不能多准备一下学生学习空间的基础设施？我打听到可能这不是我们一个学校有这个规定。。。但我不得不问这样真的好吗？从小学。。。中学。。一直会有一种来自四面八方的眼神将学生分成三六九等。。。</p><blockquote><p>你成绩不好你坐后面，我不能关照你？但你要自己加油啊！</p></blockquote><p>我最小的时候就极其厌恶这种行为！我来学校是来受不公平待遇的吗？你要么别要我，要么别歧视！！</p><blockquote><p>哎？谁叫你志愿填这所大学？</p></blockquote><p>我可以明确地说，我到现在也一点也不后悔我选择这所大学！现在他身为我的母校我有义务希望他变得更好，我希望以后有勇气站在更大舞台上承认他我的母校？我以他为豪！虽然我不是做得最出色的那个人，他也没有改变我很多，但我在大学确实成长了很多也学到了许多！</p><p>以上是我对我母校的部分不满和建议！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事情最开始是我想要请公选课的假来做实习笔试，结果是学校不允许实习代替学校的实训？&lt;/p&gt;
&lt;p&gt;再然后就是七牛 hr 问我最早的到岗时间，我想这一定关系到给不给 offer 吧？所以我找老师希望能有机会先实习再实训，希望能尽早先到公司然后给学校安排就安排吧～然而接收到的又是
      
    
    </summary>
    
    
      <category term="生活" scheme="https://meandni.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="生气" scheme="https://meandni.com/tags/%E7%94%9F%E6%B0%94/"/>
    
  </entry>
  
  <entry>
    <title>2019第二次阅读记录</title>
    <link href="https://meandni.com/2019/03/12/reading-record2/"/>
    <id>https://meandni.com/2019/03/12/reading-record2/</id>
    <published>2019-03-12T06:53:59.000Z</published>
    <updated>2019-04-21T12:14:06.344Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/fb59c770160c" target="_blank" rel="noopener">强缓存和协商缓存</a></p><p><a href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7" target="_blank" rel="noopener">缓存详解</a></p><p><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" target="_blank" rel="noopener">轻松理解JS函数节流和函数防抖</a></p><p><a href="https://juejin.im/post/5c80e846518825355a71d154" target="_blank" rel="noopener">Flutter 的渲染逻辑及和 Native 通信</a></p><p><a href="https://mp.weixin.qq.com/s/CQQXD0TrlbaNWjoClIcDtw" target="_blank" rel="noopener">Flutter 原理简解</a></p><p><a href="http://www.cnblogs.com/shanyou/p/4085802.html" target="_blank" rel="noopener">TCP/IP, WebSocket 和 MQTT</a></p><p><a href="https://blog.csdn.net/jamesliulyc/article/details/6711828" target="_blank" rel="noopener">android开发时，finish()跟System.exit(0)的区别(转)</a></p><hr><p><a href="https://juejin.im/post/5b1cebece51d4506ae71addf" target="_blank" rel="noopener">Ajax原理一篇就够了</a></p><p><a href="https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">【原创】说说JSON和JSONP，也许你会豁然开朗，含jQuery用例</a></p><p><a href="https://zhenhua-lee.github.io/react/history.html" target="_blank" rel="noopener">react-router的实现原理</a></p><p><a href="http://blog.poetries.top/2018/12/20/react-router-anaylse/" target="_blank" rel="noopener">React Router原理</a>🌟</p><p><a href="https://juejin.im/post/5b50b0dd6fb9a04f932ff53f" target="_blank" rel="noopener">面试官所认为的单例模式</a></p><hr><p><a href="https://www.toutiao.com/i6545790064104833539/" target="_blank" rel="noopener">为什么HashMap非线程安全</a></p><p><a href="https://juejin.im/post/5c6fbf54f265da2db718216a" target="_blank" rel="noopener">TCP和UDP比较</a></p><p> <a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" target="_blank" rel="noopener">稳定排序和不稳定排序</a></p><p><a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" target="_blank" rel="noopener">稳定排序和不稳定排序</a></p><p><a href="https://juejin.im/entry/58371f13a22b9d006882902d" target="_blank" rel="noopener">面试旧敌之红黑树（直白介绍深入理解）</a></p><p><a href="https://blog.csdn.net/sinat_35297665/article/details/80979181" target="_blank" rel="noopener">TCP第四次挥手为什么要等待2MSL</a></p><p><a href="https://juejin.im/post/5ad43b86f265da239236cedc" target="_blank" rel="noopener">Web安全防范—–防止重放攻击</a></p><p><a href="https://blog.csdn.net/u012758088/article/details/76020966" target="_blank" rel="noopener">网络编程—链路层报文、网络层IP报文、传输层TCP报文</a></p><hr><p><a href="https://juejin.im/post/5c98a834f265da6111675253" target="_blank" rel="noopener">Flutter 实现原理及在马蜂窝的跨平台开发实践</a></p><hr><p><a href="https://www.jianshu.com/p/b0b6b88fe9fe" target="_blank" rel="noopener">1- Https流程和原理</a></p><p><a href="https://www.cnblogs.com/liyuhui-Z/p/7844880.html" target="_blank" rel="noopener">HTTPS 建立连接的详细过程</a></p><p><a href="https://www.cnblogs.com/chentingk/p/6497107.html" target="_blank" rel="noopener">生产者消费者模式-Java实现</a></p><p><a href="https://www.cnblogs.com/gavinsp/p/5513536.html" target="_blank" rel="noopener">数据库索引详解</a></p><p><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></p><p><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></p><p><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></p><hr><p><a href="http://web.jobbole.com/85541/" target="_blank" rel="noopener">谈谈HTTP协议中的短轮询、长轮询、长连接和短连接</a></p><p><a href="https://www.cnblogs.com/lizhengxian/p/5075635.html" target="_blank" rel="noopener">Android进程间通信的几种方式</a></p><p><a href="https://blog.csdn.net/wh_sjc/article/details/70283843" target="_blank" rel="noopener">进程间的五种通信方式介绍</a></p><p><a href="https://www.cnblogs.com/withyou/p/4789170.html" target="_blank" rel="noopener">面向对象之多态理解，多态的作用与好处</a></p><p><a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">算法导论–最小生成树（Kruskal和Prim算法）</a></p><p><a href="https://juejin.im/entry/584abdff61ff4b0058d50547" target="_blank" rel="noopener">面试旧敌之 Java 泛型 ：主要概念及特点</a></p><hr><p><a href="https://blog.csdn.net/hrn1216/article/details/51465270" target="_blank" rel="noopener">最小堆 构建、插入、删除的过程图解</a></p><p><a href="https://www.cnblogs.com/ygj0930/p/5862684.html" target="_blank" rel="noopener">【数据库】数据库的并发问题与锁机制</a></p><p><a href="https://www.cnblogs.com/lxmhhy/p/6041001.html" target="_blank" rel="noopener">进程和线程、协程的区别</a></p><p><a href="https://juejin.im/post/5caf0f89f265da038145c66e" target="_blank" rel="noopener">渣渣二本的辛酸面试之路</a></p><p><a href="https://blog.csdn.net/zbuger/article/details/50827762" target="_blank" rel="noopener">java static锁和非static锁区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/fb59c770160c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;强缓存和协商缓存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a6c8
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读" scheme="https://meandni.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Flutter进阶：路由、路由栈详解及案例分析</title>
    <link href="https://meandni.com/2019/03/04/flutter-route/"/>
    <id>https://meandni.com/2019/03/04/flutter-route/</id>
    <published>2019-03-04T12:18:54.000Z</published>
    <updated>2019-04-12T07:24:28.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由初体验"><a href="#路由初体验" class="headerlink" title="路由初体验"></a>路由初体验</h1><p>路由（Routes）是什么？路由是屏幕或应用程序页面的抽象。</p><p>Flutter 使我们能够优雅地管理路由主要依赖的是 Navigator（导航器）类。这是一个用于管理一组具有某种进出规则的页面的 Widget，也就是说用它我们能够实现各个页面间有规律的切换。而这里的规则便是在其内部维护的一个“ 路由栈”。</p><p>学习 Android 的同学知道 Activity 的启动模式可以实现各种业务需求，iOS 中也有嵌套路由的功能，Flutter 作为最有潜力的跨平台框架当然要吸取众家之精华，它当然完全有能力实现原生的各种效果！</p><p>我们先尝试实现一个小的功能。</p><h2 id="组件路由"><a href="#组件路由" class="headerlink" title="组件路由"></a>组件路由</h2><p>当我们第一次打开应用程序，出现在眼前的便是路由栈中的第一个也是最底部实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(home: Screen1()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要在堆栈上推送新的实例，我们可以调用导航器 <code>Navigator.push</code> ，传入当前 context 并且使用构建器函数创建 MaterialPageRoute 实例，该函数可以创建您想要在屏幕上显示的内容。 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">   onPressed:()&#123;</span><br><span class="line">   Navigator.push(context, MaterialPageRoute&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> Scaffold(</span><br><span class="line">          appBar: AppBar(title: Text(<span class="string">'My Page'</span>)),</span><br><span class="line">          body: Center(</span><br><span class="line">            child: FlatButton(</span><br><span class="line">              child: Text(<span class="string">'POP'</span>),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Navigator.pop(context);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    ));</span><br><span class="line">   &#125;,</span><br><span class="line">   child: <span class="keyword">new</span> Text(<span class="string">"Push to Screen 2"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>点击执行上方操作，我们将成功打开第二个页面。</p><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>在一般应用中，我们用的最多的还是命名路由，它是将应用中需要访问的每个页面命名为不重复的字符串，我们便可以通过这个字符串来将该页面实例推进路由。</p><blockquote><p>例如，’/ home’ 表示 HomeScreen， ‘/ login’ 表示 LoginScreen。 ‘/‘ 表示主页面。 这里的命名规范与 REST API 开发中的路由类似。 所以 ‘/‘ 通常表示的是我们的根页面。</p></blockquote><p>请看下方案例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MaterialApp(</span><br><span class="line">  home: <span class="keyword">new</span> Screen1(),</span><br><span class="line">  routes: &lt;<span class="built_in">String</span>, WidgetBuilder&gt; &#123;</span><br><span class="line">    <span class="string">'/screen1'</span>: (BuildContext context) =&gt; <span class="keyword">new</span> Screen1(),</span><br><span class="line">    <span class="string">'/screen2'</span> : (BuildContext context) =&gt; <span class="keyword">new</span> Screen2(),</span><br><span class="line">    <span class="string">'/screen3'</span> : (BuildContext context) =&gt; <span class="keyword">new</span> Screen3(),</span><br><span class="line">    <span class="string">'/screen4'</span> : (BuildContext context) =&gt; <span class="keyword">new</span> Screen4()</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><em>Screen1()、Screen2()等是每个页面的类名。</em></p><p>我们同样可以实现前面的功能：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">   onPressed:()&#123;</span><br><span class="line">     Navigator.of(context).pushNamed(<span class="string">'/screen2'</span>);</span><br><span class="line">   &#125;,</span><br><span class="line">   child: <span class="keyword">new</span> Text(<span class="string">"Push to Screen 2"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">   onPressed:()&#123;</span><br><span class="line">     Navigator.pushNamed(context, <span class="string">"/screen2"</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   child: <span class="keyword">new</span> Text(<span class="string">"Push to Screen 2"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>同样可以实现上方效果。</p><h2 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h2><p>实现上面两种方法，此时，路由栈中的情况如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route1.png" alt="1_RKtC1MKJbjSfMjUlR-2K7g" title="">                </div>                <div class="image-caption">1_RKtC1MKJbjSfMjUlR-2K7g</div>            </figure><p>现在，当我们想要回退的到主屏幕时，我们则需要使用 pop 方法从 Navigator 的堆栈中弹出 Routes。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).pop();</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route2.png" alt="1_hq7qfAer0wCCSyIBKr7sfg" title="">                </div>                <div class="image-caption">1_hq7qfAer0wCCSyIBKr7sfg</div>            </figure><p>使用 Scaffold 时，通常不需要显式弹出路径，因为 Scaffold 会自动向其 AppBar 添加一个“后退”按钮，按下时会调用 <code>Navigator.pop()</code>。 </p><p>在 Android 中，按下设备后退按钮也会这样做。但是，我们也有可能需要将此方法用于其他组件，例如在用户单击“取消”按钮时弹出 AlertDialog。</p><blockquote><p><strong>这里要注意的是：</strong>切勿用 push 代替 pop，有同学说我在 Screen2 push Screen1 部照样能实现这个功能吗？其实不然啊，请看下图：</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route3.png" alt="1_Xsyo5c8s1JwO6f2OQ1nNEg" title="">                </div>                <div class="image-caption">1_Xsyo5c8s1JwO6f2OQ1nNEg</div>            </figure><blockquote><p>所以 <strong>push 只用于向栈中添加实例，pop 弹出实例！（特殊需求除外）</strong></p></blockquote><h1 id="详解路由栈"><a href="#详解路由栈" class="headerlink" title="详解路由栈"></a>详解路由栈</h1><p>前面，我们已经知道如何简单在路由栈中 push、pop 实例，然而，当遇到一些特殊的情况，这显然不能满足需求。学习 Android 的同学知道 Activity 的各种启动模式可以完成相应需求，Flutter 当然也有类似的可以解决各种业务需求的实现方式！</p><p>请看下面使用方法与案例分析。</p><h2 id="pushReplacementNamed-与-popAndPushNamed"><a href="#pushReplacementNamed-与-popAndPushNamed" class="headerlink" title="pushReplacementNamed 与 popAndPushNamed"></a>pushReplacementNamed 与 popAndPushNamed</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.pushReplacementNamed(context, <span class="string">"/screen4"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">"pushReplacementNamed"</span>),</span><br><span class="line">),</span><br><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.popAndPushNamed(context, <span class="string">"/screen4"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">"popAndPushNamed"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><em>我们在 Screen3 页面使用 <code>pushReplacementNamed</code> 与 <code>popAndPushNamed</code> 方法 push 了 Screen4。</em></p><p>此时路由栈情况如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route4.png" alt="1_cr77kgOgz7KRjwvMAVXoAg" title="">                </div>                <div class="image-caption">1_cr77kgOgz7KRjwvMAVXoAg</div>            </figure><p><strong>Screen4 代替了 Screen</strong>。</p><p><code>pushReplacementNamed</code> 与 <code>popAndPushNamed</code> 的区别在于：  <code>popAndPushNamed</code>  能够执行 Screen2 弹出的动画与 Screen3 推进的动画而 <code>pushReplacementNamed</code> 仅显示 Screen3 推进的动画。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route10.gif" alt="1_cr77kgOgz7KRjwvMAVXoAg" title="">                </div>                <div class="image-caption">1_cr77kgOgz7KRjwvMAVXoAg</div>            </figure><p>案例：</p><blockquote><p><strong>pushReplacementNamed</strong>：当用户成功登录并且现在在 <code>HomeScreen</code> 上时，您不希望用户还能够返回到 <code>LoginScreen</code>。因此，登录应完全由首页替换。另一个例子是从 <code>SplashScreen</code> 转到 <code>HomeScreen</code>。 它应该只显示一次，用户不能再从 <code>HomeScreen</code> 返回它。 在这种情况下，由于我们要进入一个全新的屏幕，我们可能需要借助此方法。</p><p><strong>popAndPushNamed</strong>：假设您正在有一个 <code>Shopping</code> 应用程序，该应用程序在 <code>ProductsListScreen</code> 中显示产品列表，用户可以在 <code>FiltersScreen</code> 中应用过滤商品。 当用户单击“应用筛选”按钮时，应弹出 <code>FiltersScreen</code> 并使用新的过滤器值推回到 <code>ProductsListScreen</code>。 这里 <code>popAndPushNamed</code> 显然更为合适。</p></blockquote><h2 id="pushNamedAndRemoveUntil"><a href="#pushNamedAndRemoveUntil" class="headerlink" title="pushNamedAndRemoveUntil"></a>pushNamedAndRemoveUntil</h2><blockquote><p>用户已经登陆进入 <code>HomeScreen</code> ，然后经过一系列操作回到配合只界面想要退出登录，你不能够直接 Push 进入 <code>LoginScreen</code> 吧？<strong>你需要将之前路由中的实例全部删除是的用户不会在回到先前的路由中。</strong></p></blockquote><p>pushNamedAndRemoveUntil 可实现该功能：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).pushNamedAndRemoveUntil(<span class="string">'/screen4'</span>, (Route&lt;<span class="keyword">dynamic</span>&gt; route) =&gt; <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>这里的 <code>(Route&lt;dynamic&gt; route) =&gt; false</code> 能够确保删除先前所有实例。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route5.png" alt="Logging out removes all routes and takes user back to LoginScreen" title="">                </div>                <div class="image-caption">Logging out removes all routes and takes user back to LoginScreen</div>            </figure><p>现在又有一个需求：我们不希望删除先前所有实例，<strong>我们只要求删除指定个数的实例</strong>。</p><blockquote><p>我们有一个需要付款交易的购物应用。在应用程序中，一旦用户完成了支付交易，就应该从堆栈中删除所有与交易或购物车相关的页面，并且用户应该被带到 <code>PaymentConfirmationScreen</code> ,单击后退按钮应该只将它们带回到 <code>ProductsListScreen</code> 或 <code>HomeScreen</code>：</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route6.png" alt="1_aaZxoLUbKdFPgiIkBAmw7w" title="">                </div>                <div class="image-caption">1_aaZxoLUbKdFPgiIkBAmw7w</div>            </figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).pushNamedAndRemoveUntil(<span class="string">'/screen4'</span>, ModalRoute.withName(<span class="string">'/screen1'</span>));</span><br></pre></td></tr></table></figure><p>通过代码，我们推送 <code>Screen4</code> 并删除所有路由，直到 <code>Screen1</code>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route7.png" alt="1_D81iZF-BikxXJHak7_NkhA" title="">                </div>                <div class="image-caption">1_D81iZF-BikxXJHak7_NkhA</div>            </figure><h2 id="popUntil"><a href="#popUntil" class="headerlink" title="popUntil"></a>popUntil</h2><p>想象一下，我们在应用程序中要填写一系列信息，表单分布在多个页面中。假设需要填写三个页面的表单一步接着一步。  然而，在表单的第 3 部分，用户取消了填写表单。 用户单击取消并且应弹出所有之前与表单相关的页面，并且应该将用户带回 <code>HomeScreen</code> 或者 <code>DashboardScreen</code>，这种情况下数据属于数据无效！ 我们不会在这里推新任何新东西，只是回到以前的路由栈中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route8.png" alt="1_qV7mF0Kow2zch-fjksmA_Q" title="">                </div>                <div class="image-caption">1_qV7mF0Kow2zch-fjksmA_Q</div>            </figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.popUntil(context, ModalRoute.withName(<span class="string">'/screen2'</span>));</span><br></pre></td></tr></table></figure><h2 id="Popup-routes（弹出路由）"><a href="#Popup-routes（弹出路由）" class="headerlink" title="Popup routes（弹出路由）"></a>Popup routes（弹出路由）</h2><p>路由不一定要遮挡整个屏幕。 <a href="https://docs.flutter.io/flutter/widgets/PopupRoute-class.html" target="_blank" rel="noopener">PopupRoute</a>s 使用 <a href="https://docs.flutter.io/flutter/widgets/ModalRoute/barrierColor.html" target="_blank" rel="noopener">ModalRoute.barrierColor</a>  覆盖屏幕，<a href="https://docs.flutter.io/flutter/widgets/ModalRoute/barrierColor.html" target="_blank" rel="noopener">ModalRoute.barrierColor</a> 只能部分不透明以允许当前屏幕显示。 弹出路由是“模态”的，因为它们阻止了对下面其他组件的输入。</p><p>有一些方法可以创建和显示这类弹出路由。 例如：showDialog，showMenu 和 showModalBottomSheet。 如上所述，这些函数返回其推送路由的 Future（异步数据，参考下面的数据部分）。 执行可以等待返回的值在弹出路由时执行操作。</p><p>还有一些组件可以创建弹出路由，如 PopupMenuButton 和 DropdownButton。 这些组件创建 PopupRoute 的内部子类，并使用 Navigator 的 push 和 pop 方法来显示和关闭它们。</p><h2 id="自定义路由"><a href="#自定义路由" class="headerlink" title="自定义路由"></a>自定义路由</h2><p>您可以创建自己的一个窗口z组件库路由类（如 PopupRoute，ModalRoute 或 PageRoute）的子类，以控制用于显示路径的动画过渡，路径的模态屏障的颜色和行为以及路径的其他各个特性。</p><p>PageRouteBuilder 类可以根据回调定义自定义路由。 下面是一个在路由出现或消失时旋转并淡化其子节点的示例。 此路由不会遮挡整个屏幕，因为它指定了opaque：false，就像弹出路由一样。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Navigator.push(context, PageRouteBuilder(</span><br><span class="line">  opaque: <span class="keyword">false</span>,</span><br><span class="line">  pageBuilder: (BuildContext context, _, __) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">'My PageRoute'</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  transitionsBuilder: (___, Animation&lt;<span class="built_in">double</span>&gt; animation, ____, Widget child) &#123;</span><br><span class="line">    <span class="keyword">return</span> FadeTransition(</span><br><span class="line">      opacity: animation,</span><br><span class="line">      child: RotationTransition(</span><br><span class="line">        turns: Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0.5</span>, end: <span class="number">1.0</span>).animate(animation),</span><br><span class="line">        child: child,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">));</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/route9.gif" alt="ezgif-3-14c32a6d8764" title="">                </div>                <div class="image-caption">ezgif-3-14c32a6d8764</div>            </figure><p>路由两部分构成，“pageBuilder”和“transitionsBuilder”。 该页面成为传递给 buildTransitions 方法的子代的后代。 通常，页面只构建一次，因为它不依赖于其动画参数（在此示例中以_和__表示）。 过渡是建立在每个帧的持续时间。</p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>一个应用程序可以使用多个路由导航器。将一个导航器嵌套在另一个导航器下方可用于创建“内部旅程”，例如选项卡式导航，用户注册，商店结帐或代表整个应用程序子部分的其他独立个体。</p><p>iOS应用程序的标准做法是使用选项卡式导航，其中每个选项卡都维护自己的导航历史记录。因此，每个选项卡都有自己的导航器，创建了一种“并行导航”。</p><p>除了选项卡的并行导航之外，还可以启动完全覆盖选项卡的全屏页面。例如：入职流程或警报对话框。因此，必须存在位于选项卡导航上方的“根”导航器。因此，每个选项卡的 Navigators 实际上都是嵌套在一个根导航器下面的 Navigators。</p><p>用于选项卡式导航的嵌套导航器位于 WidgetApp 和 <a href="https://docs.flutter.io/flutter/cupertino/CupertinoTabView-class.html" target="_blank" rel="noopener">CupertinoTabView</a> 中，因此在这种情况下您无需担心嵌套的导航器，但它是使用嵌套导航器的真实示例。</p><p>以下示例演示了如何使用嵌套的 Navigator 来呈现独立的用户注册过程。</p><p>尽管此示例使用两个 Navigators 来演示嵌套的 Navigators，但仅使用一个 Navigato r就可以获得类似的结果。 </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      <span class="comment">// ...some parameters omitted...</span></span><br><span class="line">      <span class="comment">// MaterialApp contains our top-level Navigator</span></span><br><span class="line">      initialRoute: <span class="string">'/'</span>,</span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">'/'</span>: (BuildContext context) =&gt; HomePage(),</span><br><span class="line">        <span class="string">'/signup'</span>: (BuildContext context) =&gt; SignUpPage(),</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line">   <span class="comment">// SignUpPage builds its own Navigator which ends up being a nested</span></span><br><span class="line">   <span class="comment">// Navigator in our app.</span></span><br><span class="line">   <span class="keyword">return</span> Navigator(</span><br><span class="line">     initialRoute: <span class="string">'signup/personal_info'</span>,</span><br><span class="line">     onGenerateRoute: (RouteSettings settings) &#123;</span><br><span class="line">       WidgetBuilder builder;</span><br><span class="line">       <span class="keyword">switch</span> (settings.name) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'signup/personal_info'</span>:</span><br><span class="line">           <span class="comment">// Assume CollectPersonalInfoPage collects personal info and then</span></span><br><span class="line">           <span class="comment">// navigates to 'signup/choose_credentials'.</span></span><br><span class="line">           builder = (BuildContext _) =&gt; CollectPersonalInfoPage();</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'signup/choose_credentials'</span>:</span><br><span class="line">           <span class="comment">// Assume ChooseCredentialsPage collects new credentials and then</span></span><br><span class="line">           <span class="comment">// invokes 'onSignupComplete()'.</span></span><br><span class="line">           builder = (BuildContext _) =&gt; ChooseCredentialsPage(</span><br><span class="line">             onSignupComplete: () &#123;</span><br><span class="line">               <span class="comment">// Referencing Navigator.of(context) from here refers to the</span></span><br><span class="line">               <span class="comment">// top level Navigator because SignUpPage is above the</span></span><br><span class="line">               <span class="comment">// nested Navigator that it created. Therefore, this pop()</span></span><br><span class="line">               <span class="comment">// will pop the entire "sign up" journey and return to the</span></span><br><span class="line">               <span class="comment">// "/" route, AKA HomePage.</span></span><br><span class="line">               Navigator.of(context).pop();</span><br><span class="line">             &#125;,</span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">throw</span> Exception(<span class="string">'Invalid route: <span class="subst">$&#123;settings.name&#125;</span>'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> MaterialPageRoute(builder: builder, settings: settings);</span><br><span class="line">     &#125;,</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Navigator.of 在给定 BuildContext 中最近的根 Navigator 上运行。 确保在预期的 Navigator 下面提供BuildContext，尤其是在创建嵌套 Navigators 的大型构建方法中。 Builder 组件可用于访问组件子树中所需位置的 BuildContext。</p><h1 id="页面间数据传递"><a href="#页面间数据传递" class="headerlink" title="页面间数据传递"></a>页面间数据传递</h1><h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>在上面的大多数示例中，我们推送新路由时没有发送数据，但在实际应用中这种情况应用很少。 要发送数据，我们将使用 Navigator 将新的 MaterialPageRoute 用我们的数据推送到堆栈上（这里是 <code>userName</code>）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> userName = <span class="string">"John Doe"</span>;</span><br><span class="line">Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">        builder: (BuildContext context) =&gt;</span><br><span class="line">        <span class="keyword">new</span> Screen5(userName)));</span><br></pre></td></tr></table></figure><p>要在 <code>Screen5</code> 中得到数据，我们只需在 <code>Screen5</code> 中添加一个参数化构造函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen5</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> userName;</span><br><span class="line">  Screen5(<span class="keyword">this</span>.userName);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="built_in">print</span>(userName)</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表示我们不仅可以使用 <code>MaterialPageRoute</code> 作为 <code>push</code> 方法，还可以使用 <code>pushReplacement</code> ，<code>pushAndPopUntil</code> 等。基本上从我们描述的上述方法中路由方法，第一个参数现在将采用 <code>MaterialPageRoute</code> 而不是 <code>namedRoute</code> 的 <code>String</code>。</p><h2 id="数据返回"><a href="#数据返回" class="headerlink" title="数据返回"></a>数据返回</h2><p>我们可能还想从新页面返回数据。 就像一个警报应用程序，并为警报设置一个新音调，您将显示一个带有音频音调选项列表的对话框。 显然，一旦弹出对话框，您将需要所选的项目数据。 它可以这样实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(onPressed: ()<span class="keyword">async</span>&#123;</span><br><span class="line">  <span class="built_in">String</span> value = <span class="keyword">await</span> Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> GestureDetector(</span><br><span class="line">              child: <span class="keyword">new</span> Text(<span class="string">'OK'</span>),</span><br><span class="line">              onTap: () &#123; Navigator.pop(context, <span class="string">"Audio1"</span>); &#125;</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">  )</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">print</span>(value);</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">  child: <span class="keyword">new</span> Text(<span class="string">"Return"</span>),)</span><br></pre></td></tr></table></figure><p><em>在 <code>Screen4</code> 中尝试并检查控制台的打印值。</em></p><p>另请注意：当路由用于返回值时，路由的类型参数应与 pop 的结果类型匹配。 这里我们需要一个 String 数据，所以我们使用了 <code>MaterialPageRoute &lt;String&gt;</code>。 不指定类型也没关系。</p><h1 id="其他效果解释"><a href="#其他效果解释" class="headerlink" title="其他效果解释"></a>其他效果解释</h1><h2 id="maybePop"><a href="#maybePop" class="headerlink" title="maybePop"></a>maybePop</h2><p>源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;<span class="built_in">bool</span>&gt; maybePop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, [ T result ]) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.of(context).maybePop&lt;T&gt;(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; maybePop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;([ T result ]) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Route&lt;T&gt; route = _history.last;</span><br><span class="line">    <span class="keyword">assert</span>(route._navigator == <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">final</span> RoutePopDisposition disposition = <span class="keyword">await</span> route.willPop();</span><br><span class="line">    <span class="keyword">if</span> (disposition != RoutePopDisposition.bubble &amp;&amp; mounted) &#123;</span><br><span class="line">      <span class="keyword">if</span> (disposition == RoutePopDisposition.pop)</span><br><span class="line">        pop(result);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果我们在初始路由上并且有人错误地试图弹出这个唯一页面怎么办？ 弹出堆栈中唯一的页面将关闭您的应用程序，因为它后面已经没有页面了。这显然是不好的体验。 这就是 <code>maybePop()</code> 起的作用。 点击 <code>Screen1</code> 上的 <code>maybePop</code> 按钮，没有任何效果。 在 <code>Screen3</code> 上尝试相同的操作，可以正常弹出。</p><p>这种效果也可通过 canPop 实现：</p><h2 id="canPop"><a href="#canPop" class="headerlink" title="canPop"></a>canPop</h2><p>源码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> canPop(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> NavigatorState navigator = Navigator.of(context, nullOk: <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> navigator != <span class="keyword">null</span> &amp;&amp; navigator.canPop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> canPop() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_history.isNotEmpty);</span><br><span class="line">    <span class="keyword">return</span> _history.length &gt; <span class="number">1</span> || _history[<span class="number">0</span>].willHandlePopInternally;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果占中实例大于 1 或 willHandlePopInternally 属性为 true 返回 true，否则返回 false。</p><p>我们可以通过判断 canPop 来确定是否能够弹出该页面。</p><h2 id="如何去除默认返回按钮"><a href="#如何去除默认返回按钮" class="headerlink" title="如何去除默认返回按钮"></a>如何去除默认返回按钮</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">AppBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.leading,</span><br><span class="line">    <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="keyword">this</span>.actions,</span><br><span class="line">    <span class="keyword">this</span>.flexibleSpace,</span><br><span class="line">    <span class="keyword">this</span>.bottom,</span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">4.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="keyword">this</span>.brightness,</span><br><span class="line">    <span class="keyword">this</span>.iconTheme,</span><br><span class="line">    <span class="keyword">this</span>.textTheme,</span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.centerTitle,</span><br><span class="line">    <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line">    <span class="keyword">this</span>.toolbarOpacity = <span class="number">1.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.bottomOpacity = <span class="number">1.0</span>,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(automaticallyImplyLeading != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(elevation != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(primary != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(titleSpacing != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(toolbarOpacity != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(bottomOpacity != <span class="keyword">null</span>),</span><br><span class="line">       preferredSize = Size.fromHeight(kToolbarHeight + (bottom?.preferredSize?.height ?? <span class="number">0.0</span>)),</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br></pre></td></tr></table></figure><p>将 <code>automaticallyImplyLeading</code>置为 <code>false</code></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://docs.flutter.io/flutter/widgets/Navigator-class.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/widgets/Navigator-class.html</a></p><p><a href="https://medium.com/flutter-community/flutter-push-pop-push-1bb718b13c31" target="_blank" rel="noopener">https://medium.com/flutter-community/flutter-push-pop-push-1bb718b13c31</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;路由初体验&quot;&gt;&lt;a href=&quot;#路由初体验&quot; class=&quot;headerlink&quot; title=&quot;路由初体验&quot;&gt;&lt;/a&gt;路由初体验&lt;/h1&gt;&lt;p&gt;路由（Routes）是什么？路由是屏幕或应用程序页面的抽象。&lt;/p&gt;
&lt;p&gt;Flutter 使我们能够优雅地管理路由
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter实践：深入 Flutter 的状态管理方式(3)——Redux与旅途小结</title>
    <link href="https://meandni.com/2019/02/09/flutter-state3/"/>
    <id>https://meandni.com/2019/02/09/flutter-state3/</id>
    <published>2019-02-09T08:54:54.000Z</published>
    <updated>2019-04-12T06:05:01.301Z</updated>
    
    <content type="html"><![CDATA[<p>至此，这已经是探索 Flutter 状态管理方式文章的最后一篇，同时这也是新年后的第一篇文章，之后我将将他们应用在实际项目中开发并将值的学习的项目开源出来。对于其中讲解可能有点浅尝则止，因为给出的实例相对简单，但相信聪明的程序员都会有自己的学习方法，你可以从给出的实例结合自己的所学引深出更好的设计方法。</p><p>同时要送给大家的建议是：请在需要这些状态管理方式时使用它，我见过不少的开发者都有用大刀砍白菜的意思，这并不是一个好习惯，你会发现这些状态管理方式有时候不但不会使开发简单，其实还会加大代码量，使其变得复杂，对于如何选择，这里还不够说清楚，希望你们都能找到自己的管理应用程序的方式。</p><p>所有实例：</p><p> github 地址：<a href="https://github.com/MeandNi/Flutter_StateManagement" target="_blank" rel="noopener">https://github.com/MeandNi/Flutter_StateManagement</a></p><ul><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/inheritedValue" target="_blank" rel="noopener">InheritedWidget</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/scoped" target="_blank" rel="noopener">ScopedModel</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/bloc_counter" target="_blank" rel="noopener">bloc_counter</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/bloc_cart" target="_blank" rel="noopener">bloc_cart</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/bloc_inherited" target="_blank" rel="noopener">bloc with inherited</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/redux_counter" target="_blank" rel="noopener">Redux_counter</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/redux_cart" target="_blank" rel="noopener">Redux_Cart</a></li></ul><hr><p>Redux 由 Facebook 2015年提出，是基于 Flux 理念实现的一个响应式框架的状态管理方式，最早应用于 React 中，而后 React Native 、 Flutter 等多个框架也同样可以使用。</p><p>学习 Redux 之前，请了解 Redux 所能做到的事情：</p><ul><li>单一状态来源：整个应用程序的状态存储在单个的对象树中。</li><li>状态只读：更改状态的唯一方法是发出一个 action（一个描述发生什么事件的对象）。</li><li>使用纯函数更改状态：通过 reducers，状态知道如何通过操作进行改变，reducers便是一个纯函数。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/redux1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>如果你用过 React ，相信你对上面的概念已经很清晰了，没使用过？也 OK，下面慢慢道来….</p><p>整体的思路：所有状态存放在 store 中，Redux 将 store 内所有状态放入对应的组件中呈现在 Ui 上，用户与 UI 交互（如点击）发起一个 action（一个描述行为的对象），store 可判别 action类型并作用相应的 reducer（操作改变状态的纯函数），reducer 完成相应改变后将数据放到全局的 store 中，实现改变。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/redux2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>思路简单，描述起来蛮复杂，其实它的目的就是实现代码作用域的分离。</p><p>那么如何让将以上描述应用于实际的应用程序中呢？</p><h2 id="redux-实现计数器应用"><a href="#redux-实现计数器应用" class="headerlink" title="redux 实现计数器应用"></a>redux 实现计数器应用</h2><p>其中的实现与 ScopedModel 很相似，<strong>抓住两个要点，如何在 UI 中呈现以及如何 发起 action 改变状态。</strong></p><p>我们首先定义 一个全局状态 AppState：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> counter;</span><br><span class="line">  AppState(<span class="keyword">this</span>.counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有一个 counter 变量用于计数。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>如前面所述，State 的变化，会导致 UI 的变化。但是，用户接触不到 State，只能接触到 UI。所以，State 的变化必须是 UI 导致的。Action 就是 UI 发出的通知，表示 State 应该要发生变化了。</p><p>我们这里有一个促使 counter 增加的 action：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Actions &#123; Increment &#125;</span><br></pre></td></tr></table></figure><h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p><p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AppState reducer(AppState prev, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action == Actions.Increment) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppState(prev.counter + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reducer 中判断了 action 时 Increment 这一类型，将一个新的 AppState 返回到 store。</p><h3 id="在-UI-中呈现-StoreConnector"><a href="#在-UI-中呈现-StoreConnector" class="headerlink" title="在 UI 中呈现(StoreConnector)"></a>在 UI 中呈现(StoreConnector)</h3><p>首先初始化状态：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> store = <span class="keyword">new</span> Store(reducer, initialState: <span class="keyword">new</span> AppState(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>然后显示状态：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> StoreConnector(</span><br><span class="line">  converter: (store) =&gt; store.state.counter,</span><br><span class="line">  builder: (context, counter) =&gt; <span class="keyword">new</span> Text(</span><br><span class="line">    <span class="string">'$counter'</span>,</span><br><span class="line">    style: Theme.of(context).textTheme.display1,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通过 converter 属性拿到 state 中的 counter 属性。</p><p>然后传入 builder 应用在组件中。</p><h3 id="发起-action-改变状态"><a href="#发起-action-改变状态" class="headerlink" title="发起 action 改变状态"></a>发起 action 改变状态</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> StoreConnector(</span><br><span class="line">    converter: (store) &#123;</span><br><span class="line">      <span class="keyword">return</span> () =&gt; store.dispatch(Actions.Increment);</span><br><span class="line">    &#125;,</span><br><span class="line">    builder: (context, callback) =&gt; <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">      onPressed: callback,</span><br><span class="line">      tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">      child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">    ), </span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>同样是使用 StoreConnector，然而这次通过 converter 拿到的是一个 <code>store.dispatch(Actions.Increment)</code>，<code>store.dispatch()</code>是 View 发出 Action 的唯一方法。而后在组件中调用该回调方法即可。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码被放在一个文件中：<a href="https://github.com/MeandNi/Flutter_StateManagement/blob/master/lib/redux/main.dart" target="_blank" rel="noopener">样例代码</a></p><p>Redux 应用在 ShoppingCart：<a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/redux_cart" target="_blank" rel="noopener">样例代码</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/redux6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/redux5.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="将-Redux-用于更复杂的应用中"><a href="#将-Redux-用于更复杂的应用中" class="headerlink" title="将 Redux 用于更复杂的应用中"></a>将 Redux 用于更复杂的应用中</h2><p>在复杂的应用中我们可以将应用程序中的 reducer 根据业务类型分离，例如用户信息、产品信息等不同业务的操作分离到单独的模块，</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/redux3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>而后将其合并：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/redux4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>实现上看的分离后，又可只将相应业务的数据放到相应业务根 widget（其子组件的所有数据和操作来自该根组件）</p><p>我们将需要的数据及操作到一个对象中，传递到组件中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceFragment</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: <span class="keyword">new</span> StoreConnector&lt;AppState, _ViewModel&gt;(</span><br><span class="line">          converter: _ViewModel.fromStore,</span><br><span class="line">          builder: (context, vm) &#123;</span><br><span class="line">            <span class="keyword">return</span> DeviceList(</span><br><span class="line">              devices: vm.devices,</span><br><span class="line">              onStateChanged: vm.onStateChanged,</span><br><span class="line">              onRemove: vm.onRemove,</span><br><span class="line">              onUndoRemove: vm.onUndoRemove,</span><br><span class="line">            );</span><br><span class="line">          &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Device&gt; devices;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// final bool loading;</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span>(Device) onStateChanged;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span>(Device) onRemove;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span>(Device) onUndoRemove;</span><br><span class="line"></span><br><span class="line">  _ViewModel(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.devices,</span><br><span class="line">    <span class="comment">// @required this.loading,</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onStateChanged,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onRemove,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onUndoRemove,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> _ViewModel fromStore(Store&lt;AppState&gt; store) &#123;</span><br><span class="line">    <span class="keyword">return</span> _ViewModel(</span><br><span class="line">      devices: store.state.devices,</span><br><span class="line">      <span class="comment">// loading: store.state.isLoading,</span></span><br><span class="line">      onStateChanged: (device) &#123;</span><br><span class="line">        store.dispatch(editItem(device.copyWith(state: !device.state)));</span><br><span class="line">      &#125;,</span><br><span class="line">      onRemove: (device) &#123;</span><br><span class="line">        store.dispatch(deleteDevice(device));</span><br><span class="line">      &#125;,</span><br><span class="line">      onUndoRemove: (device) &#123;</span><br><span class="line">        store.dispatch(AddDeviceAction(device));</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使得产生模块化管理的思想！（以上实例来自正在开发的一个真实项目，目前还未开源。）</p><p>同时，在实际的应用程序中，你一定需要在程序启动初期来加载来自云端或者数据本地的数据，你可以在入口的页面中接受一个加载数据的函数，放入 initState 函数中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;至此，这已经是探索 Flutter 状态管理方式文章的最后一篇，同时这也是新年后的第一篇文章，之后我将将他们应用在实际项目中开发并将值的学习的项目开源出来。对于其中讲解可能有点浅尝则止，因为给出的实例相对简单，但相信聪明的程序员都会有自己的学习方法，你可以从给出的实例结合自
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="技术" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Flutter实践：深入 Flutter 的状态管理方式(2)——演化BloC</title>
    <link href="https://meandni.com/2019/02/02/flutter-state1/"/>
    <id>https://meandni.com/2019/02/02/flutter-state1/</id>
    <published>2019-02-02T04:34:27.000Z</published>
    <updated>2019-04-12T06:04:56.884Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇文章中，我详细介绍了 InheritedWidget 及 ScopedModel 实现原理与方法，有同学说找不到源码，其实上篇文章包括这篇文章里的源码都按步骤放在<a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">样例代码</a>里了，有同学说有点懵，其实上一篇的概念过多而且本身我表达也不是很清晰，英文文档中我也解释的没有完全语义化，所以还请谅解，<strong>结合实际代码你会有更好地理解</strong>。</p><p>这篇的重点我将放在 BloC 的实现上面，我们已经知道 Strems 的概念，RXDart 是依赖 Streams 使用的输入（<em>Sink</em>）和输出（<em>stream</em>）封装而成的响应式库，BloC 基于此便可以实时侦听数据的变化而改变数据，并且，BloC 主要解决的问题就是他不会一刀切的更新整个状态树，它关注的是数据，经过一系列处理后得到它并且只改变应用它的 widget。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/flutterstate2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="如何将-Stream-中的数据应用到-Widget？"><a href="#如何将-Stream-中的数据应用到-Widget？" class="headerlink" title="如何将 Stream 中的数据应用到 Widget？"></a>如何将 Stream 中的数据应用到 Widget？</h3><p>我们先来实践一下如何在 widget 中使用数据。Flutter 提供了一个名为 <a href="https://docs.flutter.io/flutter/widgets/StreamBuilder-class.html" target="_blank" rel="noopener">StreamBuilder</a> 的 StatefulWidget。</p><p>StreamBuilder 监听 Stream，每当一些数据流出 Stream 时，它会自动重建，调用其构建器回调。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StreamBuilder&lt;T&gt;(</span><br><span class="line">    key: ...optional, the unique ID of <span class="keyword">this</span> Widget...</span><br><span class="line">    stream: ...the stream to listen to...</span><br><span class="line">    initialData: ...any initial data, <span class="keyword">in</span> <span class="keyword">case</span> the stream would initially be empty...</span><br><span class="line">    builder: (BuildContext context, AsyncSnapshot&lt;T&gt; snapshot)&#123;</span><br><span class="line">        <span class="keyword">if</span> (snapshot.hasData)&#123;</span><br><span class="line">            <span class="keyword">return</span> ...the Widget to be built based on snapshot.data</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ...the Widget to be built <span class="keyword">if</span> no data <span class="keyword">is</span> available</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>以下示例使用 Stream 而不是 setState() 模拟默认的“计数器”应用程序：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;<span class="built_in">int</span>&gt; _streamController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _streamController.close();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: _streamController.stream,</span><br><span class="line">          initialData: _counter,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          _streamController.sink.add(++_counter);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第24-30行：我们监听流，每次有一个新值流出这个流时，我们用该值更新 Text;</li><li>第35行：当我们点击 FloatingActionButton 时，我们递增计数器并通过接收器将其发送到 Stream; 侦听它的 StreamBuilder 注入了该值相应到后重建并“刷新”计数器;</li><li>我们不再需要 State，所有东西都可以通过 Stream 接受;</li><li>这里实现了相当大的优化，因为调用 setState() 方法会强制整个 Widget（和任何子组件）重新渲染。 而在这里，只重建 StreamBuilder（当然还有其子组件）;</li><li>我们仍需要使用 StatefulWidget 的唯一原因，仅仅是因为我们需要通过 dispose 方法第15行释放StreamController;</li></ul><h3 id="实现真正的-BloC"><a href="#实现真正的-BloC" class="headerlink" title="实现真正的 BloC"></a>实现真正的 BloC</h3><p>是时候展现真正的计技术了，我们依然将 BloC 用于默认的计数器应用中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">          bloc: IncrementBloc(),</span><br><span class="line">          child: CounterPage(),</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: bloc.outCounter,</span><br><span class="line">          initialData: <span class="number">0</span>,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          bloc.incrementCounter.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _counterController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  StreamSink&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> _inAdd =&gt; _counterController.sink;</span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> outCounter =&gt; _counterController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the action on the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController _actionController = StreamController();</span><br><span class="line">  StreamSink <span class="keyword">get</span> incrementCounter =&gt; _actionController.sink;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  IncrementBloc()&#123;</span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    _actionController.stream</span><br><span class="line">                     .listen(_handleLogic);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _actionController.close();</span><br><span class="line">    _counterController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleLogic(data)&#123;</span><br><span class="line">    _counter = _counter + <span class="number">1</span>;</span><br><span class="line">    _inAdd.add(_counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是上篇文章的最后给打大家制造悬念的代码？五脏俱全，基本已经实现了 BloC。</p><p>结合上面的例子来分析 BloC 体现出来的优势：（建议先将<a href="https://github.com/MeandNi/Flutter_StatePro/blob/master/lib/bloc_counter/main.dart" target="_blank" rel="noopener">这段代码</a>跑起来！）</p><h4 id="一，BloC-实现了责任分离"><a href="#一，BloC-实现了责任分离" class="headerlink" title="一，BloC 实现了责任分离"></a>一，BloC 实现了责任分离</h4><p>你可以看到 CounterPage（第21-45行），其中没有任何业务逻辑。</p><p>它承担的负责仅有：</p><ul><li>显示计数器，现在只在必要时更新</li><li>提供一个按钮，当按下时，请求执行动作</li></ul><p>此外，整个业务逻辑集中在一个单独的类“IncrementBloc”中。</p><p>如果现在，如果我们需要更改业务逻辑，只需更新方法 _handleLogic（第77-80行）。 也许新的业务逻辑将要求做非常复杂的事情…… CounterPage 永远与它无关！</p><h4 id="二，可测试性"><a href="#二，可测试性" class="headerlink" title="二，可测试性"></a>二，可测试性</h4><p>现在，测试业务逻辑也变得更加容易。</p><p>无需再通过用户界面测试业务逻辑。 只需要测试 IncrementBloc 类。</p><h4 id="三，任意组织布局"><a href="#三，任意组织布局" class="headerlink" title="三，任意组织布局"></a>三，任意组织布局</h4><p>由于使用了 Streams，您现在可以独立于业务逻辑组织布局。</p><p>你可以从应用程序中的任何位置用任何操作：只需调用 <em>.incrementCounter</em> 接收器即可。</p><p>您可以在任何页面的任何位置显示计数器，只需舰艇监听 .outCounter 流。</p><h4 id="四，减少-“build”-的数量"><a href="#四，减少-“build”-的数量" class="headerlink" title="四，减少 “build” 的数量"></a>四，减少 “build” 的数量</h4><p>不用 <code>setState()</code>而是使用 StreamBuilder，从而大大减少了“构建”的数量，只减少了所需的数量。</p><p>这是性能上的巨提高！</p><h4 id="只有一个约束……-BLoC的可访问性"><a href="#只有一个约束……-BLoC的可访问性" class="headerlink" title="只有一个约束…… BLoC的可访问性"></a>只有一个约束…… BLoC的可访问性</h4><p>为了达到各种目的，BLoC 需要可访问。</p><p>有以下几种方法可以访问它：</p><ul><li><p>通过全局单例的变量</p><p>这种方式很容易实现，但不推荐。 此外，由于 Dart 中没有类析构函数，因此我们永远无法正确释放资源。</p></li><li><p>作为本地实例</p><p>您可以实例化 BLoC 的本地实例。 在某些情况下，此解决方案完全符合需求。 在这种情况下，您应该始终考虑在 StatefulWidget 中初始化，以便您可以利用 dispose() 方法来释放它。</p></li><li><p>由根组件提供<br>使其可访问的最常见方式是通过根 Widget，将其实现为 StatefulWidget。</p><p>以下代码给出了一个通用 BlocProvider 的示例：（这个例子牛逼！）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic Interface for all BLoCs</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic BLoC provider</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  BlocProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;();</span><br><span class="line">    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type);</span><br><span class="line">    <span class="keyword">return</span> provider.bloc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">BlocBase</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    widget.bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这段通用的 <em>BlocProvider</em> 仔细回味，你会发现其精妙之处！</p><p>通用 <em>BlocProvider</em> 的一些解释：</p><p>首先，如何将其用作数据提供者？</p><p>如果你看了上面<a href="https://gist.github.com/MeandNi/1161560bf90c5bc7f341844e8126a8f4" target="_blank" rel="noopener">BloC 计数器的示例代码</a>示例代码，您将看到以下代码行（第12-15行）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">         bloc: IncrementBloc(),</span><br><span class="line">         child: CounterPage(),</span><br><span class="line">       ),</span><br></pre></td></tr></table></figure><p>使用以上代码，我们实例化了一个想要处理 <em>IncrementBloc</em> 的新 <em>BlocProvider</em>，并将 <em>CounterPage</em> 呈现为子组件。</p><p>从 <em>BlocProvider</em> 开始的子组件的任何组件部分都将能够通过以下行访问 <em>IncrementBloc</em>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br></pre></td></tr></table></figure></li></ul><p>BLoC 的基本使用就介绍完了，所有<a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">实例代码在这里</a> ，我将每种状态管理的方法分模块放在里面，选择使用哪种方式运行代码即可。</p><h3 id="BloC-其他你必须知道的事情"><a href="#BloC-其他你必须知道的事情" class="headerlink" title="BloC 其他你必须知道的事情"></a>BloC 其他你必须知道的事情</h3><h4 id="可以实现多个-BloC"><a href="#可以实现多个-BloC" class="headerlink" title="可以实现多个 BloC"></a>可以实现多个 BloC</h4><p>在大型项目中，这是非常可取的。 给以下几个建议：</p><ul><li>（如果有任何业务逻辑）每页顶部有一个BLoC，</li><li>用一个 ApplicationBloc 来处理应用程序所有状态</li><li>每个“足够复杂的组件”都有相应的BLoC。</li></ul><p>以下示例代码在整个应用程序的顶部使用 <em>ApplicationBloc</em>，然后在 <em>CounterPage</em> 顶部使用 <em>IncrementBloc</em>。该示例还展示了如何使用两个 Bloc：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(</span><br><span class="line">  BlocProvider&lt;ApplicationBloc&gt;(</span><br><span class="line">    bloc: ApplicationBloc(),</span><br><span class="line">    child: MyApp(),</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">      home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">        bloc: IncrementBloc(),</span><br><span class="line">        child: CounterPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc counterBloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line">    <span class="keyword">final</span> ApplicationBloc appBloc = BlocProvider.of&lt;ApplicationBloc&gt;(context);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为何不用-InheritedWidget-来全局管理-BloC-的状态"><a href="#为何不用-InheritedWidget-来全局管理-BloC-的状态" class="headerlink" title="为何不用 InheritedWidget 来全局管理 BloC 的状态"></a>为何不用 InheritedWidget 来全局管理 BloC 的状态</h4><p>我为此也整理了一个将 BLoC 结合 InheritedWidget 使用的示例：</p><p>在很多与 BLoC 相关的文章中，您将看到 <em>Provider</em> 的实现其实是一个 <em>InheritedWidget</em>。</p><p>当然，  这是完全可以实现的，然而，</p><ul><li>一个 <em>InheritedWidget</em> 没有提供任何 <em>dispose</em> 方法，记住，在不再需要资源时总是释放资源是一个很好的做法。</li><li>当然，你也可以将 <em>InheritedWidget</em> 包装在另一个 <em>StatefulWidget</em> 中，但是，乍样使用 <em>InheritedWidget</em> 并没有什么便利之处！</li><li>最后，如果不受控制，使用 <em>InheritedWidget</em> 经常会导致一些副作用（请参阅下面的  <em>InheritedWidget</em> 上的提醒）。</li></ul><p>这 3 点解释了我为何将通用 BlocProvider 实现为 StatefulWidget，这样我就可以<strong>释放资源</strong>。</p><blockquote><p>Flutter无法实例化泛型类型</p><p>不幸的是，Flutter 无法实例化泛型类型，我们必须将 BLoC 的实例传递给 BlocProvider。 为了在每个BLoC中强制执行 dispose() 方法，所有BLoC都必须实现 BlocBase 接口。</p></blockquote><h4 id="关于使用-InheritedWidget-的提醒"><a href="#关于使用-InheritedWidget-的提醒" class="headerlink" title="关于使用 InheritedWidget 的提醒"></a>关于使用 InheritedWidget 的提醒</h4><p>在使用 <em>InheritedWidget</em> 并通过 <em>context.inheritFromWidgetOfExactType(…)</em> 获取指定类型最近的 <em>Widget</em> 时，每当InheritedWidget 的父级或者子布局发生变化时，这个方法会自动将当前 “<em>context</em>”（= <em>BuildContext</em>）注册到要重建的 <em>widget</em> 当中。</p><blockquote><p>请注意，为了完全正确，我刚才解释的与 <em>InheritedWidget</em> 相关的问题只发生在我们将 <em>InheritedWidget</em> 与 <em>StatefulWidget</em> 结合使用时。 当您只使用没有 State 的 InheritedWidget 时，问题就不会发生。 </p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flutter 状态管理的这几种模式同样可以适用于很多软件开发中，而 BloC 模式最初的设想是实现允许独立于平台重用相同的代码！因此多花时间学习这类模式便是软件开发的根基。</p><p>我的建议是将<strong>实例代码运行出来阅读代码</strong>，依靠文章理解！希望能帮助到你！</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>这篇内容是我反复看完 <a href="https://www.youtube.com/watch?v=RS36gBEp8OI&amp;index=115&amp;list=PLOU2XLYxmsIInFRc3M44HUTQc3b_YJ4-Y" target="_blank" rel="noopener">Build reactive mobile apps with Flutter (Google I/O ‘18)</a> 谷歌大会写完的。</p><p>并且大量借鉴了 <a href="https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/" target="_blank" rel="noopener">Reactive Programming - Streams - BLoC</a> 这篇文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上篇文章中，我详细介绍了 InheritedWidget 及 ScopedModel 实现原理与方法，有同学说找不到源码，其实上篇文章包括这篇文章里的源码都按步骤放在&lt;a href=&quot;https://github.com/MeandNi/Flutter_StatePro&quot;
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="技术" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Flutter实践：深入探索 Flutter 中的状态管理方式(1)</title>
    <link href="https://meandni.com/2019/01/30/flutter-state1/"/>
    <id>https://meandni.com/2019/01/30/flutter-state1/</id>
    <published>2019-01-30T12:54:19.000Z</published>
    <updated>2019-04-12T06:04:53.886Z</updated>
    
    <content type="html"><![CDATA[<p>利用 Flutter 内置的许多控件我们可以打造出一款不仅漂亮而且完美跨平台的 App 外壳，我利用其特性完成了类似<a href="https://github.com/MeandNi/Flutter_ZhiHu" target="_blank" rel="noopener">知乎App的UI界面</a>，然而一款完整的应用程序显然不止有外壳这么简单。填充在外壳里面的是数据，数据来源或从本地，或从云端，大量的数据处理很容易造成数据的混乱，耦合度提高，不便于维护，于是诞生了很多设计模式和状态管理的方式。</p><p>目前 Flutter 常用状态管理方式有如下几种：</p><ul><li>ScopedModel</li><li>BLoC (Business Logic Component) / Rx</li><li>Redux</li></ul><p>这篇文章暂且不提这些比较复杂的模式。我们简单的提出三个问题：</p><ul><li>Flutter 中组件之间如何通信？</li><li>更新 State 后组件以何种方式重新渲染？</li><li>如何在路由转换之间保持状态同步？</li></ul><h3 id="初探-State"><a href="#初探-State" class="headerlink" title="初探 State"></a>初探 State</h3><p>我以创建新项目 Flutter 给我们默认的计数器应用为例，通过路由我将其拆分为两部分 <code>MyHomePage</code>和 <code>PageTwo</code>，</p><p>MyHomePage，持有一个<code>_counter</code>变量和一个增加计数的方法，PageTwo，接收两个参数(计数的至和增加计数的方法)：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageTwo</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> count;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span> increment;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> PageTwo(&#123;Key key, <span class="keyword">this</span>.count, <span class="keyword">this</span>.increment&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  _PageTwoState createState() =&gt; _PageTwoState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PageTwoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">PageTwo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"Page Two"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(widget.count.toString(), style: TextStyle(fontSize: <span class="number">30.0</span>),),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">        onPressed: widget.increment,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现的状况是：我们在首页点击按钮触发计数器增加，路由到 PageTwo 后，数值正常显示，然而点击这个界面中的 add 按钮该页面的数值并未发生改变，通过观察父页面的 count 值确实发生了改变，因此再次通过路由到第二个界面界面才显示正常。解答上面三个问题：</p><ul><li><p>Flutter 中组件之间如何通信？</p><p>参数传递。</p></li><li><p>更新 State 后组件以何种方式重新渲染？</p><p>只渲染当前的组件（和子组件，这里暂未证明，但确实是触发 SetSate() 后，其所有子组件都将重新渲染。）</p></li><li><p>如何在路由转换之间保持状态同步？</p><p>父组件传递状态值到子组件，子组件拿到并显示，但却不能实时更改😀，我一时半会还正没想出什么解决方法，我相信即使能做到也不优雅。</p></li></ul><p>证明触发 SetSate() 后，其所有子组件都将重新渲染：我在副组件中添加两个子组件，一旦触发渲染变打印相关数据：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TestStateless(),</span><br><span class="line">TestStateful()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStateless</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'build TestStateless'</span>);</span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'TestStateless'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStateful</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TestStatefulState createState() =&gt; _TestStatefulState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TestStatefulState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TestStateful</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'build TestStateful'</span>);</span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'_TestStatefulState'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时到 PageTwo 触发 add 事件，日志出来：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/flutterstate1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过这种简单的方式已经可以说明一个问题，即以最简单的方式我们已经可以完成状态传递和组件渲染，而路由间保持状态一致还不能解决。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/flutterstate8.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>Google 官方给我们的解决方案是 <code>InheritedWidget</code>，怎么理解他，我们可以称它为“状态树”，它使得所有的 widget 的 State 来源统一，这样一旦有一处触发状态改变，Flutter 以某种方式感应到了（有个监听器），砍掉它，长出一个新树，Perfect！所有地方都能感受到他的变化。上面提到的第一种状态管理方式 <code>ScopedModel</code>便是基于此而产生的一套第三方库。</p><p>其实现在看来 InheritedWidget 已经非常简单了，我们抓住两个点即可完全掌握它：</p><ol><li><p>状态树中的数据</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInheritedValue</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyInheritedValue(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.value,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(value != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(child != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> value;</span><br><span class="line">  <span class="keyword">static</span> MyInheritedValue of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.inheritFromWidgetOfExactType(MyInheritedValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(MyInheritedValue old) =&gt; </span><br><span class="line">        value != old.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入到根组件中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> MyInheritedValue(</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    child: ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用状态树中数据的其他 Widget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 拿到状态树中的值</span><br><span class="line">MyInheritedValue.of(context).value</span><br></pre></td></tr></table></figure><p>请注意：这种情况下是不能改 InheritedWidget 中的值的，需要改也很简单就是将 MyInheritedValue 的值封装成一个对象，每次改变这个对象的值，具体法相看我的<a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">样例代码</a>！</p><p><img src="/images/flutterstate7.png" alt=""></p></li></ol><p>上面所说砍掉整棵树过于粗暴却并不夸张，因为一处改变它将联动整棵树，</p><p>ScopedModel 是基于 InheritedWidget 的库，实现起来与 InheritedWidget 大同小异，而且其有一种可以让局部组件不改变的方式：设置 rebuildOnChange 为 false。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ScopedModelDescendant&lt;CartModel&gt;(</span><br><span class="line">          rebuildOnChange: <span class="keyword">false</span>,</span><br><span class="line">          builder: (context, child, model) =&gt; ProductSquare(</span><br><span class="line">                product: product,</span><br><span class="line">                onTap: () =&gt; model.add(product),</span><br><span class="line">              ),</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>具体代码请看 GitHub，ScopedModel 样例截取一个老外给的实例，就是下方参考链接 Google 开发者大会上演讲的那两位其中之一。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/flutterstate9.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这种方式显然有点不足之处就是一旦遇到小规模变动就要引起大规模重新渲染，所以当项目达到一定的规模考虑 Google 爸爸给我们的另一种解决方案。</p><h3 id="Streams（流）"><a href="#Streams（流）" class="headerlink" title="Streams（流）"></a>Streams（流）</h3><p>在 Android 开发中我们经常会用到 RxJava 这类响应式编程方法的框架，其强大之处无须多言，而 Stream 看上去就是在 Dart 语言中的响应式编程的一种实现。</p><ul><li><p>Streams 是什么鬼？</p><p>如果要具体把 Streams 说清楚，一篇文章绝对不够，这里先介绍一下其中的概念，这篇文章目的就是如此。待我后续想好怎么具体描述清楚。</p><p>你可以把它想象成一个管道，有入口（StreamSink）和出口（），我们将想要处理的数据从入口放入经过该管道经过一系列处理（经由 <em>StreamController</em>）从出口中出来，而出口又有一个类似监听器之物，我们不知道它何时到来或者何时处理结束。但是当出口的监听器拿到东西便立即做出相应的反应。</p></li><li><p>那些东西可以放入管道？<br>任何变量、对象、数组、甚至事件都可以被当作数据源从入口放进去。</p></li><li><p>Streams 种类</p><ol><li>Single-subscription Stream，“单订阅”流，这种类型的流只允许在该流的整个生命周期内使用单个侦听器。即使在第一个订阅被取消后，也无法在此类流上收听两次。</li><li>Broadcast Streams，第二种类型的Stream允许任意数量的侦听器。可以随时向广播流添加侦听器。 新的侦听器将在它开始收听 Stream 时收到事件。</li></ol><p>例子：</p></li></ul><p>第一个示例显示了“单订阅”流，只打印输入的数据。 你会发现是哪种数据类型无关紧要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &apos;dart:async&apos;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  //</span><br><span class="line">  // Initialize a &quot;Single-Subscription&quot; Stream controller</span><br><span class="line">  //</span><br><span class="line">  final StreamController ctrl = StreamController();</span><br><span class="line">  </span><br><span class="line">  //</span><br><span class="line">  // Initialize a single listener which simply prints the data</span><br><span class="line">  // as soon as it receives it</span><br><span class="line">  //</span><br><span class="line">  final StreamSubscription subscription = ctrl.stream.listen((data) =&gt; print(&apos;$data&apos;));</span><br><span class="line"></span><br><span class="line">  //</span><br><span class="line">  // We here add the data that will flow inside the stream</span><br><span class="line">  //</span><br><span class="line">  ctrl.sink.add(&apos;my name&apos;);</span><br><span class="line">  ctrl.sink.add(1234);</span><br><span class="line">  ctrl.sink.add(&#123;&apos;a&apos;: &apos;element A&apos;, &apos;b&apos;: &apos;element B&apos;&#125;);</span><br><span class="line">  ctrl.sink.add(123.45);</span><br><span class="line">  </span><br><span class="line">  //</span><br><span class="line">  // We release the StreamController</span><br><span class="line">  //</span><br><span class="line">  ctrl.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个示例显示“广播”流，它传达整数值并仅打印偶数。 我们用 StreamTransformer 来过滤（第14行）值，只让偶数经过。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a "Broadcast" Stream controller of integers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;<span class="built_in">int</span>&gt; ctrl = StreamController&lt;<span class="built_in">int</span>&gt;.broadcast();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a single listener which filters out the odd numbers and</span></span><br><span class="line">  <span class="comment">// only prints the even numbers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamSubscription subscription = ctrl.stream</span><br><span class="line">      .where((value) =&gt; (value % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line">      .listen((value) =&gt; <span class="built_in">print</span>(<span class="string">'$value'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We here add the data that will flow inside the stream</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;<span class="number">11</span>; i++)&#123;</span><br><span class="line">  ctrl.sink.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We release the StreamController</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ctrl.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h3><p>RxDart包是 ReactiveX API 的 Dart 实现，它扩展了原始的 Dart Streams API 以符合 ReactiveX 标准。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/flutterstate2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由于它最初并未由 Google 定义，因此它使用不同于 Dart 的变量。 下表给出了 Dart 和 RxDart 之间的关系。</p><table><thead><tr><th>Dart</th><th>RxDart</th></tr></thead><tbody><tr><td>Stream</td><td>Observable</td></tr><tr><td>StreamController</td><td>Subject</td></tr></tbody></table><p>RxDart 扩展了原始的 Dart Streams API 并提供了 StreamController 的3个主要变体：</p><ol><li><p>PublishSubject</p><p>PublishSubject 是一个普通的 <strong>broadcast</strong> StreamController ，有一点不同：stream 返回一个 Observable 而不是一个 Stream 。</p><p><img src="/images/flutterstate3.png" alt=""></p><p>如您所见，PublishSubject 仅向侦听器发送在订阅之后添加到 Stream 的事件。</p></li><li><p>BehaviorSubject</p><p>BehaviorSubject 也是一个 broadcast StreamController，它返回一个 Observable 而不是一个Stream。</p><p><img src="/images/flutterstate4.png" alt=""></p><p>与 PublishSubject 的主要区别在于 BehaviorSubject 还将最后发送的事件发送给刚刚订阅的侦听器。</p></li><li><p>ReplaySubject</p><p>ReplaySubject 也是一个广播 StreamController，它返回一个 Observable 而不是一个 Stream。(萝莉啰嗦)</p><p><img src="/images/flutterstate5.png" alt=""></p><p>默认情况下，ReplaySubject 将Stream 已经发出的所有事件作为第一个事件发送到任何新的侦听器。</p></li></ol><h3 id="BloC"><a href="#BloC" class="headerlink" title="BloC"></a>BloC</h3><p>BLoC 代表业务逻辑组件 (<strong>B</strong>usiness <strong>Lo</strong>gic <strong>C</strong>omponent)。一般的 Flutter 代码业务逻辑和UI组件糅合在一起，不方便测试，不利于单独的测试业务逻辑部分，不能更好的重用业务逻辑代码，体现在，如果网络请求的逻辑有所变动的话，加入这个业务功能被两个端（web、flutter）使用的话，是需要改动两个地方的。</p><p>简而言之，业务逻辑需要：</p><ul><li>被移植到一个或几个 BLoC 中，</li><li>尽可能从表示层中删除。 也就是说，UI组件应该只关心UI事物而不关心业务，</li><li>依赖 Streams 使用输入（Sink）和输出（<em>stream</em>），</li><li>保持平台独立，</li><li>保持环境独立。</li></ul><p>事实上，BLoC 模式最初的设想是实现允许独立于平台重用相同的代码：Web应用程序，移动应用程序，后端。</p><p>Bloc 的大概就是 Stream 在 Flutter 中的最佳实践：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/flutterstate6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>组件通过 Sinks 向 BLoC 发送事件，</li><li>BLoC 通过 stream 通知组件，</li><li>由 BLoC 实现的业务逻辑。</li></ul><p>将 BloC 应用在计数器应用中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">          bloc: IncrementBloc(),</span><br><span class="line">          child: CounterPage(),</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: bloc.outCounter,</span><br><span class="line">          initialData: <span class="number">0</span>,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          bloc.incrementCounter.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _counterController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  StreamSink&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> _inAdd =&gt; _counterController.sink;</span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> outCounter =&gt; _counterController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the action on the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController _actionController = StreamController();</span><br><span class="line">  StreamSink <span class="keyword">get</span> incrementCounter =&gt; _actionController.sink;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  IncrementBloc()&#123;</span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    _actionController.stream</span><br><span class="line">                     .listen(_handleLogic);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _actionController.close();</span><br><span class="line">    _counterController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleLogic(data)&#123;</span><br><span class="line">    _counter = _counter + <span class="number">1</span>;</span><br><span class="line">    _inAdd.add(_counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你一定在说，卧槽，哇靠～～什么吊玩意，那么就留着悬念吧，今天写不动了！</p><p>Bolc 的具体实现我在样例代码里分两步走放在两个文件夹里！如果需要可以先去看看尝尝鲜。</p><p>这篇文章的目的就是介绍一些概念给大家关于 Streams、RXDart 及 Bloc 详细明了的解释后续更新！</p><h3 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h3><p><a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">https://github.com/MeandNi/Flutter_StatePro</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.youtube.com/watch?v=RS36gBEp8OI&amp;index=115&amp;list=PLOU2XLYxmsIInFRc3M44HUTQc3b_YJ4-Y" target="_blank" rel="noopener">Build reactive mobile apps with Flutter (Google I/O ‘18)</a></p><p><a href="https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/" target="_blank" rel="noopener">Reactive Programming - Streams - BLoC</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用 Flutter 内置的许多控件我们可以打造出一款不仅漂亮而且完美跨平台的 App 外壳，我利用其特性完成了类似&lt;a href=&quot;https://github.com/MeandNi/Flutter_ZhiHu&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="技术" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Flutter知乎App实践：UI+Json+Utils</title>
    <link href="https://meandni.com/2019/01/29/flutter-zhihu/"/>
    <id>https://meandni.com/2019/01/29/flutter-zhihu/</id>
    <published>2019-01-29T07:17:22.000Z</published>
    <updated>2019-04-12T06:05:05.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter实践之知乎App"><a href="#Flutter实践之知乎App" class="headerlink" title="Flutter实践之知乎App"></a>Flutter实践之知乎App</h2><p>预览图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/showapp.jpg" alt="app展示" title="">                </div>                <div class="image-caption">app展示</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/showapp2.jpg" alt="app展示" title="">                </div>                <div class="image-caption">app展示</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/showgif.gif" alt="app展示" title="">                </div>                <div class="image-caption">app展示</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/showgif2.gif" alt="app展示" title="">                </div>                <div class="image-caption">app展示</div>            </figure><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flutter 1.0.0 • channel stable • https://github.com/flutter/flutter.git</span><br><span class="line">Framework • revision 5391447fae (9 weeks ago) • 2018-11-29 19:41:26 -0800</span><br><span class="line">Engine • revision 7375a0f414</span><br><span class="line">Tools • Dart 2.1.0 (build 2.1.0-dev.9.4 f9ebf21297)</span><br></pre></td></tr></table></figure><h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><ol><li><p>克隆代码</p><p>源码地址：<a href="https://github.com/MeandNi/Flutter_ZhiHu" target="_blank" rel="noopener">https://github.com/MeandNi/Flutter_ZhiHu</a></p></li><li><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br></pre></td></tr></table></figure></li></ol><h4 id="UI-大致结构"><a href="#UI-大致结构" class="headerlink" title="UI 大致结构"></a>UI 大致结构</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/common.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>采用类似 Android 模块化思想，将整个 App 的内容分为5个部分.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/common2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="Ui-细节"><a href="#Ui-细节" class="headerlink" title="Ui 细节"></a>Ui 细节</h4><p>暂不叙述，项目目前还在更新完善中，预计使用Redux、Sqlflite等技术栈填充数据部分，本项目部分界面及工具类来自<a href="https://github.com/MeandNi/Flutter_CommonApp" target="_blank" rel="noopener">Flutter_CommonApp</a> 。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/recommend.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/idea.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/question.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>结构图壕无专业性可言，仅供观赏😀。</p><h4 id="第三方框架"><a href="#第三方框架" class="headerlink" title="第三方框架"></a>第三方框架</h4><table><thead><tr><th>库</th><th>功能</th></tr></thead><tbody><tr><td><strong>dio</strong></td><td><strong>网络框架</strong></td></tr><tr><td><strong>carousel_slider</strong></td><td><strong>轮播图</strong></td></tr><tr><td><strong>cached_network_image</strong></td><td><strong>图片加载</strong></td></tr><tr><td><strong>share</strong></td><td><strong>链接分享</strong></td></tr><tr><td><strong>flutter_webview_plugin</strong></td><td><strong>WebView</strong></td></tr></tbody></table><h4 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h4><p>感谢那些热爱开源、一起奋斗的朋友们。</p><p>值得学习请Star啊^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Flutter实践之知乎App&quot;&gt;&lt;a href=&quot;#Flutter实践之知乎App&quot; class=&quot;headerlink&quot; title=&quot;Flutter实践之知乎App&quot;&gt;&lt;/a&gt;Flutter实践之知乎App&lt;/h2&gt;&lt;p&gt;预览图：&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="技术" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Flutter进阶：在应用中实现 Hero(飞行) 动画</title>
    <link href="https://meandni.com/2019/01/27/flutter-hero/"/>
    <id>https://meandni.com/2019/01/27/flutter-hero/</id>
    <published>2019-01-27T12:12:07.000Z</published>
    <updated>2019-04-12T06:05:09.030Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/hero.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><table><thead><tr><th>标题</th><th>链接</th></tr></thead><tbody><tr><td>Flutter进阶：深入探究 ListView 和 ScrollPhysics</td><td><a href="https://juejin.im/post/5c4c202df265da615064ce4b" target="_blank" rel="noopener">https://juejin.im/post/5c4c202df265da615064ce4b</a></td></tr><tr><td>Flutter进阶：深入探究 TextField</td><td><a href="https://juejin.im/post/5c4c4e22f265da6174652fb4" target="_blank" rel="noopener">https://juejin.im/post/5c4c4e22f265da6174652fb4</a></td></tr></tbody></table><h2 id="hero-动画介绍"><a href="#hero-动画介绍" class="headerlink" title="hero 动画介绍"></a>hero 动画介绍</h2><p>Hero 指的是可以在路由(页面)之间“飞行”的 widget，从一个页面打开另一个页面时产生一个简单的过渡动画，看下图实例：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/hero1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><center><img width="384px" height="640" src="/images/hero2.gif"></center><p>Hero Animations 采用类似图标的 widget ，称为“hero”，一旦触发页面过渡，例如通过单击图标，hero 将会“飞”到下一页。 当用户导航回到上一页面时，也将实现原路返回的动画。</p><p>更多介绍，请看<a href="https://flutter.io/docs/development/ui/animations/hero-animations" target="_blank" rel="noopener">官网</a>。</p><p>这里我们不仅学习如何使用 hero 动画，也将会自定义一些我们自己实现的动画。</p><h2 id="构建一个普通的-hero-动画"><a href="#构建一个普通的-hero-动画" class="headerlink" title="构建一个普通的 hero 动画"></a>构建一个普通的 hero 动画</h2><p>hero 动画允许我们在 Flutter 中用最简单的方式实现漂亮动画，无需太多设置。 在上面的例子中，我们可以看到两个页面上都存在相同的图标或者图片。 我们需要做的只是 <strong>让这两者以某种方式相关联</strong>。</p><p>要实现它，我们可以通过在 Hero 组件中包含图标之类的组件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">  child: Icon(</span><br><span class="line">    Icons.add,</span><br><span class="line">    size: <span class="number">70.0</span>,</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>我们需要设置了一个 tag 参数，给这个  hero 一个独立的名字（类比 Android 中的 ID），因为如果我们在同一页面上有多个 hero ，每个 hero 都需要知道它们将飞往何处且在各不相同的地方。</p><p>现在应用程序有一个 hero 组件想要飞到下一页。接下来就是要告诉它将要飞向何处。</p><p>我们仅需要在第二页上添加带有相同标签的Hero小部件就可实现这个效果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">  child: Icon(</span><br><span class="line">    Icons.add,</span><br><span class="line">    size: <span class="number">150.0</span>,</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>实例如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/hero3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="自定义-hero-动画"><a href="#自定义-hero-动画" class="headerlink" title="自定义 hero 动画"></a>自定义 hero 动画</h2><p>Hero 组件允许我们自定义各种过渡效果。 有以下几种方法。</p><h3 id="添加占位符"><a href="#添加占位符" class="headerlink" title="添加占位符"></a>添加占位符</h3><p>在组件飞离它曾经处于的位置并且到达目标位置之前，目标处有一处空的地方。 我们可以在此位置添加<strong>占位符</strong>。</p><p>我们现在使用 CircularProgressIndicator 作为占位符。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Hero(</span><br><span class="line">    tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">    child: Icon(</span><br><span class="line">      Icons.add,</span><br><span class="line">      size: <span class="number">150.0</span>,</span><br><span class="line">    ),</span><br><span class="line">    placeholderBuilder: (context, widget) &#123;</span><br><span class="line">      <span class="keyword">return</span> Container(</span><br><span class="line">        height: <span class="number">150.0</span>,</span><br><span class="line">        width: <span class="number">150.0</span>,</span><br><span class="line">        child: CircularProgressIndicator(),</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure><p>我们使用 placeholderBuilder 来构造占位符并返回我们希望作为占位符的组件。</p><p>使用占位符：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/hero4.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="更改-hero-组件"><a href="#更改-hero-组件" class="headerlink" title="更改 hero 组件"></a>更改 hero 组件</h3><p>Flutter 允许我们更改从一个页面飞到另一个页面过程的组件，而无需更改两个页面上的组件。</p><p>让我们<strong>在不更改 hero 组件的子组件的前提下</strong>，使用火箭图标“飞”而不是 “+” 图标 。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/hero5.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们使用 <strong>flightShuttleBuilder</strong> 参数执行此操作。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">  child: Icon(</span><br><span class="line">    Icons.add,</span><br><span class="line">    size: <span class="number">150.0</span>,</span><br><span class="line">  ),</span><br><span class="line">  flightShuttleBuilder: (flightContext, animation, direction,</span><br><span class="line">      fromContext, toContext) &#123;</span><br><span class="line">    <span class="keyword">return</span> Icon(FontAwesomeIcons.rocket, size: <span class="number">150.0</span>,);</span><br><span class="line">  &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>flightShuttleBuilder 有5个参数，用来设置动画以及动画的方向。</p><p>目前，两个方向的火箭图标大小都保持在 150.0 。 通过使用方法的 direction 参数，我们可以为每个方向配置不同的配置。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(direction == HeroFlightDirection.push) &#123;</span><br><span class="line">  <span class="keyword">return</span> Icon(</span><br><span class="line">    FontAwesomeIcons.rocket,</span><br><span class="line">    size: <span class="number">150.0</span>,</span><br><span class="line">  );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == HeroFlightDirection.pop)&#123;</span><br><span class="line">  <span class="keyword">return</span> Icon(</span><br><span class="line">    FontAwesomeIcons.rocket,</span><br><span class="line">    size: <span class="number">70.0</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/hero6.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="使-hero-动画可以支持-iOS-返回滑动手势"><a href="#使-hero-动画可以支持-iOS-返回滑动手势" class="headerlink" title="使 hero 动画可以支持 iOS 返回滑动手势"></a>使 hero 动画可以支持 iOS 返回滑动手势</h3><p>默认情况下，当在 iOS 上按后退按钮时，hero 动画会有效果，但它们在手势滑动时并没有。</p><p><strong>使用返回按钮：</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/hero7.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>使用滑动手势</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/hero8.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要解决此问题，只需在两个 Hero 组件上将 transitionOnUserGestures 设置为 true 即可。 默认情况下这里是 false。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">  child: Icon(</span><br><span class="line">    Icons.add,</span><br><span class="line">  ),</span><br><span class="line">  transitionOnUserGestures: <span class="keyword">true</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/hero9.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>利用时间整理分析自己所学的知识是件非常有意义的事情，希望这也能帮到其他正在学习的同学。同时我也正在用Flutter写几个项目，写好之后就会开源给大家。</p><p>Github：<a href="https://github.com/MeandNi" target="_blank" rel="noopener">https://github.com/MeandNi</a></p><p>欢迎一起交流移动开发的技术！</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://flutter.io/docs/development/ui/animations/hero-animations" target="_blank" rel="noopener">https://flutter.io/docs/development/ui/animations/hero-animations</a></p><p><a href="https://medium.com/flutter-community/a-deep-dive-into-hero-widgets-in-flutter-d34f441eb026" target="_blank" rel="noopener">https://medium.com/flutter-community/a-deep-dive-into-hero-widgets-in-flutter-d34f441eb026</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="技术" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Flutter进阶：深入探究 TextField</title>
    <link href="https://meandni.com/2019/01/26/flutter-exploring-textfield/"/>
    <id>https://meandni.com/2019/01/26/flutter-exploring-textfield/</id>
    <published>2019-01-26T07:34:32.000Z</published>
    <updated>2019-04-12T06:05:12.466Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="TextField-介绍"><a href="#TextField-介绍" class="headerlink" title="TextField 介绍"></a>TextField 介绍</h2><p>TextField 组件可以让用户填写信息。 TextField 的代码非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextField()</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="从TextField中检索信息"><a href="#从TextField中检索信息" class="headerlink" title="从TextField中检索信息"></a>从TextField中检索信息</h2><p>由于 TextFields 组件没有像 Android 中那样的 ID，因此无法根据需要检索文本，而必须在更改时将其存储在变量中或使用控制器。</p><ol><li><p>最简单的方法是使用 onChanged 方法并将当前值存储在一个变量中。示例代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> value = <span class="string">""</span>;</span><br><span class="line">TextField(</span><br><span class="line">  onChanged: (text) &#123;</span><br><span class="line">    value = text;</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>第二种方法是使用 TextEditingController 。 控制器连接到 TextField ，让我们也可以监听和控制 TextField 的内容。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TextEditingController controller = TextEditingController();</span><br><span class="line">TextField(</span><br><span class="line">  controller: controller,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们可以这样监听变化</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">controller.addListener(() &#123;</span><br><span class="line">  <span class="comment">// Do something here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>获取、设置文本内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(controller.text); <span class="comment">// Print current value</span></span><br><span class="line">controller.text = <span class="string">"Demo Text"</span>; <span class="comment">// Set new value</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="TextField-中其他的回调"><a href="#TextField-中其他的回调" class="headerlink" title="TextField 中其他的回调"></a>TextField 中其他的回调</h2><p>TextField 组件还提供其他回调，例如：</p><ol><li>onEditingCompleted</li><li>onSubmitted</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onEditingComplete: () &#123;&#125;,</span><br><span class="line">onSubmitted: (value) &#123;&#125;,</span><br></pre></td></tr></table></figure><p>这些是在用户单击 iOS 上的“完成”按钮时调用的回调。</p><h2 id="在-TextField-中使用焦点"><a href="#在-TextField-中使用焦点" class="headerlink" title="在 TextField 中使用焦点"></a>在 TextField 中使用焦点</h2><p>在 TextField 上“聚焦”意味着激活 TextField ，键盘的任何输入都将导致在聚焦的 TextField 中输入数据。</p><h3 id="1-使其自动聚焦"><a href="#1-使其自动聚焦" class="headerlink" title="1. 使其自动聚焦"></a>1. 使其自动聚焦</h3><p>要在创建窗口时在 TextField 上自动对焦，请将自动对焦字段设置为 true 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  autofocus: <span class="keyword">true</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>默认情况下，这会将焦点设置在 TextField 上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield2.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-自定义更改焦点"><a href="#2-自定义更改焦点" class="headerlink" title="2.自定义更改焦点"></a>2.自定义更改焦点</h3><p>如果我们想要改变焦点而不仅仅是自动对焦怎么办？ 看下面代码 ，我们将 FocusNode 附加到 TextField 并使用它来切换焦点。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialise outside the build method</span></span><br><span class="line">FocusNode nodeOne = FocusNode();</span><br><span class="line">FocusNode nodeTwo = FocusNode();</span><br><span class="line"><span class="comment">// Do this inside the build method</span></span><br><span class="line">TextField(</span><br><span class="line">  focusNode: nodeOne,</span><br><span class="line">),</span><br><span class="line">TextField(</span><br><span class="line">  focusNode: nodeTwo,</span><br><span class="line">),</span><br><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    FocusScope.of(context).requestFocus(nodeTwo);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">"Next Field"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>我们创建两个焦点节点并将它们附加到 TextFields 。 按下按钮时，我们使用 FocusScope 请求焦点到下一个TextField。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="更改-TextFields-的键盘属性"><a href="#更改-TextFields-的键盘属性" class="headerlink" title="更改 TextFields 的键盘属性"></a>更改 TextFields 的键盘属性</h2><p>Flutter 中的 TextField 允许我们自定义与键盘相关的属性。</p><h3 id="1-键盘类型"><a href="#1-键盘类型" class="headerlink" title="1.键盘类型"></a>1.键盘类型</h3><p>TextField 允许您自定义在 TextField 成为焦点时显示的键盘类型。 我们更改 keyboardType 属性。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  keyboardType: TextInputType.number,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>类型有：</p><ol><li><strong>TextInputType.text</strong> (普通全键盘)</li><li><strong>TextInputType.number</strong> (数字键盘)</li><li><strong>TextInputType.emailAddress</strong> (普通键盘，带有“@”符号)</li><li><strong>TextInputType.datetime</strong> (数字键盘，带有 “/” 和  “:” 符号)</li><li><strong>TextInputType.multiline</strong> (数字键盘，带有启用有符号和十进制模式的选项)</li></ol><h3 id="2-TextInputAction"><a href="#2-TextInputAction" class="headerlink" title="2.TextInputAction"></a>2.TextInputAction</h3><p>更改 TextField 的 textInputAction 可以更改键盘本身的操作按钮。</p><p>例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textInputAction: TextInputAction.continueAction,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>这会导致 “Done” 按钮被 “Continue” 按钮替换：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>或者：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textInputAction: TextInputAction.send,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>还有很多类型，这里不一一列举。</p><h3 id="3-自动更正"><a href="#3-自动更正" class="headerlink" title="3.自动更正"></a>3.自动更正</h3><p>启用或禁用特定 TextField 的自动更正。 使用自动更正字段进行如下设置。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  autocorrect: <span class="keyword">false</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>这将禁用更正。</p><h3 id="4-文本大写"><a href="#4-文本大写" class="headerlink" title="4.文本大写"></a>4.文本大写</h3><p>TextField 提供了一些有关如何使用户输入中的字母大写的选项。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textCapitalization: TextCapitalization.sentences,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>选项有：</p><ol><li><p><strong>TextCapitalization.sentences</strong></p><p>这可以使每个句子的首字母大写。</p><p><img src="/images/textfield6.png" alt=""></p></li><li><p><strong>TextCapitalization.characters</strong></p><p>大写句子中的所有字符。</p><p><img src="/images/textfield7.png" alt=""></p></li><li><p><strong>TextCapitalization.words</strong></p><p>大写每个单词的首字母。</p><p><img src="/images/textfield8.png" alt=""></p><h2 id="Text-Style-Alignment-和-Cursor"><a href="#Text-Style-Alignment-和-Cursor" class="headerlink" title="Text Style, Alignment 和 Cursor"></a>Text Style, Alignment 和 Cursor</h2></li></ol><p>Flutter 允许自定义 TextField 内的文本样式和对齐方式以及 TextField 内的光标。</p><h3 id="TextField-内的文本对齐方式"><a href="#TextField-内的文本对齐方式" class="headerlink" title="TextField 内的文本对齐方式"></a>TextField 内的文本对齐方式</h3><p>使用 textAlign 属性调整 TextField 中光标的位置。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textAlign: TextAlign.center,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield9.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通常的对齐属性有：<strong>start, end, left, right, center, justify</strong>.</p><h3 id="在-TextField-中设置文本样式"><a href="#在-TextField-中设置文本样式" class="headerlink" title="在 TextField 中设置文本样式"></a>在 TextField 中设置文本样式</h3><p>我们使用 style 属性来更改 TextField 内部文本的样式。 使用它来更改颜色，字体大小等。这类似于文本组件中的样式属性，这里我们不多做介绍。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  style: TextStyle(color: Colors.red, fontWeight: FontWeight.w300),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield10.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="更改-TextField-中的光标"><a href="#更改-TextField-中的光标" class="headerlink" title="更改 TextField 中的光标"></a>更改 TextField 中的光标</h3><p>可以直接自定义 TextField 组件的光标。</p><p>您可以更改光标颜色，宽度和半径。 例如，在这里我自定义了一个圆形红色光标。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  cursorColor: Colors.red,</span><br><span class="line">  cursorRadius: Radius.circular(<span class="number">16.0</span>),</span><br><span class="line">  cursorWidth: <span class="number">16.0</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield11.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="控制-TextField-中的大小和最大长度"><a href="#控制-TextField-中的大小和最大长度" class="headerlink" title="控制 TextField 中的大小和最大长度"></a>控制 TextField 中的大小和最大长度</h3><p>TextFields 可以控制其中写入的最大字符数、最大行数并在键入文本时展开。</p><h4 id="控制最大字符数"><a href="#控制最大字符数" class="headerlink" title="控制最大字符数"></a>控制最大字符数</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  maxLength: <span class="number">4</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield12.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>通过设置 maxLength 属性，将强制执行最大长度，并且默认情况下会将计数器添加到 TextField 。</p><h4 id="制作可扩展的TextField"><a href="#制作可扩展的TextField" class="headerlink" title="制作可扩展的TextField"></a>制作可扩展的TextField</h4><p>有时，我们需要 TextField 当一行完成时会扩展。 在Flutter中，做法有点奇怪（但很容易）。 我们将 maxLines 设置为 null ，默认为1。 </p><p><img src="/images/textfield13.png" alt=""></p><p><strong>注意：默认情况下，将 maxLines 设置为直接值会将其自动扩展为该行数。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  maxLines: <span class="number">3</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield14.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="模糊文字"><a href="#模糊文字" class="headerlink" title="模糊文字"></a>模糊文字</h4><p>要隐藏 TextField 中的文本，请将 obscureText 设置为true 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  obscureText: <span class="keyword">true</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield15.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="装饰-TextField"><a href="#装饰-TextField" class="headerlink" title="装饰 TextField"></a>装饰 TextField</h2><p>至此，我们专注于 Flutter 提供的输入功能。 现在我们来实际设计一个漂亮的 TextField 。</p><p>为了装饰 TextField，我们使用了带有 InputDecoration 的 decoration 属性。 由于 InputDecoration 类非常庞大，我们快速过一遍它的重要属性。</p><h3 id="使用提示和标签属性向用户提供信息"><a href="#使用提示和标签属性向用户提供信息" class="headerlink" title="使用提示和标签属性向用户提供信息"></a>使用提示和标签属性向用户提供信息</h3><p>提示和标签都是字符串，可帮助用户理解要在 TextField 中输入的信息。 不同之处在于，当标签浮动在 TextField上时，一旦用户开始输入，提示就会消失。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield16.png" alt="Hint" title="">                </div>                <div class="image-caption">Hint</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield17.png" alt="Label" title="">                </div>                <div class="image-caption">Label</div>            </figure><h3 id="您可以使用-“icon”，“prefixIcon”-和-“suffixIcon”-添加图标"><a href="#您可以使用-“icon”，“prefixIcon”-和-“suffixIcon”-添加图标" class="headerlink" title="您可以使用 “icon”，“prefixIcon” 和 “suffixIcon” 添加图标"></a>您可以使用 “icon”，“prefixIcon” 和 “suffixIcon” 添加图标</h3><p>您可以直接向 TextFields 添加图标。 您也可以使用 prefixText 和 suffixText 代替 Text。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    icon: Icon(Icons.<span class="built_in">print</span>)</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield18.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    prefixIcon: Icon(Icons.<span class="built_in">print</span>)</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield19.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="对于其他任何组件，使用-“prefix”-而不是-“prefixIcon”"><a href="#对于其他任何组件，使用-“prefix”-而不是-“prefixIcon”" class="headerlink" title="对于其他任何组件，使用 “prefix” 而不是 “prefixIcon”"></a>对于其他任何组件，使用 “prefix” 而不是 “prefixIcon”</h3><p>要使用通用组件而不是仅仅一个图标，请使用 prefix field 。让我们在 TextField 中添加一个圆形进度框。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    prefix: CircularProgressIndicator(),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield20.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="像-hint-，label-等每个属性都有各自的样式字段"><a href="#像-hint-，label-等每个属性都有各自的样式字段" class="headerlink" title="像 hint ，label 等每个属性都有各自的样式字段"></a>像 <strong>hint</strong> ，<strong>label</strong> 等每个属性都有各自的样式字段</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    hintText: <span class="string">"Demo Text"</span>,</span><br><span class="line">    hintStyle: TextStyle(fontWeight: FontWeight.w300, color: Colors.red)</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><strong>注意：虽然我在此示例中这样操作，但通常不会更改提示颜色。</strong></p><h3 id="如果您不想要标签而想要为用户提供持久消息，请使用-“helperText”-。"><a href="#如果您不想要标签而想要为用户提供持久消息，请使用-“helperText”-。" class="headerlink" title="如果您不想要标签而想要为用户提供持久消息，请使用 “helperText” 。"></a>如果您不想要标签而想要为用户提供持久消息，请使用 “helperText” 。</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    helperText: <span class="string">"Hello"</span></span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield21.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="使用-“decoration：null”-或-InputDecoration-collapsed-删除-TextField-上的默认下划线"><a href="#使用-“decoration：null”-或-InputDecoration-collapsed-删除-TextField-上的默认下划线" class="headerlink" title="使用 “decoration：null” 或 InputDecoration.collapsed 删除 TextField 上的默认下划线"></a>使用 “decoration：null” 或 InputDecoration.collapsed 删除 TextField 上的默认下划线</h3><p>使用这些删除 TextField 上的默认下划线。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration.collapsed(hintText: <span class="string">""</span>)</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield22.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="使用-“border”-为-TextField-设置边框"><a href="#使用-“border”-为-TextField-设置边框" class="headerlink" title="使用 “border” 为 TextField 设置边框"></a>使用 “border” 为 TextField 设置边框</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    border: OutlineInputBorder()</span><br><span class="line">  )</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/textfield23.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>您可以进一步做大量的装饰，我不可能将所有你需要的样式做出来。 但我希望这我已经让你知道怎么将它做出来！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="技术" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Flutter进阶：深入探究 ListView 和 ScrollPhysics</title>
    <link href="https://meandni.com/2019/01/26/flutter-exploring-list/"/>
    <id>https://meandni.com/2019/01/26/flutter-exploring-list/</id>
    <published>2019-01-26T06:19:55.000Z</published>
    <updated>2019-04-12T06:05:16.286Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/listview.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Flutter 中的 ListView 可以对比 Android 中的 ListView 或者 RecycleView（当然也有不同之处） ，是可滚动项的线性列表。 我们可以用它来制作可滚动项目列表或重复项目列表。</p><h2 id="探究各类型的-ListView"><a href="#探究各类型的-ListView" class="headerlink" title="探究各类型的 ListView"></a>探究各类型的 ListView</h2><p>构建 ListView 有以下几种方式：</p><ol><li><strong>ListView</strong></li><li><strong>ListView.builder</strong></li><li><strong>ListView.separated</strong></li><li><strong>ListView.custom</strong></li></ol><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><p>这是 ListView 类的默认构造函数。 ListView 内有任意个数的子元素都可使其滚动。</p><p>代码的格式为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    ItemOne(),</span><br><span class="line">    ItemTwo(),</span><br><span class="line">    ItemThree(),</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>通常这里应该放少量的子元素，因为 ListView 也会将当前不可见的元素构建起来，因此大量的子元素可能使 App 性能降低。</p><h3 id="ListView-builder"><a href="#ListView-builder" class="headerlink" title="ListView.builder()"></a>ListView.builder()</h3><p>builder() 构造函数可以用来构造重复的子项列表，这里我们就可以类比 Android 中的 ListView 。 这个构造函数有两个主要参数：列表中项目数的 itemCount 和构造每个列表子项的 itemBuilder。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/listview2.gif" alt="/images/listview2.gif" title="">                </div>                <div class="image-caption">/images/listview2.gif</div>            </figure><p>代码的格式为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">  itemCount: itemCount,</span><br><span class="line">  itemBuilder: (context, position) &#123;</span><br><span class="line">    <span class="keyword">return</span> listItem();</span><br><span class="line">  &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>列表项是<strong>懒加载</strong>的，这表明 Flutter 只构造了特定数量的列表项，当用户滚动时，早期的列表项被销毁。</p><p><strong>技巧</strong>：由于元素是懒加载的，只加载了所需数量的元素，我们并不需要将 itemCount 作为必需参数，列表可以是<strong>无限长</strong>的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ListView.builder(</span><br><span class="line">  itemBuilder: (context, position) &#123;</span><br><span class="line">    <span class="keyword">return</span> Card(</span><br><span class="line">      child: Padding(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">        child: Text(position.toString(), style: TextStyle(fontSize: <span class="number">22.0</span>),),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/listview3.gif" alt="/images/listview3.gif" title="">                </div>                <div class="image-caption">/images/listview3.gif</div>            </figure><h3 id="ListView-separated"><a href="#ListView-separated" class="headerlink" title="ListView.separated()"></a>ListView.separated()</h3><p>在 separate() 的构造函数中，我们同样生成一个列表，但这里我们可以指定每个项之间的分隔符。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/listview4.gif" alt="/images/listview4.gif" title="">                </div>                <div class="image-caption">/images/listview4.gif</div>            </figure><p>实质上，这里，<strong>我们构造了两个交织列表</strong>：一个作为主列表，一个作为分隔符列表。</p><p>要注意的是，这里不能应用前面构造函数中所说的无限长度，因为此构造函数会强制执行 itemCount 。</p><p>代码的格式为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListView.separated(</span><br><span class="line">      itemBuilder: (context, position) &#123;</span><br><span class="line">        <span class="keyword">return</span> ListItem();</span><br><span class="line">      &#125;,</span><br><span class="line">      separatorBuilder: (context, position) &#123;</span><br><span class="line">        <span class="keyword">return</span> SeparatorItem();</span><br><span class="line">      &#125;,</span><br><span class="line">      itemCount: itemCount,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>这种类型的列表允许您动态定义分隔符，为不同类型的子项分配不同类型的分隔符，在需要时添加或删除分隔符等。</p><p>该实现还可以在列表中方便地插入其他类型的子元素（例如广告），而不需要对列表项中的主列表进行任何修改。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/listview5.png" alt="/images/listview5.png" title="">                </div>                <div class="image-caption">/images/listview5.png</div>            </figure><p><strong>注意：</strong>通常分隔符列表长度比项目列表小 1，因为在最后一个元素之后不存在分隔符。</p><h3 id="ListView-custom"><a href="#ListView-custom" class="headerlink" title="ListView.custom()"></a>ListView.custom()</h3><p>正如其名，custom() 构造函数允许我们自定义构建 ListViews。 需要的主要参数是 SliverChildDelegate ，用于构建子项。 SliverChildDelegates 的类型是：</p><ol><li><strong>verChildListDelegate</strong></li><li><strong>SliverChildBuilderDelegate</strong></li></ol><p>SliverChildListDelegate 接受一个子项的直接列表，而 SliverChildBuiderDelegate 接受 IndexedWidgetBuilder（我们使用的构造函数）。</p><p><strong>您可以使用或子类化这些来构建自己的委托。</strong></p><p><strong>ListView 默认构造函数的行为类似于带有 SliverChildListDelegate 的 ListView.custom 。</strong></p><p>我们已经介绍完了 ListViews 的各种类型，让我们来看看 ScrollPhysics 。</p><h2 id="探究-ScrollPhysics"><a href="#探究-ScrollPhysics" class="headerlink" title="探究 ScrollPhysics"></a>探究 ScrollPhysics</h2><p>为了控制列表滚动的发生方式，我们在 ListView 的构造函数中通常需要设置 physics 参数。 各种类型的 physics 参数有：</p><h3 id="NeverScrollablePhysics"><a href="#NeverScrollablePhysics" class="headerlink" title="NeverScrollablePhysics"></a>NeverScrollablePhysics</h3><p>NeverScrollablePhysics 表现为不可滚动的列表。 使用此选项可以完全禁用 ListView 的滚动。</p><h3 id="BouncingScrollPhysics"><a href="#BouncingScrollPhysics" class="headerlink" title="BouncingScrollPhysics"></a>BouncingScrollPhysics</h3><p>BouncingScrollPhysics 在列表结束时<strong>退回</strong>列表。 iOS 中有类似的效果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/listview6.gif" alt="/images/listview6.gif" title="">                </div>                <div class="image-caption">/images/listview6.gif</div>            </figure><h3 id="ClampingScrollPhysics"><a href="#ClampingScrollPhysics" class="headerlink" title="ClampingScrollPhysics"></a>ClampingScrollPhysics</h3><p>这是 Android 上使用的默认滚动方式。 列表在结尾处停止并给出一定的效果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/listview7.gif" alt="/images/listview7.gif" title="">                </div>                <div class="image-caption">/images/listview7.gif</div>            </figure><h3 id="FixedExtentScrollPhysics"><a href="#FixedExtentScrollPhysics" class="headerlink" title="FixedExtentScrollPhysics"></a>FixedExtentScrollPhysics</h3><p>该方法与其他方法略有不同，因为它仅适用于 FixedExtendScrollControllers 和使用它们的列表。 举个例子，我们用 ListWheelScrollView 来制作类似轮子的列表。</p><p>FixedExtentScrollPhysics 仅滚动到子项而不存在任何偏移。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/listview8.gif" alt="/images/listview8.gif" title="">                </div>                <div class="image-caption">/images/listview8.gif</div>            </figure><p>样例代码非常简单：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FixedExtentScrollController fixedExtentScrollController =</span><br><span class="line">    <span class="keyword">new</span> FixedExtentScrollController();</span><br><span class="line">ListWheelScrollView(</span><br><span class="line">  controller: fixedExtentScrollController,</span><br><span class="line">  physics: FixedExtentScrollPhysics(),</span><br><span class="line">  children: monthsOfTheYear.map((month) &#123;</span><br><span class="line">    <span class="keyword">return</span> Card(</span><br><span class="line">        child: Row(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Expanded(</span><br><span class="line">            child: Padding(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">          child: Text(</span><br><span class="line">            month,</span><br><span class="line">            style: TextStyle(fontSize: <span class="number">18.0</span>),</span><br><span class="line">          ),</span><br><span class="line">        )),</span><br><span class="line">      ],</span><br><span class="line">    ));</span><br><span class="line">  &#125;).toList(),</span><br><span class="line">  itemExtent: <span class="number">60.0</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="你应当知道的其他事情"><a href="#你应当知道的其他事情" class="headerlink" title="你应当知道的其他事情"></a>你应当知道的其他事情</h2><h3 id="如何在列表中保留被破坏的元素？"><a href="#如何在列表中保留被破坏的元素？" class="headerlink" title="如何在列表中保留被破坏的元素？"></a>如何在列表中保留被破坏的元素？</h3><p>Flutter 提供了一个 KeepAlive() 小组件，它可以使子元素保持活跃状态，否则会被破坏。 在列表中，默认情况下，元素包装在 AutomaticKeepAlive 中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/listview9.png" alt="/images/listview9.png" title="">                </div>                <div class="image-caption">/images/listview9.png</div>            </figure><h3 id="为什么我的-ListView-在列表和外部小部件之间有空格？"><a href="#为什么我的-ListView-在列表和外部小部件之间有空格？" class="headerlink" title="为什么我的 ListView 在列表和外部小部件之间有空格？"></a>为什么我的 ListView 在列表和外部小部件之间有空格？</h3><p>ListView 在它与外部窗口组件之间有默认填充，将填充设置为 EdgeInsets.all(0.0) 就可以删除它。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>利用时间整理分析自己所学的知识是件非常有意义的事情，希望这也能帮到其他正在学习的同学。同时我也正在用Flutter写几个项目，写好之后就会开源给大家。</p><p>Github：<a href="https://github.com/MeandNi" target="_blank" rel="noopener">https://github.com/MeandNi</a></p><p>微信：yangjk128</p><p>原文博客：<a href="https://meandni.com/2019/01/26/1be6/">https://meandni.com/2019/01/26/1be6/</a></p><p>欢迎一起交流移动开发的技术！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="技术" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2019第一次阅读记录</title>
    <link href="https://meandni.com/2019/01/18/reading-record1/"/>
    <id>https://meandni.com/2019/01/18/reading-record1/</id>
    <published>2019-01-18T06:53:59.000Z</published>
    <updated>2019-04-16T14:15:54.554Z</updated>
    
    <content type="html"><![CDATA[<h4 id="已读"><a href="#已读" class="headerlink" title="已读"></a>已读</h4><p><a href="http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html" target="_blank" rel="noopener">《Node 定时器详解》</a></p><p><a href="https://juejin.im/post/5c408f40e51d455222642b1c" target="_blank" rel="noopener">一位年度作者的年度总结 | 掘金年度征文</a></p><p><a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">前端常见跨域解决方案（全）</a> ？</p><p><a href="https://juejin.im/post/5aad40e4f265da237f1e12ed" target="_blank" rel="noopener">前端笔试题面试题记录（上）| 掘金技术征文</a></p><p><a href="https://github.com/KieSun/Blog/issues/2" target="_blank" rel="noopener">深度解析原型中的各个难点</a></p><hr><p><a href="https://juejin.im/post/5c0dbe7ee51d451dac076e6c" target="_blank" rel="noopener">Android MVVM组件化架构方案</a></p><p><a href="https://juejin.im/post/5c404cca5188251e10159d09" target="_blank" rel="noopener">基于源码分析 Android View 事件分发机制</a></p><p><a href="https://juejin.im/post/5bdfaed0e51d4505086fa4cd" target="_blank" rel="noopener">回到最初：开发不需要“编译” 的 WebApp</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/01/weekly-issue-40.html" target="_blank" rel="noopener">每周分享第 40 期</a></p><p><a href="https://www.cnblogs.com/xueweihan/p/5220513.html" target="_blank" rel="noopener">什么是真正的程序员</a></p><p><a href="https://hellogithub.com/periodical/volume/32/" target="_blank" rel="noopener">分享 GitHub 上 有趣、入门级的开源项目</a></p><hr><p><a href="https://juejin.im/post/5b2b4c36f265da59b243cac9" target="_blank" rel="noopener">flutter-dart 类的构造函数</a></p><p><a href="https://juejin.im/post/5c453f97f265da61776c3fed" target="_blank" rel="noopener">2018年值得熬夜看完的书</a></p><p><a href="https://juejin.im/post/5c2c31d3f265da61553aee34" target="_blank" rel="noopener">Android绘制函数图象及正弦函数的介绍</a></p><p><a href="https://juejin.im/post/5c2dd2f75188250fa8362647" target="_blank" rel="noopener">Android多媒体之认识声音、录音与播放(PCM)</a></p><p><a href="https://www.jianshu.com/p/c0e30769ea7e" target="_blank" rel="noopener">Flutter进阶篇（4）– Flutter的Future异步详解</a></p><p><a href="https://juejin.im/post/5b431bff5188251b166ee0c1" target="_blank" rel="noopener">教你如何用 Flutter 的 GestureDetector 构建自定义滑块</a></p><p><a href="https://github.com/xitu/gold-miner/blob/master/TODO/a-blurring-view-for-android.md" target="_blank" rel="noopener">在 Android 下进行实时模糊渲染</a></p><p><a href="https://github.com/ljianshu/Blog/issues/22" target="_blank" rel="noopener">关于Http协议，你必须要知道的</a></p><hr><p><a href="https://www.cnblogs.com/yjiyjige/p/3263858.html#commentform" target="_blank" rel="noopener">详解KMP算法</a></p><p><a href="https://www.jianshu.com/p/aaafcd72c127" target="_blank" rel="noopener">要点提炼|开发艺术之Bitmap&amp;Cache</a></p><p><a href="https://www.jianshu.com/p/10dc575896d3" target="_blank" rel="noopener">要点提炼|开发艺术之Animation</a></p><p><a href="https://mp.weixin.qq.com/s/PCkVsD8nPJV3wXkPg_6yDw" target="_blank" rel="noopener">分享一个我开发的MVVM架构的开源小项目 —— 郭霖</a></p><p><a href="https://medium.com/flutter-community/flutter-push-pop-push-1bb718b13c31" target="_blank" rel="noopener">Flutter: Push, Pop, Push</a></p><p><a href="https://docs.flutter.io/flutter/widgets/Navigator-class.html" target="_blank" rel="noopener">Navigator class</a></p><p><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html" target="_blank" rel="noopener">十大经典排序算法最强总结（含JAVA代码实现）</a></p><p><a href="https://www.jianshu.com/p/06ff0dfeed39" target="_blank" rel="noopener">要点提炼|开发艺术之View</a></p><p><a href="https://www.jianshu.com/p/02962454adf7?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq" target="_blank" rel="noopener">Android 消息处理机制（Looper、Handler、MessageQueue,Message）</a>🌟</p><p><a href="https://github.com/sucese/android-interview-guide/blob/master/doc/Android%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86.md" target="_blank" rel="noopener">Android网络编程面试题集</a>🌟</p><p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">深入解析String#intern —— 美团技术</a></p><hr><p><a href="https://www.jianshu.com/p/e8955f525f4c" target="_blank" rel="noopener">【大揭秘】Android架构组件ViewModel来龙去脉</a></p><p><a href="https://juejin.im/entry/586a12c5128fe10057037fba" target="_blank" rel="noopener">RecyclerView 源码解析</a></p><p><a href="https://iamasoldier6.com/2017/03/25/%E6%B7%B1%E5%85%A5-RecyclerView-%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6%E4%B8%80%EF%BC%9A%E5%AE%8F%E8%A7%82%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">深入 RecyclerView 源码探究一：宏观设计</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;已读&quot;&gt;&lt;a href=&quot;#已读&quot; class=&quot;headerlink&quot; title=&quot;已读&quot;&gt;&lt;/a&gt;已读&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html&quot; 
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读" scheme="https://meandni.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记6——高效并发</title>
    <link href="https://meandni.com/2019/01/18/jvm_note6/"/>
    <id>https://meandni.com/2019/01/18/jvm_note6/</id>
    <published>2019-01-18T01:47:40.000Z</published>
    <updated>2019-04-12T06:05:23.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五部分-高效并发"><a href="#第五部分-高效并发" class="headerlink" title="第五部分 高效并发"></a>第五部分 高效并发</h1><h2 id="第十二章-Java内存模型与线程"><a href="#第十二章-Java内存模型与线程" class="headerlink" title="第十二章 Java内存模型与线程"></a>第十二章 Java内存模型与线程</h2><p>并发处理的广泛应用是使得Amdahl定律代替摩尔定律成为计算机性能发展源动力的根本原因，也是人类“压榨”计算机运算能力的最有力武器。</p><h3 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h3><ul><li>多任务处理在现代计算机操作系统中几乎已是一项必备的功能了；</li><li>除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景；</li><li>服务端是Java语言最擅长的领域之一，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持，幸好Java语言和虚拟机提供了许多工具，把并发编码的门槛降低了不少；</li></ul><h3 id="12-2-硬件的效率与一致性"><a href="#12-2-硬件的效率与一致性" class="headerlink" title="12.2 硬件的效率与一致性"></a>12.2 硬件的效率与一致性</h3><ul><li>绝大多数的运算任务不可能只靠处理器计算就能完成，处理器至少要与内存交互，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速运行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了；</li><li>基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性；为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等；</li><li>本章将会多次提到内存模型一词，可以理解在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象；不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问具有很高的可比性；</li><li>除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的；</li></ul><h3 id="12-3-Java内存模型"><a href="#12-3-Java内存模型" class="headerlink" title="12.3 Java内存模型"></a>12.3 Java内存模型</h3><p>Java虚拟机规范中视图定义一种Java内存模型（JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><h4 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h4><ul><li>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节；此处的变量与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享；</li><li>Java内存模型规定了所有的变量都存储在主内存中，每个线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量；</li><li>这里所讲的主内存、工作内存与第二章所讲的Java内存区域中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的；线程、主内存和工作内存的关系如下所示：</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-01c9d97d757d8c1f.png" alt="线程、主内存和工作内存的关系"></p><h4 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h4><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下八种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量的某些操作在某些平台允许有例外）：</p><ul><li>lock</li><li>unlock</li><li>read</li><li>load</li><li>use</li><li>assign</li><li>store</li><li>write</li></ul><p>基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃采用这八种操作去定义Java内存模型的访问协议了，后面将会介绍一个等效判断原则 – 先行发生原则，用来确定一个访问在并发环境下是否安全；</p><h4 id="12-3-3-对于volatile型变量的特殊规则"><a href="#12-3-3-对于volatile型变量的特殊规则" class="headerlink" title="12.3.3 对于volatile型变量的特殊规则"></a>12.3.3 对于volatile型变量的特殊规则</h4><ul><li>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制；</li><li>当一个变量定义为volatile之后，它将具备两种特性：第一是保证此变量对所有线程的可见性，这里的可见性是指当一个线程修改了这个变量的值，新的值对于其他线程来说是可以立即得知的，而普通的变量的值在线程间传递均需要通过主内存来完成；另外一个是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致；</li><li>volatile变量在各个线程的工作内存中不存在一致性问题，但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的；</li><li>在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性：运算结果并不依赖变量的当前值或者能够确保只有单一的线程修改变量的值、变量不需要与其他的状态变量共同参与不变约束；</li><li>volatile变量读操作的性能消耗与普通变量几乎没有任何差别，但是写操作则可能会慢一些；不过大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求；</li></ul><h4 id="12-3-4-对于long和double型变量的特殊规则"><a href="#12-3-4-对于long和double型变量的特殊规则" class="headerlink" title="12.3.4 对于long和double型变量的特殊规则"></a>12.3.4 对于long和double型变量的特殊规则</h4><ul><li>允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子性协定；</li><li>但允许虚拟机选择把这些操作实现为具有原子性的操作，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待；</li></ul><h4 id="12-3-5-原子性、可见性与有序性"><a href="#12-3-5-原子性、可见性与有序性" class="headerlink" title="12.3.5 原子性、可见性与有序性"></a>12.3.5 原子性、可见性与有序性</h4><ul><li>原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write；在synchronized块之间的操作也具备原子性；</li><li>可见性（Visibility）：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改；除了volatile之外，Java还有synchronized和final关键字能实现可见性；</li><li>有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的；Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性；</li></ul><h4 id="12-3-6-先行发生原则"><a href="#12-3-6-先行发生原则" class="headerlink" title="12.3.6 先行发生原则"></a>12.3.6 先行发生原则</h4><ul><li>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，影响包括了修改了内存中共享变量的值、发送了消息、调用了方法等；</li><li>下面是Java内存模型下一些天然的先行发生关系：程序次序规则、管程锁定规则、volatile变量规则、线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性；</li><li>时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准；</li></ul><h3 id="12-4-Java与线程"><a href="#12-4-Java与线程" class="headerlink" title="12.4 Java与线程"></a>12.4 Java与线程</h3><h4 id="12-4-1-线程的实现"><a href="#12-4-1-线程的实现" class="headerlink" title="12.4.1 线程的实现"></a>12.4.1 线程的实现</h4><ul><li>线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源又可以独立调度；</li><li>Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的；</li><li>实现线程主要有三种方式：使用内核线程实现（系统调用代价相对较高、一个系统支持轻量级进程的数量是有限的）、使用用户线程实现（优势在于不需要系统内核支援，劣势在于所有线程操作都需要用户程序自己处理）和使用用户线程加轻量级进程混合实现（用户线程是完全建立在用户空间中，因此用户线程的创建、切换等操作依然廉价，并且可以支持大规模的用户线程并发；而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险）；</li><li>对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模式就是一对一的；</li></ul><h4 id="12-4-2-Java线程调度"><a href="#12-4-2-Java线程调度" class="headerlink" title="12.4.2 Java线程调度"></a>12.4.2 Java线程调度</h4><ul><li>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（线程的执行时间由线程本身来控制）和抢占式线程调度（线程由系统来分配执行时间，线程的切换不由线程本身来决定）；</li><li>Java语言一共设置了10个级别的线程优先级，不过线程优先级并不是太靠谱，原因就是操作系统的线程优先级不见得总是与Java线程的优先级一一对应，另外优先级还可能被系统自行改变；</li></ul><h4 id="12-4-3-状态转换"><a href="#12-4-3-状态转换" class="headerlink" title="12.4.3 状态转换"></a>12.4.3 状态转换</h4><ul><li>Java语言定义了五种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别是新建（New）、运行（Runnable）、无限期等待（Waiting）、限期等待（Timed Waiting）、阻塞（Blocled）、结束（Terminated）。它们之间相互的转换关系如下所示：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-68f2cc99d1439039.png" alt="线程状态转换关系" title="">                </div>                <div class="image-caption">线程状态转换关系</div>            </figure><h3 id="12-5-本章小结"><a href="#12-5-本章小结" class="headerlink" title="12.5 本章小结"></a>12.5 本章小结</h3><p>本章我们首先了解了虚拟机Java内存模型的结构及操作，然后讲解了原子性、可见性、有序性在Java内存模型中的体现，最后介绍了先行发生原则的规则及使用。另外，我们还了解了线程在Java语言之中是如何实现的。</p><p>在本章主要介绍了虚拟机如何实现并发，而在下一章我们主要关注点将是虚拟机如何实现高效，以及虚拟机对我们编写的并发代码提供了什么样的优化手段。</p><h2 id="第十三章-线程安全与锁优化"><a href="#第十三章-线程安全与锁优化" class="headerlink" title="第十三章 线程安全与锁优化"></a>第十三章 线程安全与锁优化</h2><h3 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h3><ul><li>首先需要保证并发的正确性，然后在此基础上实现高效；</li></ul><h3 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h3><p>Brian Goetz对线程安全有一个比较恰当的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p><h4 id="13-2-1-Java语言中的线程安全"><a href="#13-2-1-Java语言中的线程安全" class="headerlink" title="13.2.1 Java语言中的线程安全"></a>13.2.1 Java语言中的线程安全</h4><ul><li>我们可以将Java语言中各个操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立；</li><li>不可变：不可变带来的安全性是最简单和最纯粹的，如final的基本数据类型；如果共享的数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行，比如String类的substring、replace方法；Number类型的大部分子类都符合不可变要求的类型，但是AtomicInteger和AtomicLong则并非不可变的；</li><li>线程绝对安全：Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全；比如java.util.Vector，不意味着调用它的是时候永远都不再需要同步手段了；</li><li>线程相对安全：是我们通常意义上所讲的线程安全，在Java语言中，大部分的线程安全类都属于这种类型；</li><li>线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用；我们说一个类不是线程安全的，绝大多数时候指的是这一种情况；</li><li>线程对立：无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码，Java语言中很少出现；</li></ul><h4 id="13-2-2-线程安全的实现方法"><a href="#13-2-2-线程安全的实现方法" class="headerlink" title="13.2.2 线程安全的实现方法"></a>13.2.2 线程安全的实现方法</h4><ul><li>互斥同步：同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用，而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式；Java中最基本的互斥同步手段就是synchronized关键字，它对同一个线程来说是可重入的且会阻塞后面其他线程的进入；另外还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步，相比synchronized关键字ReentrantLock增加了一些高级功能：等待可中断、可实现公平锁以及锁可以绑定多个条件；</li><li>非阻塞同步：互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，其属于一种悲观的并发策略；随着硬件指令集的发展，我们有了另外一个选择即基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程争用共享数据那就操作成功了，如果有争用产生了冲突，那就再采取其他的补偿措施（最常见的就是不断重试直至成功），这种同步操作称为非阻塞同步；Java并发包的整数原子类，其中的compareAndSet和getAndIncrement等方法都使用了Unsafe类的CAS操作；</li><li>无同步方案：要保证线程安全，并不是一定就要进行同步；有一些代码天生就是线程安全的，比如可重入代码和线程本地存储的代码；</li></ul><h3 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h3><h4 id="13-3-1-自旋锁与自适应自旋"><a href="#13-3-1-自旋锁与自适应自旋" class="headerlink" title="13.3.1 自旋锁与自适应自旋"></a>13.3.1 自旋锁与自适应自旋</h4><ul><li>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力；另外在共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得，如果让两个或以上的线程同时并行执行，让后面请求锁的那个线程稍等一下，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁；为了让线程等待，我们只需让线程执行一个忙循环，这些技术就是所谓的自旋锁；</li><li>在JDK 1.6已经默认开启自旋锁；如果锁被占用的时间很短自旋等待的效果就会非常好，反之则会白白消耗处理器资源；</li><li>在JDK 1.6中引入了自适应的自旋锁，这意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定；</li></ul><h4 id="13-3-2-锁消除"><a href="#13-3-2-锁消除" class="headerlink" title="13.3.2 锁消除"></a>13.3.2 锁消除</h4><ul><li>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除；</li><li>锁消除的主要判断依据来源于逃逸分析的数据支持；</li></ul><h4 id="13-3-3-锁粗化"><a href="#13-3-3-锁粗化" class="headerlink" title="13.3.3 锁粗化"></a>13.3.3 锁粗化</h4><ul><li>原则上总是推荐将同步块的作用范围限制得尽量小 – 只有在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁；</li><li>但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗；</li></ul><h4 id="13-3-4-轻量级锁"><a href="#13-3-4-轻量级锁" class="headerlink" title="13.3.4 轻量级锁"></a>13.3.4 轻量级锁</h4><ul><li>轻量级锁是JDK 1.6之中加入的新型锁机制，它是相对于使用操作系统互斥量来实现的传统锁而言的；它并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗；</li><li>要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须从HotSpot虚拟机的对象的内存布局开始介绍；HotSpot虚拟机的对象头分为两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄等，这部分官方称之为Mark Word，是实现轻量级锁和偏向锁的关键，另外一部分用于存储指向方法区对象类型数据的指针； Mark Word被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，在32位的HotSpot虚拟机中对象未被锁定的状态下，25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0；在其他状态（轻量级锁定、重量级锁定、GC标志、可偏向）下对象的存储内容如下：</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-5ab1ae52e69821c1.png" alt="HotSpot虚拟机对象头"></p><ul><li>在代码进入同步块的时候，如果此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储对象目前的Mark Word的拷贝（官方称之为Displaced Mark Word）；然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果更新成功了那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位将转变为“00”，即表示此对象处于轻量级锁定状态；如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了；如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进行阻塞状态；</li><li>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据；</li></ul><h4 id="13-3-5-偏向锁"><a href="#13-3-5-偏向锁" class="headerlink" title="13.3.5 偏向锁"></a>13.3.5 偏向锁</h4><ul><li>偏向锁也是JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能；如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了；</li><li>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步；</li><li>假设当前虚拟机启动了偏向锁，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式；同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中；如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作；当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如上面介绍的轻量级锁那样执行；偏向锁、轻量级锁的状态转化以及对象Mark Work的关系如下图所示：</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-2501d5d148f80a2d.png" alt="偏向锁、轻量级锁的状态转化"></p><ul><li>偏向锁可以提高带有同步但无竞争的程序性能，它同样是一个带有效益权衡性质的优化；</li></ul><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了线程安全所涉及的概念和分类、同步实现的方式及虚拟机的底层运行原理，并且介绍了虚拟机为了实现高效并发所采取的一系列锁优化措施。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五部分-高效并发&quot;&gt;&lt;a href=&quot;#第五部分-高效并发&quot; class=&quot;headerlink&quot; title=&quot;第五部分 高效并发&quot;&gt;&lt;/a&gt;第五部分 高效并发&lt;/h1&gt;&lt;h2 id=&quot;第十二章-Java内存模型与线程&quot;&gt;&lt;a href=&quot;#第十二章-Java
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读" scheme="https://meandni.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="jvm" scheme="https://meandni.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记5——类加载机制与字节码执行引擎</title>
    <link href="https://meandni.com/2019/01/15/jvm_note5/"/>
    <id>https://meandni.com/2019/01/15/jvm_note5/</id>
    <published>2019-01-15T04:12:44.000Z</published>
    <updated>2019-04-12T06:05:29.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><ul><li>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</li><li>在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成，这虽然增量一些性能开销，但是会为Java应用程序提供高度的灵活性。</li></ul><h3 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h3><ul><li>类的整个生命周期：加载、验证、准备、解析、初始化、使用和卸载；其中验证、准备和解析统称为连接；</li><li>虚拟机规范没有强制约束类加载的时机，但严格规定了有且只有5种情况必须立即对类进行初始化：遇到new、getstatic、putstatic和invokestatic指令；对类进行反射调用时如果类没有进行过初始化；初始化时发现父类还没有进行初始化；虚拟机启动指定的主类；动态语言中MethodHandle实例最后解析结果REF_getStatic等的方法句柄对应的类没有初始化时；</li></ul><h3 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3 类加载的过程"></a>7.3 类加载的过程</h3><h4 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h4><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流；</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li></ul><h4 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h4><ul><li>验证是连接阶段的第一步，其目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全；</li><li>验证阶段是非常重要的，这个阶段是否严谨决定了Java虚拟机是否能承受恶意代码的攻击；</li><li>校验动作：文件格式验证（基于二进制字节流）、元数据验证（对类的元数据语义分析）、字节码验证（对方法体语义分析）、符号引用验证（对类自身以外的信息进行匹配性校验）；</li></ul><h4 id="7-3-3-准备"><a href="#7-3-3-准备" class="headerlink" title="7.3.3 准备"></a>7.3.3 准备</h4><ul><li>正式为变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在这个方法区中进行分配；</li><li>需要强调两点：这时候内存分配的仅包括类变量，而不包括类实例变量；这里所说的初始化通常情况下是数据类型的零值，真正的赋值是在初始化阶段，<strong>如果是static final的则是直接赋值</strong>；</li></ul><h4 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h4><ul><li>解析阶段是虚拟机将常量池内的符号引用（如CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等7种）替换为直接引用的过程；</li><li>符号引用可以是任何形式的字面量，与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中；而直接引用是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，它和虚拟机实现的内存布局相关，引用的目标必定以及在内存中存在；</li><li>对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可以对第一次解析的结果进行缓存；</li></ul><h4 id="7-3-5-初始化"><a href="#7-3-5-初始化" class="headerlink" title="7.3.5 初始化"></a>7.3.5 初始化</h4><ul><li>是类加载过程的最后一步，真正开始执行类中定义的Java程序代码（或者说是字节码）；</li><li>初始化阶段是执行类构造器<clinit>方法的过程，该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的；</clinit></li><li><clinit>方法与类的构造函数（或者说是实例构造器<init>方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>方法执行之前，父类的<clinit>方法已执行完毕；</clinit></clinit></init></clinit></li><li>执行接口的<clinit>方法不需要先执行父接口的<clinit>方法，只有当父接口中定义的变量使用时父接口才会初始化，接口的实现类在初始化时也一样不会执行接口的<clinit>方法；</clinit></clinit></clinit></li><li><clinit>方法初始化是加锁阻塞等待的，应当避免在<clinit>方法中有耗时很长的操作；</clinit></clinit></li></ul><h3 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h3><ul><li>虚拟机设计团队把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到虚拟机外部去实现，实现这个动作的代码模块称为类加载器；</li><li>这时Java语言的一项创新，也是Java语言流行的重要原因，在类层次划分、OSGI、热部署、代码加密等领域大放异彩；</li></ul><h4 id="7-4-1-类与类加载器"><a href="#7-4-1-类与类加载器" class="headerlink" title="7.4.1 类与类加载器"></a>7.4.1 类与类加载器</h4><ul><li>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机的唯一性，每一个类加载器都拥有一个独立的类名称空间；</li><li>比较两个类是否相等（如Class对象的equals方法、isAssignableFrom方法、isInstance方法），只有在这两个类是由同一个类加载器加载的前提下才有意义；</li></ul><h4 id="7-4-2-双亲委派模型"><a href="#7-4-2-双亲委派模型" class="headerlink" title="7.4.2 双亲委派模型"></a>7.4.2 双亲委派模型</h4><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-4e150bb5176ab73d.png" alt="双亲委派模型"></p><ul><li>三种系统提供的类加载器：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）；</li><li>双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器，这里一般不会以继承的关系来实现，而是使用组合的关系来复用父加载器的代码；</li><li>其工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有父类加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载；</li><li>这样的好处是Java类随着它的类加载器具备了一种带有优先级的层次关系，对保证Java程序的稳定运作很重要；</li><li>实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass方法中，逻辑清晰易懂；</li></ul><h4 id="7-4-3-破坏双亲委派模型"><a href="#7-4-3-破坏双亲委派模型" class="headerlink" title="7.4.3 破坏双亲委派模型"></a>7.4.3 破坏双亲委派模型</h4><ul><li>上一小节的双亲委派模型是Java设计者推荐给开发者的类加载器实现方法，但不是一个强制性的约束模型；</li><li>典型的两种情况：为了解决JNI接口提供者（SPI）引入的线程上下文类加载器；为了程序动态性加强的OSGI的Bundle类加载器；</li></ul><h3 id="7-5-本章小结"><a href="#7-5-本章小结" class="headerlink" title="7.5 本章小结"></a>7.5 本章小结</h3><p>本章介绍了类加载过程的加载、验证、准备、解析和初始化五个阶段中虚拟机进行了哪些动作，还介绍了类加载器的工作原理及其对虚拟机的意义。下一章将一起看看虚拟机如果执行定义在Class文件里的字节码。</p><h2 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 虚拟机字节码执行引擎"></a>第八章 虚拟机字节码执行引擎</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><ul><li>执行引擎是Java虚拟机最核心的组成部分之一，区别于物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎是自己实现的，可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式；</li><li>在虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，该模型成为各种虚拟机执行引擎的统一外观；</li><li>在不同的虚拟机实现里面，执行引擎在执行Java代码时可能会有解释执行和编译执行两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎，但从外观来说是一致的：输入的都是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</li></ul><h3 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-009d0f0efe9f528e.png" alt="运行时栈帧结构" title="">                </div>                <div class="image-caption">运行时栈帧结构</div>            </figure><ul><li>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素；</li><li>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机里面从入栈到出栈的过程；</li><li>栈帧需要分配多少内存在编译时就完全确定并写入到方法表的Code属性之中了，不会受到程序运行期变量数据的影响；</li><li>对于执行引擎来说，在活动线程中只有位于栈顶的栈帧才算有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法，执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。</li></ul><h4 id="8-2-1-局部变量表"><a href="#8-2-1-局部变量表" class="headerlink" title="8.2.1 局部变量表"></a>8.2.1 局部变量表</h4><ul><li>是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，Code属性的max_locals确定了该方法所需要分配的局部变量表的最大容量；</li><li>其容量以变量槽（Variable Slot）为最小单位，虚拟机规范允许Slot的长度随处理器、操作系统或虚拟机的不同而发生变化；</li><li>一个Slot可以存放一个32位以内的数据类型，包括boolean、byte、char。short、int、float、reference和returnAddress这八种类型；对于64位的数据类型（long和double），虚拟机会以高位对齐的方式为其分配两个连续的Slot空间；</li></ul><h4 id="8-2-2-操作数栈"><a href="#8-2-2-操作数栈" class="headerlink" title="8.2.2 操作数栈"></a>8.2.2 操作数栈</h4><ul><li>也常称为操作栈，它是一个后入先出栈；Code属性的max_stacks确定了其最大深度；</li><li>比如整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈；</li><li>操作数栈中元素的类型必须与字节码指令的序列严格匹配；</li><li>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的栈就是操作数栈；</li></ul><h4 id="8-2-3-动态连接"><a href="#8-2-3-动态连接" class="headerlink" title="8.2.3 动态连接"></a>8.2.3 动态连接</h4><ul><li>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）；</li><li>Class文件的常量池的符号引用，有一部分在类加载阶段或者第一次使用时就转换为直接引用，这种称为静态解析，而另外一部分在每一次运行期间转换为直接引用，这部分称为动态连接；</li></ul><h4 id="8-2-4-方法返回地址"><a href="#8-2-4-方法返回地址" class="headerlink" title="8.2.4 方法返回地址"></a>8.2.4 方法返回地址</h4><ul><li>退出方法的方式：正常完成出口和异常完成出口；</li><li>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能只需的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数中，调整PC计数器的值以只需方法调用指令后面的一套指令等；</li></ul><h4 id="8-2-5-附加信息"><a href="#8-2-5-附加信息" class="headerlink" title="8.2.5 附加信息"></a>8.2.5 附加信息</h4><ul><li>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分完成取决于具体的虚拟机实现；</li></ul><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul><li>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本即调用哪一个方法，暂时还不涉及方法内部的具体运行过程；</li><li>Class文件的编译过程中不报警传统编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂；</li></ul><h4 id="8-3-1-解析"><a href="#8-3-1-解析" class="headerlink" title="8.3.1 解析"></a>8.3.1 解析</h4><ul><li>方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，这类方法的调用称为解析；</li><li>在Java语言中符合编译器可知、运行期不可变这个要求的方法，主要包括静态方法和私有方法两大类；</li><li>五条方法调用字节码指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic；</li><li>解析调用是一个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用；而分派调用则可能是静态的也可能是动态的；</li></ul><h4 id="8-3-2-分派"><a href="#8-3-2-分派" class="headerlink" title="8.3.2 分派"></a>8.3.2 分派</h4><ul><li>静态分派：“Human man = new Man();”语句中Human称为变量的静态类型，后面的Man称为变量的实际类型；静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译器可知的；而实际类型的变化在运行期才确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么；编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的；所有根据静态类型来定位方法执行版本的分派动作称为静态分派，其典型应用是方法重载；</li><li>动态分派：invokevirtual指令执行的第一步就是在运行期间确定接收者的实际类型，所以两次调用中invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质；我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派；</li><li>单分派与多分派：方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派分为单分派（根据一个宗量对目标方法进行选择）与多分派（根据多于一个宗量对目标方法进行选择）两种；今天的Java语言是一门静态多分派、动态单分派的语言；</li><li>虚拟机动态分派的实现：在方法区中建立一个虚方法表（Virtual Method Table），使用虚方法表索引来代替元数据查找以提高性能；方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始化值后，虚拟机会把该类的方法表也初始化完毕；</li></ul><h4 id="8-3-3-动态类型语言支持"><a href="#8-3-3-动态类型语言支持" class="headerlink" title="8.3.3 动态类型语言支持"></a>8.3.3 动态类型语言支持</h4><ul><li>JDK 1.7发布增加的invokedynamic指令实现了“动态类型语言”支持，也是为JDK 1.8顺利实现Lambda表达式做技术准备；</li><li>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器，比如JavaScript、Python等；</li><li>Java语言在编译期间就将方法完整的符号引用生成出来，作为方法调用指令的参数存储到Class文件中；这个符号引用包含了此方法定义在哪个具体类型之中、方法的名字以及参数顺序、参数类型和方法返回值等信息；而在ECMAScript等动态语言中，变量本身是没有类型的，变量的值才具有类型，编译时最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型；变量无类型而变量值才有类型，这个特点也是动态类型语言的一个重要特征；</li><li>JDK 1.7实现了JSR-292，新加入的java.lang.invoke包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法外，提供一种新的动态确定目标方法的机制，称为MethodHandle；</li><li>从本质上讲，Reflection（反射）和MethodHandle机制都是在模拟方法调用，但Reflection是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用，前者是重量级，而后者是轻量级；另外前者只为Java语言服务，后者可服务于所有Java虚拟机之上的语言；</li><li>每一处含有invokedynamic指令的位置都称为“动态调用点(Dynamic Call Site)”，这条指令的第一个参数不再是代表符号引用的CONSTANT_Methodref_info常量，而是CONSTANT_InvokeDynamic_info常量（可以得到引导方法、方法类型和名称）；</li><li>invokedynamic指令与其他invoke指令的最大差别就是它的分派逻辑不是由虚拟机决定的，而是由程序员决定的；</li></ul><h3 id="8-4-基于栈的字节码解释执行引擎"><a href="#8-4-基于栈的字节码解释执行引擎" class="headerlink" title="8.4 基于栈的字节码解释执行引擎"></a>8.4 基于栈的字节码解释执行引擎</h3><p>上节主要讲虚拟机是如何调用方法的，这节探讨虚拟机是如何执行方法中的字节码指令的。</p><h4 id="8-4-1-解释执行"><a href="#8-4-1-解释执行" class="headerlink" title="8.4.1 解释执行"></a>8.4.1 解释执行</h4><ul><li>只有确定了谈论对象是某种具体的Java实现版本和执行引擎运行模式时，谈解释执行还是编译执行才比较确切；</li><li>Java语言中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程；因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现；</li></ul><h4 id="8-4-2-基于栈的指令集与基于寄存器的指令集"><a href="#8-4-2-基于栈的指令集与基于寄存器的指令集" class="headerlink" title="8.4.2 基于栈的指令集与基于寄存器的指令集"></a>8.4.2 基于栈的指令集与基于寄存器的指令集</h4><ul><li>Java编译器输出的指令集，基本上是一种基于栈的指令集架构，指令流中的指令大部分是零地址指令，它们依赖操作数栈进行工作；</li><li>基于栈的指令集主要的优点是可移植性，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束；主要缺点是执行速度相对来说会稍慢一点；</li></ul><h4 id="8-4-3-基于栈的解释器执行过程"><a href="#8-4-3-基于栈的解释器执行过程" class="headerlink" title="8.4.3 基于栈的解释器执行过程"></a>8.4.3 基于栈的解释器执行过程</h4><p>一段简单的算法代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int calc()&#123;</span><br><span class="line">    int a = 100;</span><br><span class="line">    int b = 200;</span><br><span class="line">    int c = 300;</span><br><span class="line">    return (a + b) * c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的字节码表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int calc();</span><br><span class="line">Code:</span><br><span class="line">Stack=2, Locals=4, Args_size=1</span><br><span class="line">0:bipush 100</span><br><span class="line">2:istore_1</span><br><span class="line">3:sipush 200</span><br><span class="line">6:istore_2</span><br><span class="line">7:sipush 300</span><br><span class="line">10:istore_3</span><br><span class="line">11:iload_1</span><br><span class="line">12:iload_2</span><br><span class="line">13:iadd</span><br><span class="line">14:iload_3</span><br><span class="line">15:imul</span><br><span class="line">16:ireturn</span><br></pre></td></tr></table></figure><p>javap提示这段代码需要深度为2的操作数栈和4个Slot的局部变量空间，作者根据这些信息画了示意图来说明执行过程中的变化情况：</p><p>执行偏移地址为0的指令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-ae7f979f896ae750.png" alt="执行偏移地址为0的指令" title="">                </div>                <div class="image-caption">执行偏移地址为0的指令</div>            </figure><p>执行偏移地址为2的指令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-4cc3955b129175a3.png" alt="执行偏移地址为2的指令" title="">                </div>                <div class="image-caption">执行偏移地址为2的指令</div>            </figure><p>执行偏移地址为11的指令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-b640506135b2ccd3.png" alt="执行偏移地址为11的指令" title="">                </div>                <div class="image-caption">执行偏移地址为11的指令</div>            </figure><p>执行偏移地址为12的指令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-ddf83219167aca0f.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><p>执行偏移地址为13的指令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-8d58d9d3f21a08e2.png" alt="执行偏移地址为13的指令" title="">                </div>                <div class="image-caption">执行偏移地址为13的指令</div>            </figure><p>执行偏移地址为14的指令</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-ede2baf8e9d01bc6.png" alt="执行偏移地址为14的指令" title="">                </div>                <div class="image-caption">执行偏移地址为14的指令</div>            </figure><p>执行偏移地址为16的指令</p><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-3ddc95e842532183.png" alt="执行偏移地址为16的指令"></p><p>注：上面的执行过程仅仅是一种概念模型，虚拟机中解析器和即时编译器会对输入的字节码进行优化。</p><h3 id="8-5-本章小结"><a href="#8-5-本章小结" class="headerlink" title="8.5 本章小结"></a>8.5 本章小结</h3><p>本章分析了虚拟机在执行代码时，如何找到正确的方法、如何执行方法内的字节码以及执行代码时涉及的内存结构。这第六、七、八三章中，我们针对Java程序是如何存储的、如何载入的以及如何执行的问题进行了讲解，下一章一起看看这些理论知识在具体开发中的经典应用。</p><h2 id="第九章-类加载及执行子系统的案例与实战"><a href="#第九章-类加载及执行子系统的案例与实战" class="headerlink" title="第九章 类加载及执行子系统的案例与实战"></a>第九章 类加载及执行子系统的案例与实战</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><ul><li>在Class文件格式与执行引擎这部分中，用户的程序能直接影响的内容并不多；</li><li>能通过程序进行操作的，主要是字节码生成与类加载器这两部分的功能，但仅仅在如何处理这两点上，就已经出现了许多值得欣赏和借鉴的思路；</li></ul><h3 id="9-2-案例分析"><a href="#9-2-案例分析" class="headerlink" title="9.2 案例分析"></a>9.2 案例分析</h3><h4 id="9-2-1-Tomcat：正统的类加载器架构"><a href="#9-2-1-Tomcat：正统的类加载器架构" class="headerlink" title="9.2.1 Tomcat：正统的类加载器架构"></a>9.2.1 Tomcat：正统的类加载器架构</h4><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-6a33f07ebfd24e1e.png" alt="Tomcat服务器的类加载架构"></p><ul><li>Java Web服务器：部署在同一个服务器上的两个Web应用程序所使用的Java类库可以实现相互隔离又要可以互相共享；尽可能保证自身的安全不受部署的Web应用程序影响；要支持JSP生成类的热替换；</li><li>上图中，灰色背景的三个类加载器是JDK默认提供的类加载器，而CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader是Tomcat自己定义的类加载器，分别加载/common/<em>（可被Tomcat和Web应用共用）、/server/</em>（可被Tomcat使用）、/shared/<em>（可被Web应用使用）和/WebApp/WEB-INF/</em>（可被当前Web应用使用）中的Java类库，Tomcat 6.x把前面三个目录默认合并到一起变成一个/lib目录（作用同原先的common目录）；</li></ul><h4 id="9-2-2-OSGI：灵活的类加载架构"><a href="#9-2-2-OSGI：灵活的类加载架构" class="headerlink" title="9.2.2 OSGI：灵活的类加载架构"></a>9.2.2 OSGI：灵活的类加载架构</h4><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-5c270d4c6018cee3.png" alt="OSGI的类加载架构"></p><ul><li>OSGI的每个模块称为Bundle，可以声明它所依赖的Java Package（通过Import-Package描述），也可以声明它允许导出发布的Java Package（通过Export-Package描述）；</li><li>除了更精确的模块划分和可见性控制外，引入OSGI的另外一个重要理由是基于OSGI的程序很可能可以实现模块级的热插拔功能；</li><li>OSGI的类加载器之间只有规则，没有固定的委派关系；加载器之间的关系更为复杂、运行时才能确定的网状结构，提供灵活性的同时，可能会产生许多的隐患；</li></ul><h4 id="9-2-3-字节码生成技术与动态代理的实现"><a href="#9-2-3-字节码生成技术与动态代理的实现" class="headerlink" title="9.2.3 字节码生成技术与动态代理的实现"></a>9.2.3 字节码生成技术与动态代理的实现</h4><ul><li>在Java里面除了javac和字节码类库外，使用字节码生成的例子还有Web服务器中的JSP编译器、编译时植入的AOP框架和很常用的动态代理技术等，这里选择其中相对简单的动态代理来看看字节码生成技术是如何影响程序运作的；</li><li>动态代理的优势在于实现了在原始类和接口还未知的时候就确定类的代理行为，可以很灵活地重用于不同的应用场景之中；</li><li>以下的例子中生成的代理类“$Proxy0.class”文件可以看到代理为传入接口的每一个方法统一调用了InvocationHandler对象的invoke方法；其生成代理类的字节码大致过程其实就是根据Class文件的格式规范去拼接字节码；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyTest &#123;</span><br><span class="line"></span><br><span class="line">    interface IHello &#123;</span><br><span class="line">        void sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Hello implements IHello &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void sayHello() &#123;</span><br><span class="line">            System.out.println(&quot;Hello world&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line">        Object originalObj;</span><br><span class="line"></span><br><span class="line">        Object bind(Object originalObj) &#123;</span><br><span class="line">            this.originalObj = originalObj;</span><br><span class="line">            return Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass().getInterfaces(), this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            System.out.println(&quot;Welcome&quot;);</span><br><span class="line">            return method.invoke(originalObj, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // add this property to generate proxy class file</span><br><span class="line">        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">        IHello hello = (IHello) new DynamicProxy().bind(new Hello());</span><br><span class="line">        hello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-4-Retrotranslator：跨越JDK版本"><a href="#9-2-4-Retrotranslator：跨越JDK版本" class="headerlink" title="9.2.4 Retrotranslator：跨越JDK版本"></a>9.2.4 Retrotranslator：跨越JDK版本</h4><ul><li>Retrotranslator的作用是将JDK 1.5编译出来的Class文件转变为可以在JDK 1.4或JDK 1.3部署的版本，它可以很好地支持自动装箱、泛型、动态注解、枚举、变长参数、遍历循环、静态导入这些语法特性，甚至还可以支持JDK 1.5中新增的集合改进、并发包以及对泛型、注解等的反射操作；</li><li>JDK升级通常包括四种类型：编译器层面的做的改进、Java API的代码增强、需要再字节码中进行支持的活动以及虚拟机内部的改进，Retrotranslator只能模拟前两类，第二类通过独立类库实现，第一类则通过ASM框架直接对字节码进行处理；</li></ul><h3 id="9-3-实战：自己动手实现远程执行功能"><a href="#9-3-实战：自己动手实现远程执行功能" class="headerlink" title="9.3 实战：自己动手实现远程执行功能"></a>9.3 实战：自己动手实现远程执行功能</h3><ul><li>目标：不依赖JDK版本、不改变原有服务端程序的部署，不依赖任何第三方类库、不侵入原有程序、临时代码的执行结果能返回到客户端；</li><li>思路：如何编译提交到服务器的Java代码（客户端编译好上传Class文件而不是Java代码）、如何执行编译之后的Java代码（要能访问其他类库，要能卸载）、如何收集Java代码的执行结果（在执行的类中把System.out的符号引用替换为我们准备的PrintStream的符号引用）；</li><li>具体实现：HotSwapClassLoader用于实现同一个类的代码可以被多次加载，通过公开父类ClassLoader的defineClass实现；HackSystem是为了替换java.lang.System，它直接修改Class文件格式的byte[]数组中的常量池部分，将常量池中指定内容的CONSTANT_Utf8_info常量替换为新的字符串；ClassModifier涉及对byte[]数组操作的部分，主要是将byte[]与int和String互相转换，以及把对byte[]数据的替换操作封装在ByteUtils类中；经过ClassModifier处理过的byte[]数组才会传给HotSwapClassLoader.loadByte方法进行类加载；而JavaClassExecutor是提供给外部调用的入口；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class JavaClassExecutor &#123;</span><br><span class="line"></span><br><span class="line">    public static String execute(byte[] classByte) &#123;</span><br><span class="line">        HackSystem.clearBuffer();</span><br><span class="line">        ClassModifier cm = new ClassModifier(classByte);</span><br><span class="line">        byte[] modifiedBytes = cm.modifyUTF8Constant(&quot;java/lang/System&quot;, &quot;org/fenixsoft/classloading/execute/HackSystem&quot;);</span><br><span class="line">        HotSwapClassLoader hotSwapClassLoader = new HotSwapClassLoader();</span><br><span class="line">        Class clazz = hotSwapClassLoader.loadByte(modifiedBytes);</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method = clazz.getMethod(&quot;main&quot;, new Class[]&#123;String[].class&#125;);</span><br><span class="line">            method.invoke(null, new String[]&#123;null&#125;);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace(HackSystem.out);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return HackSystem.getBufferString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于测试的JSP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page import=&quot;java.lang.*&quot; %&gt;</span><br><span class="line">&lt;%@page import=&quot;java.io.*&quot; %&gt;</span><br><span class="line">&lt;%@page import=&quot;org.fenixsoft.classloading.execute.*&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">InputStream is = new FileInputStream(&quot;c:/TestClass.class&quot;);</span><br><span class="line">byte[] b = new byte[is.available()];</span><br><span class="line">is.read(b);</span><br><span class="line">is.close();</span><br><span class="line"></span><br><span class="line">out.println(JavaClassExecutor.execute(b));</span><br><span class="line"></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="9-4-本章小结"><a href="#9-4-本章小结" class="headerlink" title="9.4 本章小结"></a>9.4 本章小结</h3><p>只有了解虚拟机如何执行程序，才能更好地理解怎样写出优秀的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第七章-虚拟机类加载机制&quot;&gt;&lt;a href=&quot;#第七章-虚拟机类加载机制&quot; class=&quot;headerlink&quot; title=&quot;第七章 虚拟机类加载机制&quot;&gt;&lt;/a&gt;第七章 虚拟机类加载机制&lt;/h2&gt;&lt;h3 id=&quot;7-1-概述&quot;&gt;&lt;a href=&quot;#7-1-概述&quot;
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读" scheme="https://meandni.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="jvm" scheme="https://meandni.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记4——类文件结构</title>
    <link href="https://meandni.com/2019/01/14/jvm_note4/"/>
    <id>https://meandni.com/2019/01/14/jvm_note4/</id>
    <published>2019-01-14T07:24:44.000Z</published>
    <updated>2019-04-12T06:05:32.181Z</updated>
    
    <content type="html"><![CDATA[<p>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</p><p>由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p><h1 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h1><ul><li>Java刚诞生的宣传口号：一次编写，到处运行（Write Once, Run Anywhere）。其最终实现在操作系统的应用层：Sun公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码。</li><li>字节码（ByteCode）是构成平台无关的基石；</li><li>另外虚拟机的语言无关性也越来越被开发者所重视，JVM设计者在最初就考虑过实现让其他语言运行在Java虚拟机之上的可能性，如今已发展出一大批在JVM上运行的语言，比如Clojure、Groovy、JRuby、Jython、Scala；</li><li>实现语言无关性的基础仍是虚拟机和字节码存储格式，Java虚拟机不和包括Java在内的任何语言绑定，它只与Class文件这种特定的二进制文件格式所关联，这使得任何语言的都可以使用特定的编译器将其源码编译成Class文件，从而在虚拟机上运行。</li></ul><p><div align="center"> <img src="http://pic.yupoo.com/meandni/b630efe6/16c836f2.png" width=""> </div><br></p><p>Java虚拟机提供的语言无关性</p><h1 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h1><ul><li>Class文件是一组以8个字节为基础单位的二进制流（可能是磁盘文件，也可能是类加载器直接生成的），各个数据项目严格按照顺序紧凑地排列，中间没有任何分隔符；</li><li>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，其中只有两种数据类型：无符号数和表；</li><li>无符号数属于基本的数据类型，以u1、u2、u4和u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值；</li><li>表是由多个无符号数获取其他表作为数据项构成的复合数据类型，习惯以“_info”结尾；</li><li>无论是无符号数还是表，当需要描述同一个类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据未某一类型的集合。</li></ul><p><div align="center"> <img src="http://pic.yupoo.com/meandni/0afa8e94/1aaadf08.png" width=""> </div><br></p><p>下面我以自己本机写的一个简单的Java文件来学习其中各个部分的含义：</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/65326165/8b3cad31.png" width=""> </div><br>使用javac编译成TestClass.class文件，使用16进制打开：</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/4b862df8/2676ca8a.png" width=""> </div><br></p><p>使用javap命令输出Class文件信息：</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/05bb5ca8/4bcf1947.png" width=""> </div><br></p><h4 id="魔数和版本（magic、version）"><a href="#魔数和版本（magic、version）" class="headerlink" title="魔数和版本（magic、version）"></a>魔数和版本（magic、version）</h4><ul><li>Class文件的头4个字节，唯一作用是确定文件是否为一个可被虚拟机接受的Class文件，固定为“0xCAFEBABE”。</li><li>第5和第6个字节是次版本号，第7和第8个字节是主版本号（0x0034为52，对应JDK版本1.8）；能向下兼容之前的版本，无法运行后续的版本；</li></ul><h4 id="常量池（constant-pool）"><a href="#常量池（constant-pool）" class="headerlink" title="常量池（constant_pool）"></a>常量池（constant_pool）</h4><ul><li>常量池可以理解为Class文件之中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项之一；</li><li>由于常量池中的常量数量不固定，因此需要在常量池前放置一项u2类型的数据来表示容量，该值是从1开始的，上图的0x0013为十进制的19，代表常量池中有18项常量，索引值范围为1~18；</li><li>常量池主要存放两大类常量：字面量（Literal，比较接近Java的常量概念，比如文本字符串和final常量等）和符号引用（Symbolic References，主要包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）；</li><li>Java代码在javac编译时不会有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接；所以在Class文件不会保存各个方法、字段和最终内存布局信息；当虚拟机运行时需要从常量池获取对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中；</li><li>JDK 1.7中常量池共有14种不同的表结构数据，这些表结构开始的第一位是一个u1类型的标志位，代表当前常量的类型，具体如下图所示：</li></ul><p><div align="center"> <img src="http://pic.yupoo.com/meandni/81488f7b/0de93189.png" width=""> </div><br></p><ul><li>之所以说常量池是最繁琐的数据就是因为这14种常量类型都有自己的结结构。可以结合下图中各个表结构的说明和之前使用javap解析的文件内容一起看。</li></ul><p><div align="center"> <img src="http://pic.yupoo.com/meandni/ecd4f473/607e8836.png" width=""> </div><br></p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/d7e0e573/94dbf52c.png" width=""> </div><br></p><ul><li>第1项：0x0A（15标志为方法句柄），0x0004（指向第4项的类描述符），0x000F（指向第15项的名称及类型描述符）；</li><li>第2项：0x09（9标志为字段符号引用），0x0003（指向第3项类描述符），0x0010（指向第16项的名称及类型描述符）；</li><li>第3项：0x07（7标志为类符号引用），0x0011（指向第17项全限定名常量项）；</li><li>第4项：0x07（7标志为类符号引用），0x0012（指向第18项全限定名常量项）；</li><li>第5项：0x01（1标志为UTF-字符串常量），0x0001（字符串占用1个字节），6D（字符“m”）；</li><li>第6项：0x01（1标志为UTF-字符串常量），0x0001（字符串占用1个字节），49（字符“I”）；</li><li>第7项：0x01（1标志为UTF-字符串常量），0x0006（字符串占用6个字节），3C 69 6E 69 74 3E（字符“<init>”）；</init></li><li>第8项：0x01（1标志为UTF-字符串常量），0x0003（字符串占用3个字节），28 29 56（字符“()V”）；</li><li>第9项：0x01（1标志为UTF-字符串常量），0x0004（字符串占用4个字节），43 6F 64 65（字符“Code”）；</li><li>第10项：0x01（1标志为UTF-字符串常量），0x000F（字符串占用15个字节），4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65（字符“LineNumberTable”）；</li><li>第11项：0x01（1标志为UTF-字符串常量），0x0003（字符串占用3个字节），69 6E 63（字符“inc”）；</li><li>第12项：0x01（1标志为UTF-字符串常量），0x0003（字符串占用3个字节），28 29 49（字符“()I”）；</li><li>第13项：0x01（1标志为UTF-字符串常量），0x000A（字符串占用10个字节），53 6F 75 72 63 65 46 69 6C 65（字符“SourceFile”）；</li><li>第14项：0x01（1标志为UTF-字符串常量），0x000E（字符串占用14个字节），54 65 73 74 43 6C 61 73 73 2E 6A 61 76 61（字符“TestClass.java”）；</li><li>第15项：0x0C（12标志为名称和类型符号引用），0x0007（指向第7项名称常量项）， 0x0008（指向第8项描述符常量项）；</li><li>第16项：0x0C（12标志为名称和类型符号引用），0x0005（指向第5项名称常量项）， 0x0006（指向第6项描述符常量项）；</li><li>第17项：0x01（1标志为UTF-字符串常量），0x001F（字符串占用31个字节），63 6F 6D 2F 67 69 6E 6F 62 65 66 75 6E 6E 79 2F 63 6C 61 7A 7A 2F 54 65 73 74 43 6C 61 73 73（字符“com/ginobefunny/clazz/TestClas”）；</li><li>第18项：0x01（1标志为UTF-字符串常量），0x0010（字符串占用16个字节），6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74（字符“java/lang/Object”）；</li></ul><h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><ul><li>紧接在常量池后面的是两个字节的访问标志，用于标识类或接口的访问信息；</li><li>访问标志一个有16个标志位，但目前只采用了其中8位，本例子中的0x0021标识为一个public的普通类；</li></ul><h4 id="类索引、父类索引与接口索引集合"><a href="#类索引、父类索引与接口索引集合" class="headerlink" title="类索引、父类索引与接口索引集合"></a>类索引、父类索引与接口索引集合</h4><ul><li>类索引：u2类型的数据，用于确定类的全限定名。本例子中为0x0003，指向常量池中第3项；</li><li>父类索引：u2类型的数据，用于确定父类的全限定名。本例子中为0x0004，指向常量池中第4项；</li><li>接口索引计算器：u2类型的数据，用于表示索引集合的容量。本例子中为0x0000，说明没有实现接口；</li><li>接口索引集合：一组u2类型的数据的集合，用于确定实现的接口（对于接口来说就是extend的接口）。本例子不存在。</li></ul><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/57c3e621/bd0f2fcb.png" width=""> </div><br></p><ul><li>用于描述接口或者类中声明的变量，包括类级变量和实例级变量，但不包括方法内部声明的局部变量；它不会列出从父类和超类继承而来的字段；</li><li>0x0001表示这个类只有一个字段表数据；</li><li>字段修饰符放在access_flag中，是一个u2的数据类型，0x0002表示为private的属性；</li><li>字段名称name_index，是一个u2的数据类型，0x0005表示该属性的名称为常量池的第5项；</li><li>字段描述符descriptor_index，是一个u2的数据类型，0x0006表示该属性的描述符为常量池的第6项，其值“I”表示类型为整形；</li><li>字段属性计算器和属性集合：0x0000表示该例子中不存在；</li></ul><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><ul><li>和字段表集合的方式几乎一样；</li><li>方法里面的代码经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为Code的属性里面；</li><li>0x0002表示这个类有两个方法表数据，分别是编译器添加的实例构造器<init>和源码中的方式inc()；</init></li><li>第一个方法的访问标志是0x0001（public方法），名称索引值为0x0007（常量池第7项，“<init>”），描述符索引值为0x0008（常量池第8项，“()V”），属性表计算器为0x0001（有一项属性），属性名称索引为0x0009（常量池第9项，“Code”）；</init></li><li>根据“6.3.7.1 Code属性”说明，属性值的长度为23（0x0000001D表示29，但需要减去属性名称索引和属性长度固定的6个字节长度），操作数栈深度的最大值为1（0x0001，虚拟机运行时根据这个值来分配栈帧中操作栈深度），局部变量表所需要的存储空间为1个Slot（0x0001，Slot是内存分配的最小单位），字节码长度为5（0x00000005），分别为2A（aload_0，将第0个Slot中为reference类型的本地变量推送到操作数栈顶）、B7（invokespecial，以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者它父类的方法，后面接着一个u2的参数指向常量池的方法引用）、0x0001（表示常量池的第1项，即Object类的<init>方法）、B1（对应的指令为return，返回值为void）；显式异常表为空（0x0000，计数器为0）；该Code属性还内嵌1个属性（0x0001），属性的名称索引为0x000A（即“LineNumberTable”属性，用于记录对应的代码行数），该内嵌属性的长度为6（0x00000006），对应的行数信息为源码的第3行（0x000100000003）；</init></li><li>第二个方法的访问标志是0x0001（public方法），名称索引值为0x000B（常量池第11项，“inc”），描述符索引值为0x000C（常量池第12项，“()I”），属性表计算器为0x0001（有一项属性），属性名称索引为0x0009（常量池第9项，“Code”）；</li><li>根据“6.3.7.1 Code属性”说明，属性值的长度为25（0x0000001F表示31，但需要减去属性名称索引和属性长度固定的6个字节长度），操作数栈深度的最大值为2（0x0002），局部变量表所需要的存储空间为1个Slot（0x0001），字节码长度为7（0x00000007），分别为2A（aload_0）、B4（getfield，后面接着一个u2的参数指向常量池的属性引用）、0x0002（表示常量池的第2项，即TestClass类的m属性）、04（对应的指令为iconst_1）、60（对应的指令为iadd，整形求和）、AC（对应的指令为ireturn，返回值为整形）；显式异常表为空（0x0000，计数器为0）；该Code属性还内嵌1个属性（0x0001），属性的名称索引为0x000A（即“LineNumberTable”属性，用于记录对应的代码行数），该内嵌属性的长度为6（0x00000006），对应的行数信息为源码的第8行（0x000100000008）；</li></ul><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><ul><li>在Class文件、字段表、方法表都可以携带自己的属性表集合；</li><li>属性表集合的限制较为宽松，不再要求严格的顺序，只要属性名不重复即可；</li><li>以下是Java虚拟机规范里预定义的虚拟机实现应当能识别的属性：</li></ul><p><div align="center"> <img src="http://pic.yupoo.com/meandni/8f0a69c4/90a97e5a.png" width=""> </div><br></p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/4faf2ec0/e70f3e68.png" width=""> </div><br></p><p>虚拟机规范预定义的属性2</p><ul><li>接着我们的例子的Class文件还有最后一段：0x0001表示该Class有一个属性，0x000D表示属性名索引为第13项（对应“SourceFile”），0x00000002表示该属性长度为2，0x000E表示该类的SourceFile名称为第14项（对应“TestClass.java”）。</li></ul><h5 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h5><p>Java程序方法体中的代码经过javac编译后，字节码指令存放在Code属性，其属性表结构如下：</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/c7da9cd4/f4e72867.png" width=""> </div><br></p><h5 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h5><p>方法描述时throws关键字后面列举的异常，和Code属性里的异常表不同。其属性表结构如下：</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/c92bfd15/ce2d3cf7.png" width=""> </div><br></p><h5 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h5><p>用于描述Java源码行号与字节码行号之间的对应关系，它不是必须的，可以通过javac -g:none取消该信息。没有该信息的影响是运行时抛异常不会显示出错的行号，在代码调试时无法按照源码行来设置断点。</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/63fd6dbe/c879e713.png" width=""> </div><br></p><h5 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h5><p>用于描述栈帧中局部变量与Java源码中定义的变量之间的关系，它不是运行时必须的，可以通过javac -g:none取消该信息。如果没有这个属性，所有的参数名称都会丢失，取之以arg0、arg1这样的占位符来替代。</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/547e1b38/aa184bbf.png" width=""> </div><br></p><p>其中local_variable_info项代表了一个栈帧与源码中局部变量的关联，如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3709321-ff864df8cdb95d59.png?imageMogr2/auto-orient/" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h5 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h5><p>用于记录生成这个Class的源码文件名称，这个属性也是可选的。</p><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-0433c421ea6631bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/888/format/webp" alt="img"></p><h5 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h5><p>作用是通知虚拟机自动为静态变量赋值，只有被static关键字修饰的变量才可以用这个属性。对于非static类型的变量的赋值是在实例构造器<init>方法中进行的；而对于类变量有两种方式：在类构造器<clinit>方法中或者使用ConstantValue属性。目前Sun javac编译器的选择是：同时使用final和static修饰的变量且为基本数据类型或String类型使用ConstantValue属性初始化，否则使用<clinit>初始化。</clinit></clinit></init></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3709321-0433c421ea6631bd.png?imageMogr2/auto-orient/" alt="ConstantValue属性" title="">                </div>                <div class="image-caption">ConstantValue属性</div>            </figure><h5 id="InnerClass属性"><a href="#InnerClass属性" class="headerlink" title="InnerClass属性"></a>InnerClass属性</h5><p>用于记录内部类与宿主类之间的关联。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/3709321-084cd6c878ad90e3.png?imageMogr2/auto-orient/" alt="InnerClass属性" title="">                </div>                <div class="image-caption">InnerClass属性</div>            </figure><p>其中number_of_class代表需要记录多少个内部类信息，每个内部类的信息都由一个inner_class_info表进行描述。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-e4ed4191050b93ae.png" alt="inner_class_info表的结构" title="">                </div>                <div class="image-caption">inner_class_info表的结构</div>            </figure><h5 id="Deprecated及Synthetic属性"><a href="#Deprecated及Synthetic属性" class="headerlink" title="Deprecated及Synthetic属性"></a>Deprecated及Synthetic属性</h5><p>Deprecated（不推荐使用）和Synthetic（不是由Java源码直接产生编译器自行添加的，有两个例外是实例构造器<init>和类构造器<clinit>）这两个属性都属于布尔属性，只存在有和没有的区别，没有属性值的概念。在属性结构中attribute_length的数据值必须为0x00000000。</clinit></init></p><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-7eee2ac1a903c987.png" alt="Deprecated及Synthetic属性"></p><h5 id="StackMapTable属性"><a href="#StackMapTable属性" class="headerlink" title="StackMapTable属性"></a>StackMapTable属性</h5><p>这是一个复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p><p><img src="https:////upload-images.jianshu.io/upload_images/3709321-ffb7cc6ecb3d041b.png" alt="StackMapTable属性"></p><h5 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h5><p>一个可选的定长属性，在JDK 1.5发布后增加的，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或参数化类型，则Signature属性会为它记录泛型签名信息。这主要是因为Java的泛型采用的是擦除法实现的伪泛型，在字节码中泛型信息编译之后统统被擦除，在运行期无法将泛型类型与用户定义的普通类型同等对待。通过Signature属性，Java的反射API能够获取泛型类型。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https:////upload-images.jianshu.io/upload_images/3709321-1412b798df574705.png" alt="Signature属性" title="">                </div>                <div class="image-caption">Signature属性</div>            </figure><h5 id="BootstrapMethods属性"><a href="#BootstrapMethods属性" class="headerlink" title="BootstrapMethods属性"></a>BootstrapMethods属性</h5><p>一个复杂的变长属性，位于类文件的属性表中，用于保存invokedynamic指令引用的引导方法限定符。</p><h1 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h1><p>Java虚拟机的指令由一个字节长度的、代表着特定操作含义的数字（操作码）以及跟随其后的零至多个代表此操作所需参数（称为操作数）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数，只有一个操作码。</p><p>在指令集中大多数的指令都包含了其操作所对应的数据类型信息，如iload指令用于从局部变量表中加载int类型的数据到操作数栈中。</p><ul><li>加载和存储指令：iload/iload_<n>等（加载局部变量到操作栈）、istore/istore_<n>等（从操作数栈存储到局部变量表）、bipush/sipush/ldc/iconst_<n>（加载常量到操作数栈）、wide（扩充局部变量表访问索引）；</n></n></n></li><li>运算指令：没有直接支持byte、short、char和boolean类型的算术指令而采用int代替；iadd/isub/imul/idiv加减乘除、irem求余、ineg取反、ishl/ishr位移、ior按位或、iand按位与、ixor按位异或、iinc局部变量自增、dcmpg/dcmpl比较；</li><li>类型转换指令：i2b/i2c/i2s/l2i/f2i/f2l/d2i/d2l/d2f；</li><li>对象创建与访问指令：new创建类实例、newarray/anewarray/multianewarray创建数组、getfield/putfield/getstatic/putstatic访问类字段或实例字段、baload/iaload/aaload把一个数组元素加载到操作数栈、bastore/iastore/aastore将一个操作数栈的值存储到数组元素中、arraylength取数组长度、instanceof/checkcast检查类实例类型；</li><li>操作数栈管理指令：pop/pop2一个或两个元素出栈、dup/dup2复制栈顶一个或两个数组并将复制值或双份复制值重新压力栈顶、swap交互栈顶两个数值；</li><li>控制转移指令：ifeq/iflt/ifnull条件分支、tableswitch/lookupswitch复合条件分支、goto/jsr/ret无条件分支；</li><li>方法调用和返回指令：invokevirtual/invokeinterface/invokespecial/invokestatic/invokedynamic方法调用、ireturn/lreturn/areturn/return方法返回；</li><li>异常处理指令：athrow</li><li>同步指令：monitorenter/monitorexit</li></ul><h1 id="公有设计和私有实现"><a href="#公有设计和私有实现" class="headerlink" title="公有设计和私有实现"></a>公有设计和私有实现</h1><ul><li>Java虚拟机的实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的含义；</li><li>但一个优秀的虚拟机实现，通常会在满足虚拟机规范的约束下具体实现做出修改和优化；</li><li>虚拟机实现的方式主要有两种：将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集或宿主主机CPU的本地指令集。</li></ul><h1 id="Class文件结构的发展"><a href="#Class文件结构的发展" class="headerlink" title="Class文件结构的发展"></a>Class文件结构的发展</h1><ul><li>Class文件结构一直比较稳定，主要的改进集中向访问标志、属性表这些可扩展的数据结构中添加内容；</li><li>Class文件格式所具备的平台中立、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱；</li></ul><h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h1><p>本章详细讲解了Class文件结构的各个部分，通过一个实例演示了Class的数据是如何存储和访问的，后面的章节将以动态的、运行时的角度去看看字节码在虚拟机执行引擎是怎样被解析执行的。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。&lt;/p&gt;
&lt;p&gt;由于最近十年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读" scheme="https://meandni.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="jvm" scheme="https://meandni.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>实战中学习Flutter2：打造一款通用的APPUI结构，从此走上人生巅峰！</title>
    <link href="https://meandni.com/2019/01/12/flutter-practice2/"/>
    <id>https://meandni.com/2019/01/12/flutter-practice2/</id>
    <published>2019-01-12T13:43:40.000Z</published>
    <updated>2019-04-12T06:05:37.672Z</updated>
    
    <content type="html"><![CDATA[<p>打造一款通用的AppUI结构，包括登录、注册、首页及各中共用部分，最后能够构成一款完整的APP，目前还在完善，希望大家一起加入。</p><p>引用我在<a href="https://github.com/MeandNi/AndroidEfficientBaseUtils" target="_blank" rel="noopener">AndroidEfficientBaseUtils</a>说过的话，相当于给你一个完完整整地漂亮的盒子，你只需把自己需要的东西放进去就好。而且这是跨平台的呀。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/MeandNi/flutter_commonApp/raw/master/show/appshow.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="结构清单"><a href="#结构清单" class="headerlink" title="结构清单"></a>结构清单</h2><ul><li style="list-style: none"><input type="checkbox" checked> Welcome - 首页</li><li style="list-style: none"><input type="checkbox" checked> Login - 登录</li><li style="list-style: none"><input type="checkbox"> Register - 注册</li><li style="list-style: none"><input type="checkbox" checked> Home - 首页</li><li style="list-style: none"><input type="checkbox"> Personal information - 个人信息</li><li style="list-style: none"><input type="checkbox"> ….</li></ul><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><ul><li>Yangjiakang, <a href="https://github.com/MeandNi/flutter_commonApp" target="_blank" rel="noopener"><strong>MeandNi</strong></a></li><li><p>….</p></li><li><p>相信这一套结构可以适用于大部分App（当然自己要根据需求修改。），这里追求的是通用而不是花哨的效果。</p></li></ul><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><a href="https://github.com/MeandNi/flutter_commonApp" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打造一款通用的AppUI结构，包括登录、注册、首页及各中共用部分，最后能够构成一款完整的APP，目前还在完善，希望大家一起加入。&lt;/p&gt;
&lt;p&gt;引用我在&lt;a href=&quot;https://github.com/MeandNi/AndroidEfficientBaseUtils
      
    
    </summary>
    
      <category term="原创" scheme="https://meandni.com/categories/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="技术" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解Java虚拟机》笔记3——7种垃圾收集器</title>
    <link href="https://meandni.com/2019/01/11/jvm_note3/"/>
    <id>https://meandni.com/2019/01/11/jvm_note3/</id>
    <published>2019-01-11T03:50:40.000Z</published>
    <updated>2019-04-12T06:05:40.820Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://meandni.com/2019/01/05/winter_vacation/">2019大三的寒假计划</a>——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳实践》，这一系列是通过对原文的拜读与自己理解加上网络上的资料文章整理出的读书笔记。</p></blockquote><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。**Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。接下来讨论的收集器基于JDK1.7 Update 14 之后的HotSpot虚拟机（在此版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），该虚拟机包含的所有收集器如下图所示：</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/e8793494/27df7474.jpg" width=""> </div><br></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul><li><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。</li></ul><h4 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h4><p>吞吐量就是<strong>CPU用于运行用户代码的时间</strong>与<strong>CPU总消耗时间</strong>的比值，即</p><p><strong>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</strong></p><p>假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><h4 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h4><ul><li><strong>新生代GC（Minor GC）</strong>：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。具体原理见上一篇文章。</li><li><strong>老年代GC（Major GC / Full GC）</strong>：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h1 id="各收集器阐述"><a href="#各收集器阐述" class="headerlink" title="各收集器阐述"></a>各收集器阐述</h1><h4 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/5c861f07/b1ac068e.jpg" width=""> </div><br></p><p>Serial 翻译为串行，也就是说它以串行的方式执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 模式下的默认新生代收集器，因为在该应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><h4 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. ParNew 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/a5c6e277/481e1ca1.jpg" width=""> </div><br></p><p>它是 Serial 收集器的多线程版本。</p><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p><h4 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. Parallel Scavenge 收集器</h4><p>与 ParNew 一样是多线程收集器。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h4 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. Serial Old 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/14f72c5c/367020d3.jpg" width=""> </div><br></p><p>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><h4 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. Parallel Old 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/2d1989e5/6e965e83.jpg" width=""> </div><br></p><p>是 Parallel Scavenge 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h4 id="6-CMS-收集器"><a href="#6-CMS-收集器" class="headerlink" title="6. CMS 收集器"></a>6. CMS 收集器</h4><p><div align="center"> <img src="http://pic.yupoo.com/meandni/14f72c5c/367020d3.jpg" width=""> </div><br></p><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h4 id="7-G1-收集器"><a href="#7-G1-收集器" class="headerlink" title="7. G1 收集器"></a>7. G1 收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/400d294e/1d022e13.png" width="600"> </div><br></p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/5393369d/5f8cbd42.png" width="600"> </div><br></p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p><div align="center"> <img src="http://pic.yupoo.com/meandni/ce8ef9fc/10c8999f.jpg" width=""> </div><br></p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">收集器</th><th style="text-align:center">串行、并行or并发</th><th style="text-align:center">新生代/老年代</th><th style="text-align:center">算法</th><th style="text-align:center">目标</th><th>适用场景</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><strong>Serial</strong></td><td style="text-align:center">串行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td>单CPU环境下的Client模式</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>Serial Old</strong></td><td style="text-align:center">串行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">响应速度优先</td><td>单CPU环境下的Client模式、CMS的后备预案</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>ParNew</strong></td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">响应速度优先</td><td>多CPU环境时在Server模式下与CMS配合</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>Parallel Scavenge</strong></td><td style="text-align:center">并行</td><td style="text-align:center">新生代</td><td style="text-align:center">复制算法</td><td style="text-align:center">吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>Parallel Old</strong></td><td style="text-align:center">并行</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-整理</td><td style="text-align:center">吞吐量优先</td><td>在后台运算而不需要太多交互的任务</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>CMS</strong></td><td style="text-align:center">并发</td><td style="text-align:center">老年代</td><td style="text-align:center">标记-清除</td><td style="text-align:center">响应速度优先</td><td>集中在互联网站或B/S系统服务端上的Java应用</td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><strong>G1</strong></td><td style="text-align:center">并发</td><td style="text-align:center">both</td><td style="text-align:center">标记-整理+复制算法</td><td style="text-align:center">响应速度优先</td><td>面向服务端应用，将来替换CMS</td><td></td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank" rel="noopener">CS-Note——Java：java虚拟机</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://meandni.com/2019/01/05/winter_vacation/&quot;&gt;2019大三的寒假计划&lt;/a&gt;——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读" scheme="https://meandni.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="jvm" scheme="https://meandni.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解java虚拟机》笔记2——GC算法与内存分配策略</title>
    <link href="https://meandni.com/2019/01/11/jvm_note2/"/>
    <id>https://meandni.com/2019/01/11/jvm_note2/</id>
    <published>2019-01-11T03:16:01.000Z</published>
    <updated>2019-04-12T06:05:43.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://meandni.com/2019/01/05/winter_vacation/">2019大三的寒假计划</a>——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳实践》，这一系列是通过对原文的拜读与自己理解加上网络上的资料文章整理出的读书笔记。</p></blockquote><p>说起<strong>垃圾收集（Garbage Collection, GC）</strong>，想必大家都不陌生，它是JVM实现里非常重要的一环，JVM成熟的内存动态分配与回收技术使Java（当然还有其他运行在JVM上的语言，如Scala等）程序员在提升开发效率上获得了惊人的便利。理解GC，对于理解JVM和Java语言有着非常重要的作用。并且当我们需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，只有深入理解GC和内存分配，才能对这些“自动化”的技术实施必要的监控和调节。</p><p>在Java的运行时数据区中，程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，随线程而生，随线程而灭，在方法结束或线程结束时，内存自然就跟着回收了，不需要过多考虑回收的问题。而<strong>Java堆</strong>和<strong>方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器关注的是这部分内存，后续讨论的“内存”分配回收也是指这一块，尤其需要注意。</p><p>GC主要回答了以下三个问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>这三个问题的具体解决方案，也就是本文接下来要讲解的内容。</p><h1 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h1><p>在堆里存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，首要的就是确定这些对象中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法是在JVM中被摒弃的一种对象存活判定算法，不过它也有一些知名的应用场景（如Python、FlashPlayer），因此在这里也简单介绍一下。</p><p>用引用计数器判断对象是否存活的过程是这样的：<strong>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。</strong></p><p>引用计数算法的实现简单，判定效率也很高，大部分情况下是一个不错的算法。它没有被JVM采用的原因是<strong>它很难解决对象之间循环引用的问题</strong>。例如以下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * testGC()方法执行后，objA和objB会不会被GC呢？ </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，对象objA 和对象objB都有字段instance，赋值令<code>objA.instance = objB;</code>、<code>objB.instance = objA;</code>，除此之外，这两个对象再无引用。如果JVM采用引用计数算法来管理内存，<strong>这两个对象不可能再被访问，但是他们互相引用着对方，导致它们引用计数不为0，所以引用计数器无法通知GC收集器回收它们</strong>。</p><p>而事实上执行这段代码，objA和objB是可以被回收的，下面一节将介绍JVM实际使用的存活判定算法。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>在主流商用程序语言的实现中，都是通过<strong>可达性分析（tracing GC）</strong>来判定对象是否存活的。此算法的基本思路是：通过一系列的称为<strong>“GC Roots”</strong>的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为<strong>引用链（Reference Chain）</strong>，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是GC Roots 到这个对象不可达）时，则证明此对象时不可用的。用下图来加以说明：</p><center><img src="https://pic.yupoo.com/crowhawk/5d0246eb/0635cbe8.png"></center><p>上图中，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p><p>可以看到，GC Roots在对象图之外，是特别定义的<strong>“起点”</strong>，不可能被对象图内的对象所引用。</p><p>准确地说，<strong>GC Roots其实不是一组对象，而通常是一组特别管理的指向引用类型对象的指针</strong>，这些指针是tracing GC的trace的起点。它们不是对象图里的对象，对象也不可能引用到这些“外部”的指针，这也是tracing GC算法不会出现循环引用问题的基本保证。因此也容易得出，<strong>只有引用类型的变量才被认为是Roots，值类型的变量永远不被认为是Roots</strong>。只有深刻理解引用类型和值类型的内存分配和管理的不同，才能知道为什么root只能是引用类型。</p><p>在Java中，可作为GC Roots的对象包括以下几种：</p><ul><li><strong>虚拟机栈（栈帧中的局部变量表，Local Variable Table）</strong>中引用的对象。</li><li><strong>方法区中<em>类静态属性</em></strong>引用的对象。</li><li><strong>方法区中<em>常量</em></strong>引用的对象。</li><li><strong>本地方法栈中JNI（即一般说的Native方法）</strong>引用的对象。</li></ul><p>看到这里你可能要问，选择这些对象的依据是什么呢？</p><p>可以概括得出，可作为GC Roots的节点主要在<strong>全局性的引用</strong>与<strong>执行上下文</strong>中。要明确的是，tracing gc必须<strong>以当前存活的对象集为Roots</strong>，因此必须选取确定存活的引用类型对象。GC管理的区域是Java堆，<strong>虚拟机栈</strong>、<strong>方法区</strong>和<strong>本地方法栈</strong>不被GC所管理，因此选用这些区域内引用的对象作为GC Roots，是<strong>不会被GC所回收</strong>的。其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是GC roots的一部分。</p><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。在JDK1.2之前，Java中的应用定义跟很传统，如若reference类型的数据引用了一块内存地址，则这块内存代表一个引用，这样一个对象仅有被引用或没有被引用两种状态，对于一些“<strong>食之无味，弃之可惜</strong>”的无法描述。</p><p>JDK1.2之后，Java 提供了四种强度不同的引用类型。</p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来实现弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h4 id="两次标记与-finalize-方法"><a href="#两次标记与-finalize-方法" class="headerlink" title="两次标记与 finalize()方法"></a>两次标记与 finalize()方法</h4><p>即使在可达性分析算法中不可达的对象，也不是一定会死亡的，它们暂时都处于<strong>“缓刑”</strong>阶段，要真正宣告一个对象“死亡”，至少要经历两次标记过程：</p><p>如果对象在进行可达性分析后发现没有与 GC Roots相连接的引用链，那它将会被<strong>第一次标记</strong>并且进行一次筛选，筛选的条件是<strong>此对象是否有必要执行<code>finaliza()</code>方法</strong>。当对象没有覆盖<code>finaliza()</code>方法，或者<code>finaliza()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行<code>finaliza()</code>方法，那么此对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发此方法，但并不承诺会等待它运行结束，原因是：如果一个对象在<code>finaliza()</code>方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能导致F-Queue 队列中的其它对象永久处于等待，甚至导致整个内存回收系统崩溃。</p><p><code>finaliza()</code>方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue 队列中的对象进行<strong>第二次小规模的标记</strong>。如果对象想在<code>finaliza()</code>方法中成功拯救自己，<strong>只要重新与引用链上的任何一个对象建立关联即可，例如把自己（this关键字）赋值给某个类变量或者对象的成员变量，这样在第二次标记时它将被移出“即将回收”的集合</strong>；如果对象这时候还没有逃脱，基本上它就真的被回收了。</p><p>值得注意的是，如果代码中有两段一模一样的代码段，执行结果却是一次逃脱成功，一次失败。这是因为任何一个对象的<code>finalize()</code>方法都只会被系统调用一次，如果对象面临下一次回收，它的<code>finalize()</code>方法不会再被执行，因此第二次逃脱行动失败。</p><p>需要说明的是，使用<code>finalize()</code>方法来“拯救”对象是不值得提倡的，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做的一个妥协。<strong>它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</strong><code>finalize()</code>能做的工作，使用<code>try-finally</code>或者其它方法都更适合、及时，所以笔者建议大家可以忘掉此方法存在。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>很多人认为方法区没有垃圾回收，Java虚拟机规范中确实说过不要求，而且在方法区中进行垃圾收集的“性价比”较低：在堆中，尤其是新生代，常规应用进行一次垃圾收集可以回收70%~95%的空间，而方法区的效率远低于此。在JDK 1.8中，JVM摒弃了永久代，用元空间来作为方法区的实现，下面介绍的将是元空间的垃圾回收。</p><p>元空间的内存管理由<strong>元空间虚拟机</strong>来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。<strong>在元空间中，类和其元数据的生命周期</strong>和<strong>其对应的类加载器</strong>是相同的。话句话说，<strong>只要类加载器存活，其加载的类的元数据也是存活的</strong>，因而不会被回收掉。</p><p>我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，<strong>每一个<em>类加载器的存储区域</em>都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。</strong>当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>本节将介绍几种垃圾收集算法的思想及其发展过程，具体的实现将在稍后介绍。</p><h4 id="标记－清除（Mark-Sweep）算法"><a href="#标记－清除（Mark-Sweep）算法" class="headerlink" title="标记－清除（Mark-Sweep）算法"></a>标记－清除（Mark-Sweep）算法</h4><p><strong>标记－清除（Mark-Sweep）</strong>算法是最基础的垃圾收集算法，后续的收集算法都是基于它的思路并对其不足进行改进而得到的。顾名思义，算法分成“标记”、“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程在前一节讲述对象标记判定时已经讲过了。</p><p>标记－清除算法的不足主要有以下两点：</p><ul><li><strong>空间问题</strong>，标记清除之后会产生大量不连续的<strong>内存碎片</strong>，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li><li><strong>效率问题</strong>，因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。</li></ul><p>标记－清除算法的执行过程如下图所示：</p><center><img src="https://pic.yupoo.com/crowhawk/5a3494ae/efc6204a.png"></center><h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h4><p>为了解决标记-清除算法的效率问题，一种称为<strong>“复制”（Copying）</strong>的收集算法出现了，思想为：它<strong>将可用内存按容量分成大小相等的两块</strong>，每次只使用其中的一块。<strong>当这一块内存用完，就将还存活着的对象复制到另一块上面</strong>，然后再把已使用过的内存空间一次清理掉。</p><p>这样做使得<strong>每次都是对整个半区进行内存回收</strong>，内存分配时也就<strong>不用考虑内存碎片</strong>等复杂情况，只要<strong>移动堆顶指针，按顺序分配内存</strong>即可，实现简单，运行高效。只是这种算法的代价是<strong>将内存缩小为原来的一半</strong>，代价可能过高了。复制算法的执行过程如下图所示：</p><center><img src="https://pic.yupoo.com/crowhawk/62b8a3a8/f1cada8a.png"></center><big><strong>Minor GC与复制算法</strong></big><p><strong>现在的商业虚拟机都使用复制算法来回收新生代。</strong>新生代的GC又叫<strong>“Minor GC”</strong>，IBM公司的专门研究表明：新生代中的对象98%是<strong>“朝生夕死”</strong>的，所以Minor GC非常频繁，一般回收速度也比较快，同时<strong>“朝生夕死”</strong>的特性也使得Minor GC使用复制算法时不需要按照1:1的比例来划分新生代内存空间。</p><big><strong>Minor GC过程</strong></big><p>事实上，新生代将内存分为<strong>一块较大的Eden空间</strong>和<strong>两块较小的Survivor空间（From Survivor和To Survivor）</strong>，<strong>每次Minor GC都使用Eden和From Survivor</strong>，当回收时，<strong>将Eden和From Survivor中还存活着的对象都一次性地复制到另外一块To Survivor空间上</strong>，最后清理掉Eden和刚使用的Survivor空间。<strong>一次Minor GC结束的时候</strong>，<strong>Eden</strong>空间和<strong>From Survivor</strong>空间都是空的，而<strong>To Survivor</strong>空间里面存储着存活的对象。<strong>在下次MinorGC的时候</strong>，两个Survivor空间交换他们的标签，现在是空的<strong>“From” Survivor</strong>标记成为<strong>“To”</strong>，<strong>“To” Survivor</strong>标记为<strong>“From”</strong>。因此，在MinorGC结束的时候，Eden空间是空的，两个Survivor空间中的一个是空的，而另一个存储着存活的对象。</p><p>HotSpot虚拟机默认的<strong>Eden : Survivor</strong>的比例是<strong>8 : 1</strong>，由于一共有两块Survivor，所以<strong>每次新生代中可用内存空间为整个新生代容量的90%（80%＋10%）</strong>，只有10%的容量会被“浪费”。</p><big><strong>分配担保</strong></big><p>上文说的98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，<strong>当Survivor空间不够用时</strong>，需要依赖<strong>老年代内存</strong>进行<strong>分配担保（Handle Promotion）</strong>。如果另外一块Survivor上没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><h5 id="标记－整理（Mark-Compact）算法"><a href="#标记－整理（Mark-Compact）算法" class="headerlink" title="标记－整理（Mark-Compact）算法"></a>标记－整理（Mark-Compact）算法</h5><p>复制算法在对象存活率较高时要进行较多的复制操作，效率将会变低。更关键的是：如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在<strong>老年代一般不能直接选用复制算法</strong>。</p><p>根据老年代的特点，<strong>标记－整理（Mark-Compact）</strong>算法被提出来，主要思想为：此算法的标记过程与<strong>标记－清除</strong>算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</strong>具体示意图如下所示：</p><center><img src="https://pic.yupoo.com/crowhawk/d046244a/d3d3277f.png"></center><h5 id="分代收集（Generational-Collection）算法"><a href="#分代收集（Generational-Collection）算法" class="headerlink" title="分代收集（Generational Collection）算法"></a>分代收集（Generational Collection）算法</h5><p>当前商业虚拟机的垃圾收集都采用<strong>分代收集（Generational Collection）算法</strong>，此算法相较于前几种没有什么新的特征，主要思想为：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适合的收集算法：</p><ul><li><strong>新生代</strong><br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。</li><li><strong>老年代</strong><br>在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>“标记-清除”</strong>或<strong>“标记-整理”</strong>算法来进行回收。</li></ul><h1 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h1><p>前面两大节主要从理论上介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。</p><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>从可达性分析中<strong>从GC Roots节点找引用链</strong>这个操作为例，可作为GC Roots的节点主要在<strong>全局性的引用</strong>（例如常量或类静态属性）与<strong>执行上下文</strong>（例如栈帧中的局部变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p><big><strong>GC停顿（”Stop The World”）</strong></big><p>另外，可达性分析工作必须在一个<strong>能确保一致性的快照</strong>中进行——这里<strong>“一致性”</strong>的意思是指<strong>在整个分析期间整个执行系统看起来就像被冻结在某个时间点上</strong>，不可以出现分析过程中对象引用关系还在不断变化的情况，这是保证分析结果准确性的基础。这点是导致GC进行时必须<strong>停顿所有Java执行线程</strong>（Sun将这件事情称为<strong>“Stop The World”</strong>）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p><big><strong>准确式GC与OopMap</strong></big><p>由于目前的主流Java虚拟机使用的都是<strong>准确式GC（即使用准确式内存管理，虚拟机可用知道内存中某个位置的数据具体是什么类型）</strong>，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把<strong>对象内什么偏移量上是什么类型的数据</strong>计算出来，在JIT编译过程中，也会在特定的位置记录下<strong>栈和寄存器中哪些位置是引用</strong>。这样，GC在扫描时就可以直接得知这些信息了。</p><h4 id="安全点（Safepoint）——进行GC时程序停顿的位置"><a href="#安全点（Safepoint）——进行GC时程序停顿的位置" class="headerlink" title="安全点（Safepoint）——进行GC时程序停顿的位置"></a>安全点（Safepoint）——进行GC时程序停顿的位置</h4><p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，<strong>如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</strong></p><p>为此，HotSpot选择不为每条指令都生成OopMap，而是只在“特定的位置”记录这些信息，这些位置便被称为<strong>安全点（Safepoint）</strong>。也就是说，<strong>程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停</strong>。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序<strong>“是否具有让程序长时间执行的特征”</strong>为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是<strong>指令序列复用</strong>，例如<strong>方法调用</strong>、<strong>循环跳转</strong>、<strong>异常跳转</strong>等，所以具有这些功能的指令才会产生Safepoint。</p><p>对于Sefepoint，另一个需要考虑的问题是如何<strong>在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来</strong>。这里有两种方案可供选择：</p><ul><li><strong>抢先式中断（Preemptive Suspension）</strong><br>抢先式中断不需要线程的执行代码主动去配合，<strong>在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。</strong>现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</li><li><strong>主动式中断（Voluntary Suspension）</strong>：<br>主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地<strong>设置一个标志</strong>，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志的地方和安全点是重合的</strong>，另外<strong>再加上创建对象需要分配内存的地方</strong>。</li></ul><h4 id="安全区域（Safe-Region）"><a href="#安全区域（Safe-Region）" class="headerlink" title="安全区域（Safe Region）"></a>安全区域（Safe Region）</h4><p><strong>Safepoint</strong>机制保证了<strong>程序执行时</strong>，在不太长的时间内就会遇到可进入GC的Safepoint。但是，<strong>程序“不执行”的时候（如线程处于Sleep状态或Blocked状态）</strong>，这时线程无法响应JVM的中断请求，“走到”安全的地方去中断挂起，这时候就需要<strong>安全区域（Safe Region）</strong>来解决。</p><p>安全区域是指<strong>在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</strong>我们也可以把Safe Region看做是被扩展了的Safepoint。</p><p>在线程执行到Safe Region中的代码时，首先<strong>标识自己已经进入了Safe Region</strong>，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。<strong>在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程）</strong>，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><p>Java的自动内存管理最终可以归结为自动化地解决了两个问题：</p><ul><li><strong>给对象分配内存</strong></li><li><strong>回收分配给对象的内存</strong></li></ul><p>对象的内存分配通常是在堆上分配（除此以外还有可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是固定的，实际取决于垃圾收集器的具体组合以及虚拟机中与内存相关的参数的设置。至于内存回收策略，在上文已经描述得很详尽了。</p><p>下面以使用Serial/Serial Old收集器（将在下一篇文章中讲解）为例，介绍内存分配的策略。</p><h4 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h4><p>大多数情况下，对象在新生代的Eden区中分配。<strong>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</strong></p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串以及数组。大对象对虚拟机的内存分配来说是一个坏消息（尤其是遇到朝生夕灭的“短命大对象”，写程序时应避免），<strong>经常出现大对象容易导致内存还有不少空间时就提前触发GC以获取足够的连续空间来安置它们</strong>。</p><p>虚拟机提供了一个<strong>-XX:PretenureSizeThreshold</strong>参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是<strong>避免在Eden区及两个Survivor区之间发生大量的内存复制</strong>（新生代采用复制算法回收内存）。</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个<strong>对象年龄（Age）计数器</strong>。<strong>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</strong>对象晋升老年代的年龄阈值，可以通过参数<strong>-XX:MaxTenuringThreshold</strong>设置。</p><h4 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h4><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了<strong>MaxTenuringThreshold</strong>才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无须等到<strong>MaxTenuringThreshold</strong>中要求的年龄。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p><strong>在发生Minor GC之前</strong>，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看<strong>HandlePromotionFailure</strong>设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者<strong>HandlePromotionFailure</strong>设置不允许冒险，那这时也要改为进行一次<strong>Full GC</strong>。</p><p>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此<strong>当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</strong>与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p><p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致<strong>担保失败（Handle Promotion Failure）</strong>。如果出现了<strong>HandlePromotionFailure</strong>失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将<strong>HandlePromotionFailure</strong>开关打开，避免Full GC过于频繁。</p><h1 id="Full-GC的触发条件"><a href="#Full-GC的触发条件" class="headerlink" title="Full GC的触发条件"></a>Full GC的触发条件</h1><p>对于Minor GC，其触发条件非常简单，当Eden区空间满时，就将触发一次Minor GC。而Full GC则相对复杂，因此本节我们主要介绍Full GC的触发条件。</p><h4 id="调用System-gc"><a href="#调用System-gc" class="headerlink" title="调用System.gc()"></a>调用System.gc()</h4><p>此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存，可通过<strong>-XX:+ DisableExplicitGC</strong>来禁止RMI调用System.gc()。</p><h4 id="老年代空间不足"><a href="#老年代空间不足" class="headerlink" title="老年代空间不足"></a>老年代空间不足</h4><p>老年代空间不足的常见场景为前文所讲的<strong>大对象直接进入老年代</strong>、<strong>长期存活的对象进入老年代</strong>等，当执行Full GC后空间仍然不足，则抛出如下错误：<br><code>Java.lang.OutOfMemoryError: Java heap space</code><br>为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p><h4 id="空间分配担保失败"><a href="#空间分配担保失败" class="headerlink" title="空间分配担保失败"></a>空间分配担保失败</h4><p>前文介绍过，使用复制算法的Minor GC需要老年代的内存空间作担保，如果出现了<strong>HandlePromotionFailure</strong>担保失败，则会触发Full GC。</p><h4 id="JDK-1-7及以前的永久代空间不足"><a href="#JDK-1-7及以前的永久代空间不足" class="headerlink" title="JDK 1.7及以前的永久代空间不足"></a>JDK 1.7及以前的永久代空间不足</h4><p>在JDK 1.7及以前，HotSpot虚拟机中的方法区是用永久代实现的，永久代中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：<br><code>java.lang.OutOfMemoryError: PermGen space</code><br>为避免PermGen占满造成Full GC现象，可采用的方法为增大PermGen空间或转为使用CMS GC。</p><p>在JDK 1.8中用元空间替换了永久代作为方法区的实现，元空间是本地内存，因此减少了一种Full GC触发的可能性。</p><h4 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h4><p>执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC），便会报<code>Concurrent Mode Failure</code>错误，并触发Full GC。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文简要地介绍了HotSpot虚拟机如何去发起内存回收的问题，也解答了文章开头提出的三个问题中的前两个——“哪些内存需要回收”和“何时回收”，同时对于第三个问题——“如何回收”，在原理层面作出了解答。在下一篇文章中，笔者将通过介绍几种具体的垃圾收集器，来更深入地回答第三个问题。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank" rel="noopener">CS-Note——Java：java虚拟机</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/index.html" target="_blank" rel="noopener">JVM 垃圾回收器工作原理及使用实例介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://meandni.com/2019/01/05/winter_vacation/&quot;&gt;2019大三的寒假计划&lt;/a&gt;——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读" scheme="https://meandni.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="jvm" scheme="https://meandni.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解java虚拟机》笔记1——Java内存区域与Java对象</title>
    <link href="https://meandni.com/2019/01/10/jvm_note1/"/>
    <id>https://meandni.com/2019/01/10/jvm_note1/</id>
    <published>2019-01-10T03:02:02.000Z</published>
    <updated>2019-04-12T06:05:46.151Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://meandni.com/2019/01/05/winter_vacation/">2019大三的寒假计划</a>——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳实践》，这一系列是通过对原文的拜读与自己理解加上网络上的资料文章整理出的读书笔记。</p></blockquote><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JVM载执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。具体如下图所示：（其中程序计数器、Java虚拟机栈、本地方法栈为线程私有；Java堆、方法区位线程共享的内存区域。）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.yupoo.com/crowhawk/3d24df02/776c8d55.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4><p><strong>程序计数器（Program Counter Register）</strong>是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。在虚拟机概念模型中，<strong>字节码解释器</strong>工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>程序计数器是一块<strong>“线程私有”</strong>的内存，如上文的图所示，每条线程都有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。这样设计使得在多线程环境下，线程切换后能恢复到正确的执行位置。</p><p>如果线程正在执行的是一个<strong>Java方法</strong>，这个计数器记录的是正在执行的<strong>虚拟机字节码指令的地址</strong>；若执行的是<strong>Native方法</strong>，则<strong>计数器为空（Undefined）</strong>（因为对于Native方法而言，它的方法体并不是由Java字节码构成的，自然无法应用上述的“字节码指令的地址”的概念）。程序计数器也是唯一一个在Java虚拟机规范中<strong>没有</strong>规定任何<strong>OutOfMemoryError</strong>情况的内存区域。</p><h4 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h4><p><strong>Java虚拟机栈（Java Virtual Machine Stacks）</strong>描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）</strong>，栈帧中存储着<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。<strong>每一个方法从调用直至执行完成的过程，会对应一个栈帧在虚拟机栈中入栈到出栈的过程。</strong>与程序计数器一样，Java虚拟机栈也是<strong>线程私有</strong>的。</p><p>函数的调用有完美的嵌套关系——调用者的生命期总是长于被调用者的生命期，并且后者在前者的之内。这样，被调用者的局部信息所占空间的分配总是后于调用者的（后入），而其释放则总是先于调用者的（先出），所以正好可以满足栈的LIFO顺序，选用栈这种数据结构来实现调用栈是一种很自然的选择。</p><p><strong>局部变量表</strong>中存放了编译期可知的各种：</p><ul><li><strong>基本数据类型</strong>(boolen、byte、char、short、int、 float、 long、double）</li><li><strong>对象引用</strong>（reference类型，它不等于对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</li><li><strong>returnAddress类型</strong>（指向了一条字节码指令的地址）</li></ul><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>Java虚拟机规范中对这个区域规定了两种异常状况：</p><ul><li><strong>StackOverflowError</strong>：线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常。</li><li><strong>OutOfMemoryError</strong>：当可动态扩展的虚拟机栈在扩展时无法申请到足够的内存，就会抛出该异常。</li></ul><h4 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h4><p><strong>本地方法栈（Native Method Stack）</strong>与Java虚拟机栈作用很相似，它们的区别在于虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>在虚拟机规范中对本地方法栈中使用的语言、方式和数据结构并无强制规定，因此具体的虚拟机可实现它。甚至<strong>有的虚拟机（Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一</strong>。与虚拟机一样，本地方法栈会抛出<strong>StackOverflowError</strong>和<strong>OutOfMemoryError</strong>异常。</p><h4 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h4><p>对于大多数应用而言，<strong>Java堆（Heap）</strong>是Java虚拟机所管理的内存中最大的一块，它<strong>被所有线程共享的</strong>，在虚拟机启动时创建。此内存区域<strong>唯一的目的</strong>是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存，且每次分配的空间是<strong>不定长</strong>的。在Heap 中分配一定的内存来保存对象实例，实际上只是保存<strong>对象实例的属性值</strong>，<strong>属性的类型</strong>和<strong>对象本身的类型标记</strong>等，<strong>并不保存对象的方法（方法是指令，保存在Stack中）</strong>,在Heap 中分配一定的内存保存对象实例和对象的序列化比较类似。对象实例在Heap 中分配好以后，需要<strong>在Stack中保存一个4字节的Heap 内存地址</strong>，用来定位该对象实例在Heap 中的位置，便于找到该对象实例。</p><p>Java虚拟机规范中描述道：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都在堆上分配的定论也并不<strong>“绝对”</strong>了。</p><p>Java堆是垃圾收集器管理的主要区域，因此也被称为<strong>“GC堆（Garbage Collected Heap）”</strong>。从内存回收的角度看内存空间可如下划分：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.yupoo.com/crowhawk/5cf46998/fe5079d3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><ul><li><strong>新生代（Young）</strong>： 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。新生代又可细分为<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>，默认比例为8:1:1。它们的具体作用将在下一篇文章讲解GC时介绍。</li><li><strong>老年代（Tenured/Old）</strong>：在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</li><li><strong>永久代（Perm）</strong>：永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</li></ul><p>其中<strong>新生代和老年代组成了Java堆的全部内存区域</strong>，而<strong>永久代不属于堆空间，它在JDK 1.8以前被Sun HotSpot虚拟机用作方法区的实现</strong>，关于方法区的具体内容将在稍后介绍。</p><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域。<strong>Object Class Data(类定义数据)</strong>是存储在方法区的，此外，<strong>常量</strong>、<strong>静态变量</strong>、<strong>JIT编译后的代码</strong>也存储在方法区。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 <strong>Non-Heap</strong>。</p> <big><strong>JDK 1.8以前的永久代（PermGen）</strong></big><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集，也就是说，Java虚拟机规范只是规定了方法区的概念和它的作用，并没有规定如何去实现它。<strong>对于JDK 1.8之前的版本，HotSpot虚拟机设计团队选择把GC分代收集扩展至方法区，即用永久代来实现方法区</strong>，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他的虚拟机（如<strong>Oracle JRockit</strong>、<strong>IBM J9</strong>等）来说是不存在永久代的概念的。</p><p>如果运行时有大量的类产生，可能会导致方法区被填满，直至溢出。常见的应用场景如：</p><ul><li>Spring和ORM框架使用CGLib操纵字节码对类进行增强，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。</li><li>大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）。</li><li>基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）。<br>……</li></ul><p>这些都会导致方法区溢出，报出<code>java.lang.OutOfMemoryError: PermGen space</code>。</p><big><strong>JDK 1.8的元空间（Metaspace）—— 书中没有的内容</strong></big><p>在JDK 1.8中，HotSpot虚拟机设计团队为了促进<strong>HotSpot</strong>与 <strong>JRockit</strong>的融合，修改了方法区的实现，移除了永久代，选择使用<strong>本地化的内存空间</strong>（而不是JVM的内存空间）存放类的元数据，这个空间叫做<strong>元空间（Metaspace）</strong>。</p><p>做了这个改动以后，<code>java.lang.OutOfMemoryError: PermGen</code>的空间问题将不复存在，并且不再需要调整和监控这个内存空间。且虚拟机需要为方法区设计额外的GC策略：如果类元数据的空间占用达到参数<strong>“MaxMetaspaceSize”</strong>设置的值，将会触发对死亡对象和类加载器的垃圾回收。 为了限制垃圾回收的频率和延迟，适当的监控和调优<strong>元空间</strong>是非常有必要的。元空间过多的垃圾收集可能表示类、类加载器内存泄漏或对你的应用程序来说空间太小了。</p><p>元空间的内存管理由<strong>元空间虚拟机</strong>来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。<strong>在元空间中，类和其元数据的生命周期</strong>和<strong>其对应的类加载器</strong>是相同的。话句话说，<strong>只要类加载器存活，其加载的类的元数据也是存活的</strong>，因而不会被回收掉。</p><p>我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，<strong>每一个<em>类加载器的存储区域</em>都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。</strong>当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p><p><strong>元空间虚拟机</strong>负责元空间的分配，其采用的形式为<strong>组块分配</strong>。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个<strong>全局的空闲组块列表</strong>。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块<strong>是线性分配（指针碰撞分配形式）</strong>。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</p><center><img src="https://pic.yupoo.com/crowhawk/cdaea117/7bdf00c4.png"></center><p>上图展示的是虚拟内存映射区域如何进行元组块的分配。类加载器1和3表明使用了反射或者为匿名类加载器，他们使用了特定大小组块。 而类加载器2和4根据其内部条目的数量使用小型或者中型的组块。</p><big><strong>运行时常量池（Runtime Constant Pool）</strong></big><p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。<strong>Class文件</strong>中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池（Constant Pool Table）</strong>，用于存放编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后进入方法区的运行时常量池存放</strong>。</p><p>Java虚拟机对Class文件每一部分（自然包括常量池）的格式有严格规定，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。但<strong>对于运行时常量池，Java虚拟机规范没有做任何有关细节的要求</strong>，不同的提供商实现的虚拟机可以按照自己的需求来实现此内存区域。不过一般而言，除了保存<strong>Class文件中的描述符号引用</strong>外，还会把<strong>翻译出的直接引用</strong>也存储在运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译器才能产生，也就是<strong>并非置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</strong>，此特性被开发人员利用得比较多的便是String类的<code>intern()</code>方法。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p><strong>直接内存（Direct Memory）</strong>并不是虚拟机<strong>运行时数据区</strong>的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁运用，而却可能导致<strong>OutOfMemoryError</strong>异常出现，所以这里放到一起讲解。</p><p>以<strong>NIO（New Input/Output）</strong>类为例，NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能避免在Java堆和Native堆中来回复制数据，在一些场景里显著提高性能。</p><p>本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，还是会受到本机总内存（包括RAM以及SWAP区或分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现<strong>OutOfMemoryError</strong>异常。</p><h1 id="HotSpot中的对象"><a href="#HotSpot中的对象" class="headerlink" title="HotSpot中的对象"></a>HotSpot中的对象</h1><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p>Java的对象创建大致有如下四种方式：</p><ul><li><strong>new关键字</strong><br>这应该是我们最常见和最常用最简单的创建对象的方式。</li><li><strong>使用<code>newInstance()</code>方法</strong><br>这里包括<strong>Class</strong>类的<code>newInstance()</code>方法和<strong>Constructor</strong>类的<code>newInstance()</code>方法（前者其实也是调用的后者）。</li><li><strong>使用<code>clone()</code>方法</strong><br>要使用<code>clone()</code>方法我们必须实现实现<strong>Cloneable</strong>接口，用<code>clone()</code>方法创建对象并不会调用任何构造函数。即我们所说的<strong>浅拷贝</strong>。</li><li><strong>反序列化</strong><br>要实现反序列化我们需要让我们的类实现<strong>Serializable</strong>接口。当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象，在反序列化时，JVM创建对象并不会调用任何构造函数。即我们所说的<strong>深拷贝</strong>。</li></ul><p>上面的四种创建对象的方法除了第一种使用new指令之外，其他三种都是使用<strong>invokespecial(构造函数的直接调用)</strong>。这里我们只说new创建对象的方式，关于invokespecial的内容将在后续文章中介绍。下面我们来看看当虚拟机遇到new指令的时候对象是如何创建的。</p><big><strong>1. 类加载检查</strong></big><p>虚拟机遇到一条new指令时，首先将去检查<strong>这个指令的参数是否能在常量池中定位到一个类的符号引用</strong>，并且检查<strong>这个符号引用代表的类是否已被加载、解析和初始化过的</strong>，如果没有，则必须先执行相应的类加载过程，关于类加载机制和类加载器的详细内容将在后续文章中介绍。</p><big><strong>2. 分配内存</strong></big><p>在类加载检查通过后，虚拟机就将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定在下一节对象内存布局时再详细讲解），为对象分配空间的任务具体便等同于<strong>从Java堆中划出一块大小确定的内存空间</strong>，可以分如下两种情况讨论：</p><ul><li><strong>Java堆中内存绝对规整</strong><br>所有用过的内存都被放在一边，空闲的内存被放在另一边，<strong>中间放着一个指针作为分界点的指示器</strong>，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为<strong>“指针碰撞”（Bump The Pointer）</strong>。</li><li><strong>Java堆中的内存不规整</strong><br>已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须<strong>维护一个列表，记录哪些内存块是可用的</strong>，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>“空闲列表”（Free List）</strong>。</li></ul><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的<strong>垃圾收集器是否带有压缩整理功能</strong>决定。因此在使用Serial、ParNew等带<strong>Compact</strong>过程的收集器时，系统采用的分配算法是<strong>指针碰撞</strong>，而使用CMS这种基于<strong>Mark-Sweep</strong>算法的收集器时（说明一下，CMS收集器可以通过UseCMSCompactAtFullCollection或CMSFullGCsBeforeCompaction来整理内存），就通常采用<strong>空闲列表</strong>。关于垃圾收集器的具体内容将在下一篇文章中介绍。</p><p>除如何划分可用空间之外，另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也<strong>并非线程安全</strong>的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。解决这个问题有如下两个方案：</p><ul><li><strong>对分配内存空间的动作进行同步</strong><br>实际上虚拟机是采用<strong>CAS</strong>配上<strong>失败重试</strong>的方式保证更新操作的原子性。</li><li><strong>把内存分配的动作按照线程划分在不同的空间之中进行</strong><br>即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲（TLAB ，Thread Local Allocation Buffer）</strong>，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过<strong>-XX:+/-UseTLAB</strong>参数来设定。</li></ul><big><strong>3. 初始化</strong></big><p>内存分配完成之后，虚拟机需要<strong>将分配到的内存空间都初始化为零值（不包括对象头）</strong>，如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。</p><big><strong>4. 设置对象头</strong></big><p>接下来，虚拟机要<strong>设置对象的信息</strong>（如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息）并存放在对象的<strong>对象头（Object Header）</strong>中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，在下一节再详细介绍。</p><big><strong>5. 执行<code>&lt;init&gt;</code>方法</strong></big><p>在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，对象创建才刚刚开始——<code>&lt;init&gt;</code>方法还没有执行，所有的字段都还为零值。所以一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着执行<code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong>和<strong>对齐填充（Padding）</strong>。</p><big><strong>1. 对象头</strong></big><p>HotSpot虚拟机的对象头包括两部分信息：</p><ul><li><strong>对象自身的运行时数据 “Mark Word”</strong><br>如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为<strong>“Mark Word”</strong>。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个<strong>非固定的数据结构</strong>以便在极小的空间内存储尽量多的信息，它会<strong>根据对象的状态复用自己的存储空间</strong>。例如在32位的HotSpot虚拟机中对象<strong>未被锁定</strong>的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下图所示：</li></ul><center><img src="https://pic.yupoo.com/crowhawk/4f006175/8be38542.png"></center><ul><li><strong>类型指针</strong><br>类型指针即<strong>对象指向它的类元数据的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说<strong>查找对象的元数据信息并不一定要经过对象本身</strong>，这点我们在下一节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于<strong>记录数组长度</strong>的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</li></ul><big><strong>2. 实例数据</strong></big><p>实例数据是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p><big><strong>3. 对齐填充</strong></big><p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头部分正好似8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>我们的Java程序需要通过<strong>栈上的对象引用（reference）数据（存储在栈上的局部变量表中）</strong>来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面也只规定了是一个指向对象的引用，并没有定义这个引用的具体实现，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用<strong>句柄</strong>和<strong>直接指针</strong>两种。</p><big><strong>1. 使用句柄访问</strong></big><p>如果使用句柄访问的话，<strong>Java堆中</strong>将会划分出一块内存来作为<strong>句柄池</strong>，reference中存储的就是对象的句柄地址，而句柄中包含了<strong>对象实例数据</strong>与<strong>类型数据</strong>的各自的<strong>具体地址信息</strong>。如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.yupoo.com/crowhawk/af3c02ef/bfd967c5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><big><strong>2. 使用直接指针访问</strong></big><p>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic.yupoo.com/crowhawk/5c1acdb8/f5086a4d.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>这两种对象访问方式各有优势，下面分别来谈一谈：</p><ul><li><strong>句柄</strong><br>使用句柄访问的最大好处就是<strong>reference中存储的是稳定的句柄地址</strong>，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时<strong>只会改变句柄中的实例数据指针，而reference本身不需要被修改</strong>。</li><li><strong>直接指针</strong><br>使用直接指针来访问最大的好处就是<strong>速度更快</strong>，它<strong>节省了一次指针定位的时间开销</strong>，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项 非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，<strong>HotSpot是使用直接指针进行对象访问的</strong>，不过在整个软件开发的范围来 看，各种语言、框架中使用句柄来访问的情况也十分常见。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://meandni.com/2019/01/05/winter_vacation/&quot;&gt;2019大三的寒假计划&lt;/a&gt;——利用在公司每天早起的时间读书，第一本是周志明老师的《深入理解Java虚拟机——JVM高级特性与最佳
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读" scheme="https://meandni.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="jvm" scheme="https://meandni.com/tags/jvm/"/>
    
  </entry>
  
</feed>
