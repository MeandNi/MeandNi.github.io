<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Joker&#39;s Blog</title>
  
  <subtitle>个人分享博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://meandni.com/"/>
  <updated>2020-11-05T14:08:04.627Z</updated>
  <id>https://meandni.com/</id>
  
  <author>
    <name>Joker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter 应用适配（自适应布局组件实践）</title>
    <link href="https://meandni.com/2020/11/05/demystifying-responsive-layout-in-flutter/"/>
    <id>https://meandni.com/2020/11/05/demystifying-responsive-layout-in-flutter/</id>
    <published>2020-11-05T13:57:46.000Z</published>
    <updated>2020-11-05T14:08:04.627Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://medium.com/flutter-community/demystifying-responsive-layout-in-flutter-f85d0014b94e" target="_blank" rel="noopener">Demystifying responsive layout in Flutter</a>，作者：Souvik Biswas，译文首次发表于微信公众号「Meandni」，<a href="https://mp.weixin.qq.com/s/15JMvjuGKkZaq2WEvxlsSQ" target="_blank" rel="noopener">点击阅读</a>。</p></blockquote><p>Flutter 作为现如今应用如此广泛的跨平台开发框架，当然支持各种设备下屏幕的适配。</p><p>而当前，<strong>我们的应用也完全能运行在小如手表，大如电视的设备中</strong>，要实现这么多场景下的适配始终是一个挑战，但 Flutter 或许就能做到。</p><p>在 Flutter 中，设计响应式布局没有官方的硬性规定及标准。本文会向读者们展示设计自适应布局时可以遵循的一些方法。</p><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>在介绍 Flutter 的屏幕适配方案之前，我想先简单说一下在原生 Android 和 iOS 下如何处理不同屏幕尺寸的布局，Android 主要有如下几种方式。</p><h3 id="1-ConstraintLayout"><a href="#1-ConstraintLayout" class="headerlink" title="1. ConstraintLayout"></a>1. ConstraintLayout</h3><p><strong>ConstraintLayout(约束布局)</strong>是 Android 支持的一种功能强大的布局组件，主要功能就是可以灵活地响应不同的手机屏幕尺寸，根据组件间的关系确定各个组件的位置和大小，这其实和 Flutter 内的布局约束概念有点类似。</p><blockquote><p>详情可以参考 ConstraintLayout 官方文档：<strong><a href="https://developer.android.com/training/constraint-layout?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/training/constraint-layout?hl=zh-cn</a></strong></p></blockquote><p>但约束布局也不能解决多种设备的适配场景，因为它只能适应性的调整 UI 组件的大小，长宽，这么做其实并不优雅，而且在写运行在手表之类的屏幕很小的设备上，只调整大小也会使界面看起来给非常奇怪。</p><h3 id="2-替代布局"><a href="#2-替代布局" class="headerlink" title="2. 替代布局"></a>2. 替代布局</h3><p>要解决上述问题，我们可以尝试针对不同大小的设备使用各不相同的布局文件。例如，可以在平板电脑等设备中实现左右<strong>视图分离</strong>，从而充分利用大屏幕下宽敞的屏幕宽度。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*zT0i-H9I9kmbnt81e6yFug-20201105212906223.png" alt=""></p><p>在 Android 中，开发者可以为不同的屏幕尺寸定义<strong>单独的布局文件</strong>，并且 Android 底层也会根据设备的屏幕尺寸自动处理这些布局之间的切换。</p><h3 id="3-Fragment"><a href="#3-Fragment" class="headerlink" title="3. Fragment"></a>3. Fragment</h3><p>合理使用 Fragment，我们可以将 UI 逻辑单独抽离到特定的 Fragment 中，这样在为大屏幕设备设计布局时就可以有效地复用这些逻辑了。</p><h3 id="4-矢量图"><a href="#4-矢量图" class="headerlink" title="4. 矢量图"></a>4. 矢量图</h3><p>矢量图一般由 XML 创建，可以直接定义可配置的 Path 和颜色，相比像素位 bitmaps 更加灵活且高效，在不同尺寸的屏幕下也可以无限放大而不失真。Android 平台中，可以使用 <a href="https://developer.android.com/guide/topics/graphics/vector-drawable-resources" target="_blank" rel="noopener">VectorDrawable</a> 类定义矢量图。</p><h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><p>iOS 下，我们可以使用下面几种方式实现屏幕适配。</p><h3 id="1-Auto-Layout"><a href="#1-Auto-Layout" class="headerlink" title="1. Auto Layout"></a>1. Auto Layout</h3><p>Auto Layout 可以用来在 iOS 平台下构建可适配 UI，我们可以在其中定义控制应用程序内容的规则（或称为<strong>约束</strong>），当在处于某些条件（或者<strong>特征</strong>）时，Auto Layout 就会根据指定的约束条件自动重新调整布局。</p><h3 id="2-Size-类"><a href="#2-Size-类" class="headerlink" title="2. Size 类"></a>2. Size 类</h3><p>Size 类表示根据其大小自动分配给内容区域的特征。这种情况下，iOS 就可以根据内容区域的大小类别动态地进行布局调整。在 iPad 上，当应用处于 multitasking 的配置中运行时，Size 类同样适用。</p><h3 id="3-UI-组件"><a href="#3-UI-组件" class="headerlink" title="3. UI 组件"></a>3. UI 组件</h3><p>在 iOS 上也原生提供了一些天然自适应的 UI 组件，如 <a href="https://developer.apple.com/documentation/uikit/uistackview" target="_blank" rel="noopener">UIStackView</a>，<a href="https://developer.apple.com/documentation/uikit/uiviewcontroller" target="_blank" rel="noopener">UIViewController </a>和 <a href="https://developer.apple.com/documentation/uikit/uisplitviewcontroller" target="_blank" rel="noopener">UISplitViewController</a>。</p><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><p>即使我们不是 Android 或 iOS 开发人者，现在也应该大致熟悉了这两个平台如何处理自适应布局的一些方法了。</p><p>在 Android 中，要在单个屏幕上显示多个 UI 视图，建议使用 <strong>Fragment</strong>，它就相当于在 Activity 中可重用的组件。</p><blockquote><p>在 Android 中，Activity 即代表一个页面，一个 Activity 中可以运行多个 Fragment，但同一个应用下，同时只展示一个 Activity。</p></blockquote><p>在 iOS 中，要控制多个视图控制器（View Controllers），可以使用 UISplitViewController，它在分层界面中可以管理子视图控制器。</p><p>而 Flutter 中天然就存在 “<strong>一切皆为 Widget</strong>” 的概念，整个应用程序也基本都是由 Widget 组合而成的。并且<strong>每个 Widget 都是可以复用的</strong>，因此，想要在 Flutter 中实现屏幕自适应的布局，不需要学习其他任何概念，下面介绍的这些 Widget 应该足够你使用了！</p><h2 id="Flutter-适配组件"><a href="#Flutter-适配组件" class="headerlink" title="Flutter 适配组件"></a>Flutter 适配组件</h2><p>如前所诉，在 Flutter 我们只需要掌握一些 Widget 即可，实际的开发过程中，我们也只需要在合适的地方使用它们即可。下面，我们就一起来看看这些组件分别有什么魔力。</p><h3 id="1-MediaQuery"><a href="#1-MediaQuery" class="headerlink" title="1. MediaQuery"></a>1. MediaQuery</h3><p>我要介绍的第一个 Widget 即是 MediaQuery，通过它可以直接获得屏幕的<strong>大小（宽度/高度）和方向（纵向/横向）</strong>。如下这个示例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    Size screenSize = MediaQuery.of(context).size;</span><br><span class="line">    Orientation orientation = MediaQuery.of(context).orientation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Container(</span><br><span class="line">        color: CustomColors.android,</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">'View\n\n'</span> +</span><br><span class="line">                <span class="string">'[MediaQuery width]: <span class="subst">$&#123;screenSize.width.toStringAsFixed(<span class="number">2</span>)&#125;</span>\n\n'</span> +</span><br><span class="line">                <span class="string">'[MediaQuery orientation]: <span class="subst">$orientation</span>'</span>,</span><br><span class="line">            style: TextStyle(color: Colors.white, fontSize: <span class="number">18</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*pHVt1lSp1ohJwnixNCCd6Q.png" alt=""></p><h3 id="2-LayoutBuilder"><a href="#2-LayoutBuilder" class="headerlink" title="2. LayoutBuilder"></a>2. LayoutBuilder</h3><p>使用 LayoutBuilder 组件，可以获得一个 <a href="https://api.flutter.dev/flutter/rendering/BoxConstraints-class.html" target="_blank" rel="noopener">BoxConstraints</a> 对象，通过该对象我们就可以拿到 Widget 的 <strong>maxWidth（最大宽度） </strong>和<strong>maxHeight（最大高度）</strong></p><blockquote><p>MediaQuery 和 LayoutBuilder 的区别在在于，MediaQuery 得到的是整个屏幕的宽高，而 LayoutBuilder  得到的是特定组件的最大高度和宽度。</p></blockquote><p>如下这个示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HomePage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    Size screenSize &#x3D; MediaQuery.of(context).size;</span><br><span class="line"></span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: Row(</span><br><span class="line">        children: [</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: 2,</span><br><span class="line">            child: LayoutBuilder(</span><br><span class="line">              builder: (context, constraints) &#x3D;&gt; Container(</span><br><span class="line">                color: CustomColors.android,</span><br><span class="line">                child: Center(</span><br><span class="line">                  child: Text(</span><br><span class="line">                    &#39;View 1\n\n&#39; +</span><br><span class="line">                        &#39;[MediaQuery]:\n $&#123;screenSize.width.toStringAsFixed(2)&#125;\n\n&#39; +</span><br><span class="line">                        &#39;[LayoutBuilder]:\n$&#123;constraints.maxWidth.toStringAsFixed(2)&#125;&#39;,</span><br><span class="line">                    style: TextStyle(color: Colors.white, fontSize: 18),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: 3,</span><br><span class="line">            child: LayoutBuilder(</span><br><span class="line">              builder: (context, constraints) &#x3D;&gt; Container(</span><br><span class="line">                color: Colors.white,</span><br><span class="line">                child: Center(</span><br><span class="line">                  child: Text(</span><br><span class="line">                    &#39;View 2\n\n&#39; +</span><br><span class="line">                        &#39;[MediaQuery]:\n $&#123;screenSize.width.toStringAsFixed(2)&#125;\n\n&#39; +</span><br><span class="line">                        &#39;[LayoutBuilder]:\n$&#123;constraints.maxWidth.toStringAsFixed(2)&#125;&#39;,</span><br><span class="line">                    style: TextStyle(color: CustomColors.android, fontSize: 18),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*kpWUG3BylH9VVBgI4tI9wQ.png" alt=""></p><h3 id="3-OrientationBuilder"><a href="#3-OrientationBuilder" class="headerlink" title="3. OrientationBuilder"></a>3. OrientationBuilder</h3><p>要确定当前 Widget 的方向，可以使用 OrientationBuilder 组件。<strong>这里的方向与 MediaQuery 提供的设备方向不同</strong>。如下这个示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HomePage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    Orientation deviceOrientation &#x3D; MediaQuery.of(context).orientation;</span><br><span class="line"></span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: Column(</span><br><span class="line">        children: [</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: 2,</span><br><span class="line">            child: Container(</span><br><span class="line">              color: CustomColors.android,</span><br><span class="line">              child: OrientationBuilder(</span><br><span class="line">                builder: (context, orientation) &#x3D;&gt; Center(</span><br><span class="line">                  child: Text(</span><br><span class="line">                    &#39;View 1\n\n&#39; +</span><br><span class="line">                        &#39;[MediaQuery orientation]:\n$deviceOrientation\n\n&#39; +</span><br><span class="line">                        &#39;[OrientationBuilder]:\n$orientation&#39;,</span><br><span class="line">                    style: TextStyle(color: Colors.white, fontSize: 18),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: 3,</span><br><span class="line">            child: OrientationBuilder(</span><br><span class="line">              builder: (context, orientation) &#x3D;&gt; Container(</span><br><span class="line">                color: Colors.white,</span><br><span class="line">                child: Center(</span><br><span class="line">                  child: Text(</span><br><span class="line">                    &#39;View 2\n\n&#39; +</span><br><span class="line">                        &#39;[MediaQuery orientation]:\n$deviceOrientation\n\n&#39; +</span><br><span class="line">                        &#39;[OrientationBuilder]:\n$orientation&#39;,</span><br><span class="line">                    style: TextStyle(color: CustomColors.android, fontSize: 18),</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*nuUQeXMjzQ8IPRPyGn5n1w.png" alt=""></p><h3 id="4-Expanded-和-Flexible"><a href="#4-Expanded-和-Flexible" class="headerlink" title="4. Expanded 和 Flexible"></a>4. Expanded 和 Flexible</h3><p>Expanded 和 Flexible 这两个组件可以和 Column/Row 搭配使用，来实现非常完美的自适应效果。 Expanded 可以用来拓展 Row, 、Column 和 Flex，从而让子组件填充可用空间，Flexible 功能类似但并不一定能填充全部可用空间。</p><p>下面这个例子演示了混合使用 Expanded 和 Flexible 的各种方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HomePage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      backgroundColor: Colors.white,</span><br><span class="line">      body: SafeArea(</span><br><span class="line">        child: Column(</span><br><span class="line">          children: [</span><br><span class="line">            Row(</span><br><span class="line">              children: [</span><br><span class="line">                ExpandedWidget(),</span><br><span class="line">                FlexibleWidget(),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            Row(</span><br><span class="line">              children: [</span><br><span class="line">                ExpandedWidget(),</span><br><span class="line">                ExpandedWidget(),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            Row(</span><br><span class="line">              children: [</span><br><span class="line">                FlexibleWidget(),</span><br><span class="line">                FlexibleWidget(),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            Row(</span><br><span class="line">              children: [</span><br><span class="line">                FlexibleWidget(),</span><br><span class="line">                ExpandedWidget(),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ExpandedWidget extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Expanded(</span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">          color: CustomColors.android,</span><br><span class="line">          border: Border.all(color: Colors.white),</span><br><span class="line">        ),</span><br><span class="line">        child: Padding(</span><br><span class="line">          padding: const EdgeInsets.all(16.0),</span><br><span class="line">          child: Text(</span><br><span class="line">            &#39;Expanded&#39;,</span><br><span class="line">            style: TextStyle(color: Colors.white, fontSize: 24),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FlexibleWidget extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Flexible(</span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">          color: CustomColors.androidAccent,</span><br><span class="line">          border: Border.all(color: Colors.white),</span><br><span class="line">        ),</span><br><span class="line">        child: Padding(</span><br><span class="line">          padding: const EdgeInsets.all(16.0),</span><br><span class="line">          child: Text(</span><br><span class="line">            &#39;Flexible&#39;,</span><br><span class="line">            style: TextStyle(color: CustomColors.android, fontSize: 24),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*CWOTNVvLVwDkqQ_FRDS3Nw.png" alt=""></p><h3 id="5-FractionallySizedBox"><a href="#5-FractionallySizedBox" class="headerlink" title="5. FractionallySizedBox"></a>5. FractionallySizedBox</h3><p>FractionallySizedBox 组件可以使子组件<strong>填充部分可用空间</strong>，该特性在 Expanded 或 Flexible 中特别有用。示例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HomePage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      backgroundColor: Colors.white,</span><br><span class="line">      body: SafeArea(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line">          children: [</span><br><span class="line">            Row(</span><br><span class="line">              crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">              children: [</span><br><span class="line">                FractionallySizedWidget(widthFactor: 0.4),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            Row(</span><br><span class="line">              crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">              children: [</span><br><span class="line">                FractionallySizedWidget(widthFactor: 0.6),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            Row(</span><br><span class="line">              crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">              children: [</span><br><span class="line">                FractionallySizedWidget(widthFactor: 0.8),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            Row(</span><br><span class="line">              crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">              children: [</span><br><span class="line">                FractionallySizedWidget(widthFactor: 1.0),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FractionallySizedWidget extends StatelessWidget &#123;</span><br><span class="line">  final double widthFactor;</span><br><span class="line">  FractionallySizedWidget(&#123;@required this.widthFactor&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Expanded(</span><br><span class="line">      child: FractionallySizedBox(</span><br><span class="line">        alignment: Alignment.centerLeft,</span><br><span class="line">        widthFactor: widthFactor,</span><br><span class="line">        child: Container(</span><br><span class="line">          decoration: BoxDecoration(</span><br><span class="line">            color: CustomColors.android,</span><br><span class="line">            border: Border.all(color: Colors.white),</span><br><span class="line">          ),</span><br><span class="line">          child: Padding(</span><br><span class="line">            padding: const EdgeInsets.all(16.0),</span><br><span class="line">            child: Text(</span><br><span class="line">              &#39;$&#123;widthFactor * 100&#125;%&#39;,</span><br><span class="line">              style: TextStyle(color: Colors.white, fontSize: 24),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*xcbW24iB2NZOAt6Hc_zzJg.png" alt=""></p><h3 id="6-AspectRatio"><a href="#6-AspectRatio" class="headerlink" title="6. AspectRatio"></a>6. AspectRatio</h3><p>AspectRatio 组件可以直接<strong>指定子组件的固定宽高比例</strong>，使用时，我们可以使用布局约束的最大宽度，并给定一个宽高比自适应其高度，如下示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HomePage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      backgroundColor: Colors.white,</span><br><span class="line">      body: SafeArea(</span><br><span class="line">        child: Column(</span><br><span class="line">          children: [</span><br><span class="line">            AspectRatioWidget(ratio: &#39;16 &#x2F; 9&#39;),</span><br><span class="line">            AspectRatioWidget(ratio: &#39;3 &#x2F; 2&#39;),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AspectRatioWidget extends StatelessWidget &#123;</span><br><span class="line">  final String ratio;</span><br><span class="line"></span><br><span class="line">  AspectRatioWidget(&#123;@required this.ratio&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return AspectRatio(</span><br><span class="line">      aspectRatio: Fraction.fromString(ratio).toDouble(),</span><br><span class="line">      child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">          color: CustomColors.android,</span><br><span class="line">          border: Border.all(color: Colors.white),</span><br><span class="line">        ),</span><br><span class="line">        child: Padding(</span><br><span class="line">          padding: const EdgeInsets.all(16.0),</span><br><span class="line">          child: Center(</span><br><span class="line">            child: Text(</span><br><span class="line">              &#39;AspectRatio - $ratio&#39;,</span><br><span class="line">              style: TextStyle(color: Colors.white, fontSize: 24),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-2020-11-05-1*GzI_jmKrNQXMFA8JdBGrRA.png" alt=""></p><p>下面，我们就可以利用上面介绍的组件实现一个实际的应用了。</p><h2 id="应用开发实践"><a href="#应用开发实践" class="headerlink" title="应用开发实践"></a>应用开发实践</h2><p>在这个过程中，即可实现 Flutter 中的视图分离，如下示例图所示，我们要开发的应用名为 <strong>Flow</strong> ，是一款聊天应用。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*DivvZvw1LjtOUdkeIzSiPw-20201105154223662.png" alt=""></p><p>Flow 主要包括如下两个页面：</p><ul><li><strong>首页</strong>（<code>PeopleView</code>，<code>BookmarkView</code>，<code>ContactView</code>）</li><li><strong>聊天页面</strong>（<code>PeopleView</code>，<code>ChatView</code>）</li></ul><h3 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h3><p>应用启动时，首页展示 HomePage，该 Widget 主要有如下两个视图：</p><ul><li><strong>HomeViewSmall</strong>（包括<code>AppBar</code>，<code>Drawer</code>，<code>BottomNavigationBar</code>和 <code>DestinationView</code>）</li><li><strong>HomeViewLarge</strong>（由拆分视图组组成，<code>MenuWidget</code> ＆<code>DestinationView</code>）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class _HomePageState extends State&lt;HomePage&gt; &#123;</span><br><span class="line">  int _currentIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: LayoutBuilder(</span><br><span class="line">        builder: (context, constraints) &#123;</span><br><span class="line">          if (constraints.maxWidth &lt; 600) &#123;</span><br><span class="line">            return HomeViewSmall();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return HomeViewLarge();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，使用 LayoutBuilder 得到了组件的 <code>maxWidth</code> ，并通过该值在页面中展示两个不同的组件，<code>HomeViewSmall</code>和<code>HomeViewLarge</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class _HomeViewSmallState extends State&lt;HomeViewSmall&gt; &#123;</span><br><span class="line">  int _currentIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">      ),</span><br><span class="line">      drawer: Drawer(</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">      ),</span><br><span class="line">      bottomNavigationBar: BottomNavigationBar(</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">      ),</span><br><span class="line">      body: IndexedStack(</span><br><span class="line">        index: _currentIndex,</span><br><span class="line">        children: allDestinations.map&lt;Widget&gt;((Destination destination) &#123;</span><br><span class="line">          return DestinationView(destination);</span><br><span class="line">        &#125;).toList(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IndexedStack</code> 和 <code>DestinationView</code>  两个组件主要用来根据用户点击 <code>BottomNavigationBar</code> 做页面切换的动作。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*qrUoiEQSB7ALyjBFhM-GdQ-20201105154252319.png" alt=""></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class _HomeViewLargeState extends State&lt;HomeViewLarge&gt; &#123;</span><br><span class="line">  int _index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      child: Row(</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line">        children: [</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: 2,</span><br><span class="line">            child: MenuWidget(</span><br><span class="line">              selectedIndex: _index,</span><br><span class="line">              onTapped: (selectedIndex) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  _index &#x3D; selectedIndex;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: 3,</span><br><span class="line">            child: IndexedStack(</span><br><span class="line">              index: _index,</span><br><span class="line">              children: allDestinations.map&lt;Widget&gt;((Destination destination) &#123;</span><br><span class="line">                return DestinationView(destination);</span><br><span class="line">              &#125;).toList(),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于大屏幕，应用可以展示包含 <code>MenuWidget</code>和 <code>DestinationView</code> 两个组件的拆分视图。在 Flutter 中，实现拆分视图特别简单，只需要并排将组件放入 Row 中即可，如果需要填充剩余控件，可以使用 Expanded 包裹这两个组件，我们可以通过指定 Expanded 的 flex 属性分别设置两个组件所占比例（flex 属性默认为 1，即两个组件各一半），上面代码设置比例为 1：3。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*4ISs69dvgcFSqTXlXJKt2A-20201105154314644.png" alt=""></p><p>当然，如果此时你打开其他页面，然后返回，页面原有状态将会丢失，也就是说始终返回默认展示的页面，即 <strong>Chats</strong>，要解决此问题，可以使用回调函数指定页面返回至 <code>HomePage</code>，当然，最好可以使用合适的状态管理方案，因为本文主要目的是构建响应式布局，这里我们暂且不设计状态管里的延伸，我们可以做下面这些修改。</p><p>修改 <code>HomeViewSmall</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HomeViewSmall extends StatefulWidget &#123;</span><br><span class="line">  final int currentIndex;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Callback function</span><br><span class="line">  final Function(int selectedIndex) onTapped;</span><br><span class="line">  HomeViewSmall(this.currentIndex, this.onTapped);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _HomeViewSmallState createState() &#x3D;&gt; _HomeViewSmallState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _HomeViewSmallState extends State&lt;HomeViewSmall&gt; &#123;</span><br><span class="line">  int _currentIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    super.initState();</span><br><span class="line">    _currentIndex &#x3D; widget.currentIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      &#x2F;&#x2F; ...</span><br><span class="line">      bottomNavigationBar: BottomNavigationBar(</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        currentIndex: _currentIndex,</span><br><span class="line">        onTap: (int index) &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            _currentIndex &#x3D; index;</span><br><span class="line">            &#x2F;&#x2F; Invoking the callback</span><br><span class="line">            widget.onTapped(_currentIndex);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        items: allDestinations.map((Destination destination) &#123;</span><br><span class="line">          return BottomNavigationBarItem(</span><br><span class="line">            icon: Icon(destination.icon),</span><br><span class="line">            label: destination.title,</span><br><span class="line">          );</span><br><span class="line">        &#125;).toList(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>HomeViewLarge</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HomeViewLarge extends StatefulWidget &#123;</span><br><span class="line">  final int currentIndex;</span><br><span class="line">  &#x2F;&#x2F;&#x2F; Callback function</span><br><span class="line">  final Function(int selectedIndex) onTapped;</span><br><span class="line">  HomeViewLarge(this.currentIndex, this.onTapped);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _HomeViewLargeState createState() &#x3D;&gt; _HomeViewLargeState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _HomeViewLargeState extends State&lt;HomeViewLarge&gt; &#123;</span><br><span class="line">  int _index &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    super.initState();</span><br><span class="line">    _index &#x3D; widget.currentIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      child: Row(</span><br><span class="line">        crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">        mainAxisAlignment: MainAxisAlignment.start,</span><br><span class="line">        children: [</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: 2,</span><br><span class="line">            child: MenuWidget(</span><br><span class="line">              selectedIndex: _index,</span><br><span class="line">              onTapped: (selectedIndex) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  _index &#x3D; selectedIndex;</span><br><span class="line">                  &#x2F;&#x2F; Invoking the callback</span><br><span class="line">                  widget.onTapped(_index);</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          &#x2F;&#x2F; ...</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 <code>HomePage</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class HomePage extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  _HomePageState createState() &#x3D;&gt; _HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _HomePageState extends State&lt;HomePage&gt; &#123;</span><br><span class="line">  int _currentIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: LayoutBuilder(</span><br><span class="line">        builder: (context, constraints) &#123;</span><br><span class="line">          if (constraints.maxWidth &lt; 600) &#123;</span><br><span class="line">            return HomeViewSmall(_currentIndex, (index) &#123;</span><br><span class="line">              setState(() &#123;</span><br><span class="line">                _currentIndex &#x3D; index;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return HomeViewLarge(_currentIndex, (index) &#123;</span><br><span class="line">              setState(() &#123;</span><br><span class="line">                _currentIndex &#x3D; index;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，可适应组件 HomePage 就已完成。</p><h2 id="聊天页面"><a href="#聊天页面" class="headerlink" title="聊天页面"></a>聊天页面</h2><p>ChatPage 与 HomePage 类似，包含如下两个组件：</p><ul><li><strong>ChatViewSmall</strong>（由 <code>AppBar</code>，<code>ChatList</code>＆<code>SendWidget</code> 组成）</li><li><strong>ChatViewLarge</strong>（由<code>PeopleView</code>，<code>ChatList</code>＆<code>SendWidget</code> 组成）</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ChatPage extends StatelessWidget &#123;</span><br><span class="line">  final Color profileIconColor;</span><br><span class="line">  ChatPage(this.profileIconColor);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: OrientationBuilder(</span><br><span class="line">        builder: (context, orientation) &#x3D;&gt; LayoutBuilder(</span><br><span class="line">          builder: (context, constraints) &#123;</span><br><span class="line">            double breakpointWidth &#x3D; orientation &#x3D;&#x3D; Orientation.portrait ? 600 : 800;</span><br><span class="line"></span><br><span class="line">            if (constraints.maxWidth &lt; breakpointWidth) &#123;</span><br><span class="line">              return ChatViewSmall(profileIconColor);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              return ChatViewLarge(profileIconColor);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们使用了 <code>OrientationBuilder</code> 搭配 <code>LayoutBuilder</code>，<code>breakpointWidth</code> 适应当前方向的更改，此时， <code>PeopleView</code>  在小屏幕设备下不展示，如下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ChatViewSmall extends StatelessWidget &#123;</span><br><span class="line">  final Color profileIconColor;</span><br><span class="line">  ChatViewSmall(this.profileIconColor);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        color: Colors.white,</span><br><span class="line">        child: Column(</span><br><span class="line">          children: [</span><br><span class="line">            Expanded(child: ChatList(profileIconColor)),</span><br><span class="line">            SendWidget(),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-1*nsTtnyUTeYJFsPliKSbwkw.png" alt=""></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ChatViewLarge extends StatelessWidget &#123;</span><br><span class="line">  final Color profileIconColor;</span><br><span class="line">  ChatViewLarge(this.profileIconColor);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      child: Row(</span><br><span class="line">        children: [</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: 2,</span><br><span class="line">            child: SingleChildScrollView(</span><br><span class="line">              child: PeopleView(),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          Expanded(</span><br><span class="line">            flex: 3,</span><br><span class="line">            child: Container(</span><br><span class="line">              color: Colors.white,</span><br><span class="line">              child: Column(</span><br><span class="line">                children: [</span><br><span class="line">                  Expanded(child: ChatList(profileIconColor)),</span><br><span class="line">                  SendWidget(),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-11-05-2020-11-05-1*eutMMZXnblIqH5CyuOlb1A.png" alt=""></p><h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>我们已经使用 Flutter 成功开发出了一个具有屏幕适配功能的应用了，读者们也可以在此基础上继续完善，例如定义根据屏幕尺寸适配不同的 fontsize 等等。所有示例代码：<a href="https://github.com/sbis04/responsive_design，" target="_blank" rel="noopener">https://github.com/sbis04/responsive_design，</a></p><p><strong>关注公众号「Meandni」，及时阅读最新前沿技术动态，不至于落后时代。</strong></p><p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://medium.com/flutter-community/demystifying-responsive-layout-in-flutter-f85d0014b94e&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="flutter" scheme="https://meandni.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>解锁 Android 性能优化的五大误区和两大疑点！</title>
    <link href="https://meandni.com/2020/10/15/busting-android-performance-myths/"/>
    <id>https://meandni.com/2020/10/15/busting-android-performance-myths/</id>
    <published>2020-10-15T14:09:16.000Z</published>
    <updated>2020-11-05T14:00:30.311Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://medium.com/flutter/performance-testing-on-the-web-25323252de69" target="_blank" rel="noopener">Busting Android performance myths</a>，作者：Calin Juravle，译文首次发表于微信公众号「Meandni」，<a href="https://mp.weixin.qq.com/s/15JMvjuGKkZaq2WEvxlsSQ" target="_blank" rel="noopener">点击阅读</a>。</p></blockquote><p>近年来，社区充斥着关于 Android 性能优化的各种误区，本文本着<strong>误区终结者</strong>的精神，使用具体的性能检测工具，结合真实案例仔细分析这些情况，并对比它们的测试结果，也会聚焦 Android 开发者平时在编码过程的实际场景，用实际数据告诉你<strong>在实际编码之前请，一定要进行必要的性能检测</strong>。</p><h4 id="误区1：Kotlin-比-Java-更消耗性能"><a href="#误区1：Kotlin-比-Java-更消耗性能" class="headerlink" title="误区1：Kotlin 比 Java 更消耗性能"></a>误区1：Kotlin 比 Java 更消耗性能</h4><p>Google 云端硬盘团队目前已将其应用程序从 Java 全面替换为 Kotlin，重构范围涉及 170 多个文件，超过 16,000 行代码，包含 40 多个编译产物，在团队监控的指标中，第一要素是启动时间，测试结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*HMsbHNNmEj0q1yrb-20201015223338214.png" alt=""></p><p>如图所示，使用 kotlin 并没有对性能造成实质的影响，而且在整个基准测试过程中，Google 团队也都没有观察到明显的性能差异，即使编译时间和编译后的代码大小略有增加，但都保持在 2％ 之内，完全可以忽略不计。而得益于 kotlin 简洁的语法，团队的代码行却减少了大约 25％，也变得更易读和易维护。</p><p>还比较值得一提的是，使用 kotlin 时，我们也可以使用像 R8 这样的代码缩减工具，对代码进行进一步的优化。</p><h4 id="误区二：Getters-和-setters-方法更耗时"><a href="#误区二：Getters-和-setters-方法更耗时" class="headerlink" title="误区二：Getters 和 setters 方法更耗时"></a>误区二：Getters 和 setters 方法更耗时</h4><p>因为担心性能下降，有些开发者会选择在类中直接使用 public 修饰字段，而不去写 getter 和 setter 方法，如下面这段代码，这里的 getFoo() 方法就是变量 foo 的 getter 函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ToyClass &#123;</span><br><span class="line">   public int foo;</span><br><span class="line">   public int getFoo() &#123; return foo; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ToyClass tc &#x3D; new ToyClass();</span><br></pre></td></tr></table></figure><p>直接使用  tc.foo 获取变量显然已经破坏了面向对象的封装性，而在性能方面，我们在配备 Android 10 的 Pixel 3 上使用 <a href="https://developer.android.com/studio/profile/benchmark" target="_blank" rel="noopener">Jetpack Benchmark </a>对 tc.getFoo() 与 tc.foo 两个方法进行了<a href="https://developer.android.com/studio/profile/benchmark" target="_blank" rel="noopener">基准测试</a>，该库提供了预热代码的功能，最终的稳定测试结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*wbkp1A7_V8laRaRS-20201015132144978-20201015223342914.png" alt=""></p><p>getter 方法的性能与直接 access 变量的性能也并没有多大差别，结果并不奇怪，因为 Android RunTime(ART)内联了代码中所有的 getter 方法，因此，在 JIT 或 AOT 编译后执行的代码是相同的，正因如此，在 kotlin 中即使我们默认需要使用 getter 或 setter 获得变量，性能也并不会有所下降，如果使用 Java，除非特殊需要，否则就不应该使用这种方式破坏代码的封装性。</p><h4 id="误区三：Lambda-比内部类慢"><a href="#误区三：Lambda-比内部类慢" class="headerlink" title="误区三：Lambda 比内部类慢"></a>误区三：Lambda 比内部类慢</h4><p>Lambda（尤其是在引入 Stream API 的情况下）是一种非常方便的语法，可实现非常简洁的代码。如下这段代码，对对象数组的内部字段值求和，这里，使用了 Stream API 搭配 map-reduce 操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ToyClass&gt; array = build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = array.stream().map(tc -&gt; tc.foo).reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>第一个 lambda 会将对象转换为整数，第二个 lambda 会将产生的两个值相加。</p><p>下面代码中，我们再将 lambda 表达式换成内部类：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ToyClassToInteger toyClassToInteger &#x3D; new ToyClassToInteger();</span><br><span class="line"></span><br><span class="line">SumOp sumOp &#x3D; new SumOp();</span><br><span class="line"></span><br><span class="line">int sum &#x3D; array.stream().map(toyClassToInteger).reduce(0, sumOp);</span><br></pre></td></tr></table></figure><p>这里，有两个内部类：一个是 toyClassToInteger，它可以将对象转换为整数，第二个 SumOp 用来做求和运算。</p><p>从语法上看，第一个带有 lambda 的示例显然更优雅，也更易读。那么，性能差异又如何呢？我们再次在 Pixel 3 上使用了Jetpack Benchmark，也没有发现性能差异：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*UBNsamryvRy8Zgxe-20201015223348768.png" alt=""></p><p>从图中可以看到，我们还定义了单独的外部(top-level)类一起来做比较，发现性能都没有什么差异，原因就是 lambda 表达式最终也会被转换为匿名内部类。因此，为了代码的简洁易读，在这种场景下 lambda 表达式就是第一选择。</p><h4 id="误区四：对象分配开销过大，应该使用对象池"><a href="#误区四：对象分配开销过大，应该使用对象池" class="headerlink" title="误区四：对象分配开销过大，应该使用对象池"></a>误区四：对象分配开销过大，应该使用对象池</h4><p>Android 内置了最先进的内存分配和垃圾回收机制，如下图所示，几乎每个版本的更新都在对象分配方面做各式各样的更新。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*RP2kwLn9MbtPg6Ru.png" alt=""></p><p>各个版本之间的垃圾收集性能都有显著的改善，如今，垃圾收集对应用程序的流畅已经几乎没有影响了。下图展示了 Google 官方在 Android 10 中对具有分代并发收集的对象收集所做的改进，新版本的 Android 11 中也有明显的改进。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*2QorsoqRUJj0KhKt.png" alt=""></p><p>在GC基准测试（例如H2）中，吞吐量大幅提高了 170％ 以上，而在实际应用（如 Google Sheets）中，吞吐量也提高了 68％。</p><p>如果认为垃圾收集效率低下并且内存分配负担很重，那么就相当于认为创建的垃圾越少，垃圾收集工作就越少，因此，代替每次使用时都创建新对象，我们可以维护一个经常使用的类型的对象池，然后从池中获取已创建的对象，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pool&lt;A&gt; pool[] &#x3D; new Pool&lt;&gt;[50];</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">   A a &#x3D; pool.acquire();</span><br><span class="line">   …</span><br><span class="line">   pool.release(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里省略了代码细节，大体就是就是定义了一个 pool，从 pool 中获取对象，然后最终释放。</p><p>要测试这种场景，我们使用微基准测试(microbenchmark)：从池中测试分配对象的开销，以及CPU的开销，来确定垃圾回收是否会影响应用程序的性能。</p><p>在这种情况下，我们依然可以在装有 Android 10 的 Pixel 2 XL 上循环运行了数千次分配对象的代码，因为对于小型或大型对象，性能可能会有所不同，我们还通过添加不同的字段来模拟不同的对象大小，最终的开销结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*Uo_w_LzYAUiFrvax-20201015223358709.png" alt=""></p><p>用于垃圾回收的 CPU 开销的结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-2020-10-15-0*UW6KyFWPOYpz7-xd.png" alt=""></p><p>从图中可以看出，标准分配和池化对象之间的差异也很小，但是，当涉及到较大对象的垃圾回收时，池解决方案略微高一点。</p><p>这个结果并不意外，因为池化对象会增加应用的内存占用量，此时，应用突然占用了太多的内存，即使由于池化对象减少了垃圾回收调用的数量，每个垃圾回收调用的成本也更高，因为垃圾收集器必须遍历更多的内存才能确定哪些对象需要被收集，哪些对象需要保留。</p><p>那么，对象是否应该被池化，这还是主要取决于应用的需求。如果不考虑到代码复杂性，池化对象有如下缺点：</p><ul><li>提高内存占用量</li><li>使对象存活变长</li><li>需要非常完善的对象池机制</li></ul><p>但是，池的方法对于大并且耗时的对象分配可能确实是有效的，关键是要记住在选择方案之前进行充分的测试。</p><h4 id="误区五：debug-模式下进行性能分析"><a href="#误区五：debug-模式下进行性能分析" class="headerlink" title="误区五：debug 模式下进行性能分析"></a>误区五：debug 模式下进行性能分析</h4><p>在 debug 的同时对应用进行性能分析非常方便，毕竟，我们通常也是在 debug 模式下进行编码的，并且，即使 debug 应用中的性能分析不准确，也可以更快地进行迭代修改提高效率，<strong>然后事实是并没有</strong>。</p><p>为了验证这一误解，我们分析了 Activity 相关的常见操作过程过的测试结果，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*G3DDVYBx8-XegSHS-20201015132148928.png" alt=""></p><p>在某些测试（例如反序列化）中，debug 与否对性能没有影响，但是，有些结果却有 50％ 甚至以上的差别，我们甚至发现结果速度可能会慢 100％ 的例子，这是因为 runtime 在 debug 模式下时对代码几乎没有优化，因此与用户在生产设备上运行的代码有很大不同。</p><p>在 debug 模式下进行性能分析的结果是可能会误导优化方向，导致浪费时间来优化不需要优化的内容。</p><h3 id="疑点"><a href="#疑点" class="headerlink" title="疑点"></a>疑点</h3><p>现在，我们需要有意识的逃避上述提到的五大误区，下面我们再来看一下一些日常开发中不太明显，但我们经常会有的疑惑的问题，事实结果可能也与我们想的大相径庭。</p><h4 id="疑点1：Multidex：是否影响应用性能？"><a href="#疑点1：Multidex：是否影响应用性能？" class="headerlink" title="疑点1：Multidex：是否影响应用性能？"></a>疑点1：Multidex：是否影响应用性能？</h4><p>如今的 APK 文件越来越大，因为大型应用通常会超出 Android 限定的方法数量，从而使用 Multidex 方案打破传统的 dex 规范。</p><p>问题是，多少方法可以称之为多？而且如果应用包含大量 dex 是否对性能产生影响？很多时候我们也并不是因为应用太大，而是为了根据功能拆分 dex 文件来方便团队开发而使用 Multidex。</p><p>为了测试多个 dex 文件对性能的影响，我们使用了计算器应用，默认情况下，它只包含单个 dex 文件，我们可以根据其程序包边界将其拆分为五个 dex 文件，来根据功能部件模拟拆分。</p><p>首先，测试启动应用的性能，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*trjzpDOQpLbgFNvV.png" alt=""></p><p>因此，拆分 dex 文件对此处并没有影响，对于其他应用，可能会因为某些因素而产生轻微的开销：应用程序的大小以及拆分方式。但是，只要合理地分割 dex 文件并且不添加成百个 dex 文件，对启动时间的影响应该不大。</p><p>接下来是 APK 的大小和内存消耗：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/uPic/0*0-61ZDBsfpeWqsS6-20201015132150431.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*fgW2o3w1ftMuFXKu.png" alt=""></p><p>如图所示，APK 大小和应用的运行时内存占用量都略有增加，这是因为将应用程序拆分为多个 dex 文件时，每个 dex 文件都会有一些符号表和缓存表中的重复数据。</p><p>但是，我们可以通过减少 dex 文件之间的依赖关系来最大限度地避免这种情况，在这个案例中，并没有将 dex 包量化，我们可以使用 R8 和 D8 之类的工具合理分析项目结构并使用最小化的依赖关系，这些工具可以自动拆分 dex 文件，并帮助我们避免常见的错误，最大程度地减少依赖关系，如创建的 dex 文件数量不会超过指定的数量，并且不会将所有启动类都放置在主文件中。但是，如果我们对 dex 文件进行自定义拆分，请确保合理分析。</p><h4 id="疑点2：无用代码"><a href="#疑点2：无用代码" class="headerlink" title="疑点2：无用代码"></a>疑点2：无用代码</h4><p>使用 ART 这样的即时编译器的好处之一就是可以在运行时分析代码，并对其进行优化。有一种说法是，如果解释器/ JIT系统没有对代码进行概要分析，就可能不会执行该代码。为了验证这一理论，我们检查了 Google 应用生成的 ART 配置文件，发现许多代码并没有被 JIT 做概要分析，这就表明许多代码实际上从未在设备上执行过。</p><p>有几种类型的代码可能无法剖析：</p><ul><li>错误处理代码，希望它不会执行太多。</li><li>兼容性代码，并非在所有设备上都执行的代码，尤其是 Android 5 以上版本的设备。</li><li>不常用功能的代码。</li></ul><p>但是，从结果分布来看，应用程序中还是会存在很多不必要的代码。R8 可以帮助我们快速，简便，免费地删除不必要的代码，来缩小这部分的开销。如果不这么做，我们也可以将应用打包成 <a href="https://developer.android.com/guide/app-bundle" target="_blank" rel="noopener">Android App Bundle</a>，这种格式只会使用特定设备所需的代码和资源来运行应用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文，我们分析了 Android 性能优化的五大误区，但某些情况下数据的结果还并不清晰，我们需要做的就是在优化和修改代码之前尽量做好性能测试。</p><p>目前，已经有很多工具可以帮助我们分析评估如何优化应用了，如 Android Studio 中的 profilers，它也提供了电池和网络的监测功能。也可以用一些工具做更深入的探究，如 Perfetto 和 Systrace，这些工具会提供更加详细的功能，例如在应用启动或执行过程中发生的具体情况。</p><p>Jetpack Benchmark 摒弃了监测和基准测试的所有复杂操作，官方强烈建议我们在持续集成系统中使用它来跟踪性能，并查看应用在添加功能的行为，最后需要注意的一点是，不要在 debug 模式下分析应用性能。</p><p><strong>关注公众号「Meandni」，及时阅读最新前沿技术动态，不至于落后时代。</strong></p><p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://medium.com/flutter/performance-testing-on-the-web-25323252de69&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bustin
      
    
    </summary>
    
      <category term="Android" scheme="https://meandni.com/categories/Android/"/>
    
    
      <category term="Android" scheme="https://meandni.com/tags/Android/"/>
    
      <category term="性能优化" scheme="https://meandni.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>在 Chrome 中测试 Flutter Web 应用性能</title>
    <link href="https://meandni.com/2020/10/11/performance-testing-on-the-web/"/>
    <id>https://meandni.com/2020/10/11/performance-testing-on-the-web/</id>
    <published>2020-10-11T14:45:29.000Z</published>
    <updated>2020-10-15T14:13:19.868Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自：<a href="https://medium.com/flutter/performance-testing-on-the-web-25323252de69" target="_blank" rel="noopener">https://medium.com/flutter/performance-testing-on-the-web-25323252de69</a></p></blockquote><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>性能测试是开发过程中非常重要的一环，通过合适的工具我们可以发现应用程序卡顿、变慢的潜在原因。本文，我们就来介绍一种在 Chrome 中测试 Flutter Web 应用程序性能的方法，此方法与官方测试 <a href="https://gallery.flutter.dev/#/" target="_blank" rel="noopener">Flutter Gallery</a> 应用性能方法类似。</p><h2 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h2><p>下图展示了我们本文测试的一个示例应用程序，其中包含一个顶部栏，一个悬浮按钮和一个无限列表，列表中的每一项可以展示按下按钮的次数。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/uPic/0*adwmyiS509VwCCYl-20201011175512248.png" alt="图片发布"></p><p>点击 Appbar 中的 action 图标进入第二个页面，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-0*-d-mmdUUEW08ytWJ-20201011230458669.png" alt=""></p><p>应用程序的完成代码如下：</p><ul><li><a href="https://github.com/material-components/material-components-flutter-experimental/tree/develop/web_benchmarks_example" target="_blank" rel="noopener">https://github.com/material-components/material-components-flutter-experimental/tree/develop/web_benchmarks_example</a></li></ul><h2 id="测试点"><a href="#测试点" class="headerlink" title="测试点"></a>测试点</h2><p>我们主要测试该应用在 Chrome 中的以下几种情况：</p><ol><li>用户在无限列表中滚动。</li><li>用户在两个页面之间切换。</li><li>用户点击悬浮操作按钮。</li></ol><h2 id="建立框架"><a href="#建立框架" class="headerlink" title="建立框架"></a>建立框架</h2><p>在配置文件 <code>pubspec.yaml</code>  中添加如下配置项：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">web_benchmarks_framework:</span></span><br><span class="line">    <span class="attr">git:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://github.com/material-components/material-components-flutter-experimental.git</span></span><br><span class="line">      <span class="attr">ref:</span> <span class="string">f6ebb4ed3b6489547d9ae58216df9999112be568</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">web_benchmarks_framework</span></span><br></pre></td></tr></table></figure><p>引入 <code>web_benchmarks_framework</code> ，它是用在 Chrome 中做性能测试最小依赖库。</p><p>该库基于 <code>macrobenchmarks</code> 和 <code>devicelab</code> ，Flutter 官方主要就是使用两个库对 Flutter Gallery 进行了 Web 性能测试。目前，这两个库专用于 <code>flutter/flutter</code> 内部  sample 的 Web 性能测试 ，我们这里使用更加通用的 <code>web_benchmarks_framework</code>。</p><p>运行 <code>flutter pub get，</code>，同步依赖。</p><h2 id="编写第一个测试"><a href="#编写第一个测试" class="headerlink" title="编写第一个测试"></a>编写第一个测试</h2><p>在 <code>lib</code> 中新建  <code>benchmarks</code>  文件夹，并创建 <code>runner.dart</code> 文件：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/uPic/0*tsvQSKBjpWJWkiKM-20201011175515332.png" alt=""></p><p>在该文件中添加如下代码：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_test/flutter_test.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:web_benchmarks_framework/recorder.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:web_benchmarks_framework/driver.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:web_benchmarks_example/main.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:web_benchmarks_example/homepage.dart'</span> <span class="keyword">show</span> textKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="markdown">用于测量框架构建的时间的记录器。</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRecorder</span> <span class="keyword">extends</span> <span class="title">WidgetRecorder</span> </span>&#123;</span><br><span class="line">  AppRecorder(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.benchmarkName&#125;) : <span class="keyword">super</span>(name: benchmarkName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> benchmarkName;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; automate();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget createWidget() &#123;</span><br><span class="line">    Future.delayed(<span class="built_in">Duration</span>(milliseconds: <span class="number">400</span>), automate);</span><br><span class="line">    <span class="keyword">return</span> MyApp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; animationStops() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (WidgetsBinding.instance.hasScheduledFrame) &#123;</span><br><span class="line">      <span class="keyword">await</span> Future&lt;<span class="keyword">void</span>&gt;.delayed(<span class="built_in">Duration</span>(milliseconds: <span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollRecorder</span> <span class="keyword">extends</span> <span class="title">AppRecorder</span> </span>&#123;</span><br><span class="line">  ScrollRecorder() : <span class="keyword">super</span>(benchmarkName: <span class="string">'scroll'</span>);</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; automate() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> scrollable = Scrollable.of(find.byKey(textKey).evaluate().single);</span><br><span class="line">    <span class="keyword">await</span> scrollable.position.animateTo(</span><br><span class="line">      <span class="number">30000</span>,</span><br><span class="line">      curve: Curves.linear,</span><br><span class="line">      duration: <span class="built_in">Duration</span>(seconds: <span class="number">20</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> runBenchmarks(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">'scroll'</span>: () =&gt; ScrollRecorder(),</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码包括：</p><ul><li>应用运行，创建一个 <code>ScrollRecorder</code>  对象，该对象可以执行自动化手势驱动应用程执行，在上面的代码中，应用启动后就会自动化向下滚动列表。</li><li><p><code>ScrollRecorder</code> 继承 <code>AppRecorder</code>，而 <code>AppRecorder</code> 继承自 <code>WidgetRecorder</code>，其中就会通过驱动应用程序测试记录性能数据。</p></li><li><p><code>runBenchmarks</code> 在 <code>package:web_benchmarks_framework/driver.dart</code> 中实现，该函数允许用户选择一个 benchmark 执行并在浏览器中显示测试结果。</p></li><li><code>automate</code> 方法依赖 <code>flutter_test</code>，可以使用它在应用程序中执行自动化手势和组件 find 等方法。</li></ul><h2 id="运行第一个测试"><a href="#运行第一个测试" class="headerlink" title="运行第一个测试"></a>运行第一个测试</h2><p>进入项目根目录，在终端运行 <code>flutter run -d chrome -t lib/benchmarks/runner.dart</code>，该命令表示使用 <code>runner.dart</code> 代替 <code>main.dart</code> 作为程序入口点。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-0*imb9-c_LS4XF0xDX-20201011230625632.png" alt=""></p><p>目前，我们只有一个 benchmark 测试（<code>ScrollRecorder</code>），因此可以单击这里 “scroll” 直接启动。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/uPic/0*3aZa4m2GbsqHECNw-20201011175551100.png" alt=""></p><p>测试开始后，列表会自动向下滚动，几秒钟后结束，页面内容如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-0*LitJY47Vl0J17C5V-20201011175552110.png" alt=""></p><p>该图表展示了记录时应用绘制每一帧所花费的时间，横轴表示时间线，纵轴表示每帧所花费的具体时间。</p><p>图表中前 2/3 背景为灰色，表示这些帧为<strong>预热帧（warm-up frames）</strong> ，需要从统计信息中省略，预热帧可以给 JIT 编译器一定时间来编译代码，并填充各种缓存，这样，之后所有的测试结果表达就是应用程序的真实性能数据了。但预热帧也不能总被忽略，它也可以在前几秒钟提供有关应用程序性能一些有价值的信息，这些信息也会影响我们对应用程序质量的分析。</p><p>红色框中的帧表示离群值（outliers），这些帧相比其他帧更耗时，也很容易被无视，例如，jank 在动画的开始或结束时除非到了特定的点否则将会不可见，但是，动画中间的一个不稳定帧将非常明显。</p><p>离群值可以一定程度上说明应用程序的简洁性，通过改进应用，我们可以降低离群值或减少离群数，这时就表明应用已经变得更加流畅了。</p><h2 id="从-Chrome-的-DevTools-收集性能数据"><a href="#从-Chrome-的-DevTools-收集性能数据" class="headerlink" title="从 Chrome 的 DevTools 收集性能数据"></a>从 Chrome 的 DevTools 收集性能数据</h2><p>该 benchmark 完全在 Chrome 内部运行，创建 <code>test/run_benchmarks.dart</code> ，添加如下代码：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:convert'</span> <span class="keyword">show</span> JsonEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:web_benchmarks_framework/server.dart'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; main () <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> taskResult = <span class="keyword">await</span> runWebBenchmark(</span><br><span class="line">    macrobenchmarksDirectory: <span class="string">'.'</span>,</span><br><span class="line">    entryPoint: <span class="string">'lib/benchmarks/runner.dart'</span>,</span><br><span class="line">    useCanvasKit: <span class="keyword">false</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">print</span> (JsonEncoder.withIndent(<span class="string">'  '</span>).convert(taskResult.toJson()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>dart test/run_benchmarks.dart</code>。大约一分钟后，看到以下结果：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Received profile data</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"success"</span>: <span class="keyword">true</span>,</span><br><span class="line">  <span class="string">"data"</span>: &#123;</span><br><span class="line">    <span class="string">"scroll.html.preroll_frame.average"</span>: <span class="number">93.88659793814433</span>,</span><br><span class="line">    <span class="string">"scroll.html.preroll_frame.outlierAverage"</span>: <span class="number">1061.3333333333333</span>,</span><br><span class="line">    <span class="string">"scroll.html.preroll_frame.outlierRatio"</span>: <span class="number">11.304417847077339</span>,</span><br><span class="line">    <span class="string">"scroll.html.preroll_frame.noise"</span>: <span class="number">0.3103013467989926</span>,</span><br><span class="line">    <span class="string">"scroll.html.apply_frame.average"</span>: <span class="number">391.1914893617021</span>,</span><br><span class="line">    <span class="string">"scroll.html.apply_frame.outlierAverage"</span>: <span class="number">1462.3333333333333</span>,</span><br><span class="line">    <span class="string">"scroll.html.apply_frame.outlierRatio"</span>: <span class="number">3.738152217266761</span>,</span><br><span class="line">    <span class="string">"scroll.html.apply_frame.noise"</span>: <span class="number">0.24804233283684318</span>,</span><br><span class="line">    <span class="string">"scroll.html.drawFrameDuration.average"</span>: <span class="number">1496.8690476190477</span>,</span><br><span class="line">    <span class="string">"scroll.html.drawFrameDuration.outlierAverage"</span>: <span class="number">3622.8125</span>,</span><br><span class="line">    <span class="string">"scroll.html.drawFrameDuration.outlierRatio"</span>: <span class="number">2.4202601461781335</span>,</span><br><span class="line">    <span class="string">"scroll.html.drawFrameDuration.noise"</span>: <span class="number">0.38481902033678567</span>,</span><br><span class="line">    <span class="string">"scroll.html.totalUiFrame.average"</span>: <span class="number">3441</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"benchmarkScoreKeys"</span>: [</span><br><span class="line">    <span class="string">"scroll.html.drawFrameDuration.average"</span>,</span><br><span class="line">    <span class="string">"scroll.html.drawFrameDuration.outlierRatio"</span>,</span><br><span class="line">    <span class="string">"scroll.html.totalUiFrame.average"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行机器不同，这些性能值会有差异。</p><p>上面代码主要的内容包括：</p><ul><li>运行 <code>test/run_benchmarks.dart</code> 构建 Flutter Web 应用，然后在 Chrome 中运行该应用。</li><li><code>test/run_benchmarks.dart</code> 会连接到 Chrome 的 DevTools 端口，并从中监听并收集相关的性能数据。</li></ul><p>结果含义如下：</p><ul><li>每渲染一帧，<a href="https://api.flutter.dev/flutter/rendering/Layer-class.html" target="_blank" rel="noopener">layer tree</a> 执行两个步骤。</li><li>第一步 “Preroll”，它不渲染任何东西，但是会计算稍后用于渲染的值，例如包括：变换矩阵，逆变换和片段。</li><li>第二步是 “Apply frame” ，UI 被实际渲染。</li><li>“Draw frame” 表示框架渲染一帧所花费的总时间，包括 “Preroll” 和 “Apply frame”，也包括构建和布局组件所花费的时间。</li><li>“ Total UI frame” 包括 “Draw frame” 中的所有内容，还包括浏览器执行的一些隐藏工作，例如层树更新，样式重新计算和浏览器侧布局（Flutter 自己的布局逻辑不同）。</li><li>收集数据集（持续时间列表）后，性能测试算法会省略离群值。</li><li>首先，计算数据的平均值和标准差，任何高于（均值+1个标准差）的数据点均被视为离群值。</li><li>非离群值（纯数据）的平均值和标准差用于计算数据集的平均值和噪声，然后将其报告。</li><li>还报告了所有异常值的平均值，以及“异常值平均值”和“非异常值平均值”的比率。</li><li>对于每个数据集，“ outlierRatio” 和 “noise” 都是表明应用程序性能有多少噪声的良好指标。如果结果太嘈杂，则可能表明性能不一致（例如，GC 暂停时出现不稳定的帧），通过降低噪音，可以使应用更流畅地运行。</li></ul><h2 id="添加更多测试"><a href="#添加更多测试" class="headerlink" title="添加更多测试"></a>添加更多测试</h2><p>修改  <code>lib/benchmarks/runner.dart</code>，添加两个测试。首先，修改 main 函数：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> runBenchmarks(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">'scroll'</span>: () =&gt; ScrollRecorder(),</span><br><span class="line">      <span class="string">'page'</span>: () =&gt; PageRecorder(),</span><br><span class="line">      <span class="string">'tap'</span>: () =&gt; TapRecorder(),</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，再添加两个继承 <code>AppRecorder</code> 的类：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageRecorder</span> <span class="keyword">extends</span> <span class="title">AppRecorder</span> </span>&#123;</span><br><span class="line">  PageRecorder() : <span class="keyword">super</span>(benchmarkName: <span class="string">'page'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _completed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldContinue() =&gt; profile.shouldContinue() || !_completed;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; automate() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> controller = LiveWidgetController(WidgetsBinding.instance);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Testing round <span class="subst">$i</span>...'</span>);</span><br><span class="line">      <span class="keyword">await</span> controller.tap(find.byKey(aboutPageKey));</span><br><span class="line">      <span class="keyword">await</span> animationStops();</span><br><span class="line">      <span class="keyword">await</span> controller.tap(find.byKey(backKey));</span><br><span class="line">      <span class="keyword">await</span> animationStops();</span><br><span class="line">    &#125;</span><br><span class="line">    _completed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapRecorder</span> <span class="keyword">extends</span> <span class="title">AppRecorder</span> </span>&#123;</span><br><span class="line">  TapRecorder() : <span class="keyword">super</span>(benchmarkName: <span class="string">'tap'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _completed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldContinue() =&gt; profile.shouldContinue() || !_completed;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; automate() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> controller = LiveWidgetController(WidgetsBinding.instance);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Testing round <span class="subst">$i</span>...'</span>);</span><br><span class="line">      <span class="keyword">await</span> controller.tap(find.byIcon(Icons.add));</span><br><span class="line">      <span class="keyword">await</span> animationStops();</span><br><span class="line">    &#125;</span><br><span class="line">    _completed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的内容包括：</p><ul><li>这里添加了剩余的两个 benchmark 测试：一个用于在页面之间切换（PageRecorder），另一个用于点击悬浮操作按钮（TapRecorder）。</li><li><code>animationStops</code> 会一直检查动画是否正在发生，所有动画停止后才停止，这就可以确保成功过渡到打开的第二个页面。</li><li>在 “page” 和 “tap” benchmarks 中，<code>_completed</code> 表示自动手势是否完成。</li><li>在 “page” 和 “tap” benchmarks中，重写 <code>shouldContinue</code>  方法可以实现所有手势完成后 <code>AppRecorder</code>停止记录帧。</li></ul><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>要在 Chrome 中运行这些测试（并查看动画），执行下面这行命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter run -d chrome -t lib/benchmarks/runner.dart --profile</span><br></pre></td></tr></table></figure><p>要运行这些测试并收集 DevTools 数据，执行下面这行命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dart test/run_benchmarks.dart</span><br></pre></td></tr></table></figure><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>一旦用这种方式收集到了性能数据，就可以根据需要使用啦：</p><ul><li>可以在 CI 中设置一个任务，每当有人提交 PR 时就运行这些 benchmark 测试，避免引入高性能消耗的 change。</li><li>也可以设置一个 dashboard 页面，来分析性能测试 benchmark 的趋势，如官方为  Flutter Gallery 做的 <a href="https://flutter-dashboard.appspot.com/#/build" target="_blank" rel="noopener">Flutter Dashboard</a></li></ul><p>关注公众号「Meandni」，及时阅读最新技术动态。</p><p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文翻译自：&lt;a href=&quot;https://medium.com/flutter/performance-testing-on-the-web-25323252de69&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
      <category term="flutter" scheme="https://meandni.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="web" scheme="https://meandni.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>1964 年，空指针崩溃的源头，以及 Dart 最新的空安全特性！</title>
    <link href="https://meandni.com/2020/10/09/null-references-and-dart210/"/>
    <id>https://meandni.com/2020/10/09/null-references-and-dart210/</id>
    <published>2020-10-09T05:38:54.000Z</published>
    <updated>2020-10-18T07:54:29.642Z</updated>
    
    <content type="html"><![CDATA[<p>2009 年，<strong>快排算法的作者、1980 年图灵奖的得主</strong> Tony Hoare 在伦敦的 QCon 大会上发表了一场主题为《Null References: The Billion Dollar Mistake》的演讲，这场本该积极活跃的分享会<strong>全程却充满了懊悔和歉意</strong>，因为他认为正是自己在 1964 年将 null 指针引入编程语言的原因而导致了后来很多无法估量的损失。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-09-2020-10-08-1*4Utp7w7cM7wu1ipsfc6RDQ.jpeg" alt="托尼·霍尔（Tony Hoare）（右），1960 年在莫斯科国立大学作为交换生"></p><p>按 Hoare 自己的描述，当时将 null 指针引入的 ALGO（Hoare 发明的语言）的<strong>原因是非常容易实现</strong>，而 Null 后来却也造成了 innerable errors, vulnerabilities 和 system crash 等等异常，也间接导致了<strong>几十年数十亿美元的损失</strong>。</p><blockquote><p>“我把 Null 引用称为自己的十亿美元错误。它的发明是在 1965 年，那时我用一个面向对象语言 ( ALGOL W ) 设计了第一个全面的引用类型系统。我的目的是确保所有引用的使用都是绝对安全的，编译器会自动进行检查。但是我未能抵御住诱惑，加入了Null引用，仅仅是因为实现起来非常容易。”</p></blockquote><p>据调查，Javascript 中<strong>最常出现的 10 异常中有 8 个是由  <code>null</code> 和 <code>undefined</code> 引起</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-09-javascript-error-graph.png" alt="Javascript 最常见的错误排名"></p><p>因此，这也算是一个语言设计者的锅了，关于对空指针的看法，现在的工程师们也各执己见，有人认为 null 指针反倒应当成为了程序语言必不可少的一部分，认为大师做的没错，而 Hoare 的好朋友 Edsger Dijkstra 后来却把 null 比作通奸犯，认为对象里的每个值为 null 的属性都是被 null XX 的 XX，<strong>笔者在这里不予评论</strong>。</p><p>同时，现代很多高级语言，如 Kotlin, Swift, Rust，也已经有意识的来规避空指针这个特性了，今天我要说的 Dart，也在今年初开始重构类型体系支持这种<strong>在编译阶段就能发现空指针错误的 null-safe（空安全） 特性，也就是说今后我们将不再会因为空指针错误而导致 Flutter 应用程序崩溃啦！</strong>。</p><h3 id="Dart-2-10-的空安全特性"><a href="#Dart-2-10-的空安全特性" class="headerlink" title="Dart 2.10 的空安全特性"></a>Dart 2.10 的空安全特性</h3><p>在 Dart 2.10 以前，我们就常常会犯如下的错误：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Without null safety:</span></span><br><span class="line"><span class="built_in">bool</span> isEmpty(<span class="built_in">String</span> string) =&gt; string.length == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  isEmpty(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，因为这里的 null 属于 Null 类型，其中也并没有 length 属性的 getter 方法，因此会抛出 NoSuchMethodError 异常，这对我们这种底层的客户端开发者就是致命的错误。</p><p>强类型的语言的优势就在于能够在编译器就能立即发现程序的 bug，然后我们随之解决，开张大吉，但空指针错误却不在他的检查范围内，因此，Dart 在 2.10 引入 null-safe 特性后，<strong>我们在 IDE 内的编译期间就能不放过任何一个可能发生空指针错误的地方了</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-09-2020-10-08-dartpad-snippet.png" alt="空安全语法错误提示"></p><p><strong>Google 官方表示， Dart 语言 null-safe 特性目前已经在做第二阶段的测试了，下个月将该特性合并入 Flutter 内测，在此之前我们可以在 <a href="https://nullsafety.dartpad.dev/" target="_blank" rel="noopener">DartPad</a> 中尝尝鲜。</strong></p><p>另外，空安全特性的引入直接要求我们写出没有空指针的代码，因此 Dart  编译器和运行时<strong>可以省去优化内部的空检查</strong>，应用程序会就变得更轻量、速度也会更快。</p><blockquote><p>因为 Dart 目前也在预览阶段，暂时也不能投入生产，因此如果你在测试阶段遇到技术问题，随时可以<a href="https://github.com/dart-lang/sdk/issues/new?title=Null%20safety%20feedback:%20%5Bissue%20summary%5D&amp;labels=NNBD&amp;body=Describe%20the%20issue%20or%20potential%20improvement%20in%20detail%20here" target="_blank" rel="noopener">向官方提出反馈</a>。</p></blockquote><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>null-safe 引入的新操作符和关键字包括 <code>？</code>，<code>!</code> 和 <code>late</code>，使用过 Kotlin，TypeScript 或 C# 的读者，应该已经已经很熟悉这个特性了，下面我就介绍一下 Dart 语言中的使用方法。</p><p>此时，默认情况下，代码中写的所有变量默认都不为空：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些变量都不为空，直接初始化</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">String</span> name = getFileName();</span><br><span class="line"><span class="keyword">final</span> b = Foo();</span><br></pre></td></tr></table></figure><p>如果希望某个变量可以为空，可以使用 <code>?</code> 操作符声明一个<strong>可空变量</strong>，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? aNullableInt = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>如果你确定变量在使用之前一定会被初始化，可以使用 late 关键词延迟该操作：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntProvider</span> </span>&#123;</span><br><span class="line">  late <span class="built_in">int</span> aRealInt;</span><br><span class="line">  </span><br><span class="line">  IntProvider() &#123;</span><br><span class="line">    aRealInt = calculate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，Dart analyzer 就不会要求 aRealInt 变量马上给一个指定的值，我们可以称这种变量为 <strong>late 变量</strong>。</p><p>使用可控变量时，必须使用 <code>??</code> 或 <code>if</code> 语句做判空处理：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> value = aNullableInt ?? <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> definitelyInt(<span class="built_in">int</span>? aNullableInt) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aNullableInt == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> aNullableInt; <span class="comment">// Can't be null!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你能保证一个 可空变量在使用时一定不为空，使用 <code>!</code> 关键词声明：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>? aNullableInt = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span> value = aNullableInt!; <span class="comment">// `aNullableInt!` 确定为 int .</span></span><br></pre></td></tr></table></figure><p>如果你想要改变可空变量的类型，除了可以使用 <code>！</code> 操作符外，也可以使用 <code>as</code> ：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> maybeNum() <span class="keyword">as</span> <span class="built_in">int</span>;</span><br></pre></td></tr></table></figure><p>最后，如果引入空安全特性，也不能对可空变量直接使用 <code>.</code> 操作符调用方法，需要使用 <code>?.</code>：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>? d;  </span><br><span class="line"><span class="built_in">print</span>(d?.floor()); <span class="comment">// 使用 .? 代替 .</span></span><br></pre></td></tr></table></figure><h3 id="时机合适后引入"><a href="#时机合适后引入" class="headerlink" title="时机合适后引入"></a>时机合适后引入</h3><p>因为引入null-safe 特性被声明的变量都将默认不为空，会影响到整个 Dart 类型系统的改动，所以，直接使用这一特性可能会对项目具有较大的侵略性，因此官方将 null-safe 暂时当做<strong>可选特性</strong>，建议我们找个恰当的时机再做这个比较冒险的操作。</p><h3 id="逐步引入"><a href="#逐步引入" class="headerlink" title="逐步引入"></a>逐步引入</h3><p>官方也建议我们按照特定顺序来重构代码，<strong>先在独立模块的项目中引入该特性</strong>。如，如果 C 依赖于 B，而 B 又依赖于 A，那么先将 A 重构到空安全，然后再重构 B，再重构 C，无论 A、B、C 是库、包还是应用应当遵循这个重构顺序。</p><p><strong>为什么按这个次序重构代码？</strong>，虽然我们可以直接重构项目代码，但如果依赖项在重构过程中改变了它们的 API，就有可能还要进行二次重构，官方也将提供一系列开发工具来帮助开发者找出哪些依赖库已经迁移，<strong>开源项目的作者注意了，为了避免发生意外错误，请等到你所有的依赖项都重构了之后再发布空安全版本。</strong></p><h3 id="自动化工具"><a href="#自动化工具" class="headerlink" title="自动化工具"></a>自动化工具</h3><p>依赖项都重构完成时，可以使用官方的迁移工具进行项目代码重构，开发工具通过分析所有现有代码，查找哪些声明可以为非空（保持不变），哪些声明必须为可空（使用可空标记 “？” 可空标记）。</p><p>迁移工具是界面交互式的，因此我们可以直接查看该工具推断出来的具有可空性的属性，<strong>如果不想重构检查结果中的代码，也可以使用 ? 符标记为可空</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-09-2020-10-09-0*wqrweNI-0SK9DB0z.png" alt=""></p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>官方在会之后几个月中同步更多关于 Dart 空安全特性的进展和动态，届时也会请 Flutter 团队的开发者配合引入到框架中，关于空安全的具体用法可以参照 <a href="https://dart.dev/null-safety" target="_blank" rel="noopener">官方文档</a>，如果想要更深入去理解，可以参考 <a href="https://dart.dev/null-safety/understanding-null-safety#reachability-analysis" target="_blank" rel="noopener">Understanding null safety</a>，里面详细介绍了 Dart 官方的设计动机和理念，我后期也会跟国内的读者做最新的同步，大家敬请期待。</p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p><a href="https://medium.com/dartlang/announcing-dart-2-10-350823952bd5" target="_blank" rel="noopener">https://medium.com/dartlang/announcing-dart-2-10-350823952bd5</a></p><p><a href="https://blog.maxkit.com.tw/2015/08/null-null-reference-is-billion-dollar.html?m=1" target="_blank" rel="noopener">https://blog.maxkit.com.tw/2015/08/null-null-reference-is-billion-dollar.html?m=1</a></p><p><a href="https://blog.csdn.net/turingbook/article/details/3954798" target="_blank" rel="noopener">https://blog.csdn.net/turingbook/article/details/3954798</a></p><p><a href="https://dev.to/joelnet/null-the-billion-dollar-mistake-maybe-just-nothing-1cak" target="_blank" rel="noopener">https://dev.to/joelnet/null-the-billion-dollar-mistake-maybe-just-nothing-1cak</a></p><p>关注公众号「Meandni」，及时阅读最新技术动态。</p><p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2009 年，&lt;strong&gt;快排算法的作者、1980 年图灵奖的得主&lt;/strong&gt; Tony Hoare 在伦敦的 QCon 大会上发表了一场主题为《Null References: The Billion Dollar Mistake》的演讲，这场本该积极活跃的分享
      
    
    </summary>
    
      <category term="flutter" scheme="https://meandni.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="Dart" scheme="https://meandni.com/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>Flutter Navigator 2.0 全面解析</title>
    <link href="https://meandni.com/2020/10/05/flutter-navigator2-and-router/"/>
    <id>https://meandni.com/2020/10/05/flutter-navigator2-and-router/</id>
    <published>2020-10-05T09:46:19.000Z</published>
    <updated>2020-10-18T07:54:28.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter-Navigator-2-0-全面解析"><a href="#Flutter-Navigator-2-0-全面解析" class="headerlink" title="Flutter Navigator 2.0 全面解析"></a>Flutter Navigator 2.0 全面解析</h2><p>随着最新版本的的发布，<a href="https://mp.weixin.qq.com/s/ea4O4pJ1vzUfqv3j3aMqCQ" target="_blank" rel="noopener">Flutter 1.22</a> 中各个全新的功能映入了我们的眼帘，可以发现本次对路由相关 API 的改动最大，官方的设计文档中表示，由于传统的命令式并<strong>没有给开发者一种灵活的方式去直接管理路由栈</strong>，甚至觉得已经过时了，一点也不 Flutter。</p><blockquote><p>As mentioned by a participant in one of Flutter’s user studies, the API also feels outdated and not very Flutter-y.</p><p>—— <a href="https://docs.google.com/document/d/1Q0jx0l4-xymph9O6zLaOY4d_f7YFpNWX_eGbzYxr9wY/edit" target="_blank" rel="noopener">Flutter Navigator 2.0 and Router</a></p></blockquote><p>而 Navigator 2.0 引入了一套全新的声明式 API，与以往不同，这类 API 可以实现<strong>用一组声明式的不可变的 Page 页面列表表示应用中的历史路由页面</strong>，从而转换成实际代码中 Navigator 的 Routes，这<strong>与 Flutter 中将不可变的 Widgets 解析成 Elements 并在页面中渲染的原理不谋而合</strong>，倒是 Flutter 十足。本文，我们就先从 Navigator 1.0 讲起逐步了解 Navigator 2.0 的实现方式。 </p><h3 id="Navigator-1-0"><a href="#Navigator-1-0" class="headerlink" title="Navigator 1.0"></a>Navigator 1.0</h3><p>在  Navigator 2.0 推出之前，我们在应用中通常使用下面这两个类来管理各个页面：</p><ul><li><strong>Navigator</strong>，管理一组 <code>Route</code> 对象。</li><li><strong>Route</strong>，一个 <code>Route</code> 通常可以表示一个页面，被 <code>Navigator</code> 持有，常用的两个实现类是  <code>MaterialPageRoute</code> 和 <code>CupertinoPageRoute</code> 。</li></ul><p><code>Route</code> 可以通过命名路由和组件路由（匿名路由）的方式被 push 进或者 pop 出 <code>Navigator</code> 的路由栈。我们先来简单回顾一下之前的传统用法。</p><h4 id="组件路由"><a href="#组件路由" class="headerlink" title="组件路由"></a>组件路由</h4><p>传统路由的实现中，Flutter 的各个页面由 <code>Navigator</code> 组织，彼此叠放成一个 “路由栈”，常用的根组件 <code>MaterialApp</code>和<code>CupertinoApp</code> 底层就是通过 <code>Navigator</code> 来实现全局路由的管理的，我们可以通过 <code>Navigator.of()</code> 或者 <code>Navigator.push()</code>、<code>Navigator.pop()</code> 等接口实现多个页面之间的导航，具体做法如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(Nav2App());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nav2App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: HomeScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: FlatButton(</span><br><span class="line">          child: Text(<span class="string">'View Details'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">// 打开页面</span></span><br><span class="line">            Navigator.push(</span><br><span class="line">              context,</span><br><span class="line">              MaterialPageRoute(builder: (context) &#123;</span><br><span class="line">                <span class="keyword">return</span> DetailScreen();</span><br><span class="line">              &#125;),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: FlatButton(</span><br><span class="line">          child: Text(<span class="string">'Pop!'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">// 弹出页面</span></span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>push()</code> 方法时，<code>DetailScreen</code> 组件就会被放置在 <code>HomeScreen</code> 的顶部，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-05-1*v77nG0BRIWrOghj8fCq_EA-20201005211028004.png" alt=""></p><p>此时，上一个页面（<code>HomeScreen</code>）仍在组件树中，因此当 <code>DetailScreen</code>  打开时它的状态依旧会被保留。</p><h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><p>Flutter 还支持通过命名路由的方式打开页面，各个页面的名称组成 “路由表” 通过参数（routes）传递给  <code>MaterialApp</code>、<code>CupertinoApp</code>，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(Nav2App());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nav2App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      <span class="comment">// 路由表</span></span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">'/'</span>: (context) =&gt; HomeScreen(),</span><br><span class="line">        <span class="string">'/details'</span>: (context) =&gt; DetailScreen(),</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: FlatButton(</span><br><span class="line">          child: Text(<span class="string">'View Details'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.pushNamed(</span><br><span class="line">              context,</span><br><span class="line">              <span class="string">'/details'</span>,</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: FlatButton(</span><br><span class="line">          child: Text(<span class="string">'Pop!'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命名路由时都需要预先定义好需要打开的页面，尽管我们也可以在各个页面之间传递数据，但这种方式原生并不支持直接解析路由参数，如不能使用 Web 应用中的链接形式 <code>/details/:id</code> 的路由名称。</p><h4 id="onGenerateRoute"><a href="#onGenerateRoute" class="headerlink" title="onGenerateRoute"></a>onGenerateRoute</h4><p>当然，我们可以使用 <code>onGenerateRoute</code> 来接受路由的完整路径，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onGenerateRoute: (settings) &#123;</span><br><span class="line">  <span class="comment">// Handle '/'</span></span><br><span class="line">  <span class="keyword">if</span> (settings.name == <span class="string">'/'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialPageRoute(builder: (context) =&gt; HomeScreen());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Handle '/details/:id'</span></span><br><span class="line">  <span class="keyword">var</span> uri = <span class="built_in">Uri</span>.parse(settings.name);</span><br><span class="line">  <span class="keyword">if</span> (uri.pathSegments.length == <span class="number">2</span> &amp;&amp;</span><br><span class="line">      uri.pathSegments.first == <span class="string">'details'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> id = uri.pathSegments[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> MaterialPageRoute(builder: (context) =&gt; DetailScreen(id: id));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> MaterialPageRoute(builder: (context) =&gt; UnknownScreen());</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(Nav2App());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nav2App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      onGenerateRoute: (settings) &#123;</span><br><span class="line">        <span class="comment">// Handle '/'</span></span><br><span class="line">        <span class="keyword">if</span> (settings.name == <span class="string">'/'</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> MaterialPageRoute(builder: (context) =&gt; HomeScreen());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle '/details/:id'</span></span><br><span class="line">        <span class="keyword">var</span> uri = <span class="built_in">Uri</span>.parse(settings.name);</span><br><span class="line">        <span class="keyword">if</span> (uri.pathSegments.length == <span class="number">2</span> &amp;&amp;</span><br><span class="line">            uri.pathSegments.first == <span class="string">'details'</span>) &#123;</span><br><span class="line">          <span class="keyword">var</span> id = uri.pathSegments[<span class="number">1</span>];</span><br><span class="line">          <span class="keyword">return</span> MaterialPageRoute(builder: (context) =&gt; DetailScreen(id: id));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> MaterialPageRoute(builder: (context) =&gt; UnknownScreen());</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: FlatButton(</span><br><span class="line">          child: Text(<span class="string">'View Details'</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.pushNamed(</span><br><span class="line">              context,</span><br><span class="line">              <span class="string">'/details/1'</span>,</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> id;</span><br><span class="line"></span><br><span class="line">  DetailScreen(&#123;</span><br><span class="line">    <span class="keyword">this</span>.id,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: [</span><br><span class="line">            Text(<span class="string">'Viewing details for item <span class="subst">$id</span>'</span>),</span><br><span class="line">            FlatButton(</span><br><span class="line">              child: Text(<span class="string">'Pop!'</span>),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Navigator.pop(context);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnknownScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(<span class="string">'404!'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们可以通过 <code>RouteSettings</code> 类型的对象  <code>settings</code>  可以拿到 <code>Navigator.pushNamed</code> 调用时传入的参数。</p><h3 id="Navigator-2-0"><a href="#Navigator-2-0" class="headerlink" title="Navigator 2.0"></a>Navigator 2.0</h3><p>Navigator 2.0 提供了一系列全新的接口，可以实现将路由状态成为应用状态的一部分，并能够通过底层 API 实现参数解析的功能，新增的 API 如下：</p><p>Navigator 2.0 API 向框架添加了新类，以使应用程序的屏幕成为应用程序状态的功能，并提供解析来自底层平台（如 Web URL）的路由的功能。以下是新功能概述：</p><ul><li><strong>Page</strong>，用来表示 <code>Navigator</code> 路由栈中各个页面的配置信息。</li><li><strong>Router</strong>，用来制定要由 <code>Navigator</code> 展示的页面列表，通常，该页面列表会根据系统或应用程序的状态改变而改变。</li><li><p><strong>RouteInformationParser</strong>，持有 <code>RouteInformationProvider</code> 提供的  <code>RouteInformation</code>  ，可以将其解析为我们定义的数据类型。</p></li><li><p><strong>RouterDelegate</strong>，定义应用程序中的路由行为，例如 Router 如何知道应用程序状态的变化以及如何响应。主要的工作就是监听  <code>RouteInformationParser</code> 和应用状态并通过当前页面列表构建 ·。</p></li><li><strong>BackButtonDispatcher</strong>，响应后退按钮，并通知 <code>Router</code></li></ul><p>下图展示了 <code>RouterDelegate</code> 与 <code>Router</code>、<code>RouteInformationParser</code> 以及用用状态的交互原理，</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-05-1*hNt4Bc8FZBp_Gqh7iED3FA-20201005211116296.png" alt=""></p><p>大致流程如下：</p><ol><li>当系统打开新页面（如 <code>“books / 2”</code>）时，<code>RouteInformationParser</code> 会将其转换为应用中的具体数据类型 T（如 <code>BooksRoutePath</code>）。</li><li>该数据类型会被传递给 <code>RouterDelegate</code> 的 <code>setNewRoutePath</code> 方法，我们可以在这里更新路由状态（如通过设置 <code>selectedBookId</code>）并调用 <code>notifyListeners</code> 响应该操作。</li><li><code>notifyListeners</code> 会通知 <code>Router</code> 重建 <code>RouterDelegate</code>（通过 <code>build()</code> 方法）.</li><li><code>RouterDelegate.build()</code> 返回一个新的 <code>Navigator</code> 实例，并最终展示出我们想要打开的页面（如 <code>selectedBookId</code>）。</li></ol><h3 id="Navigator-2-0-实战"><a href="#Navigator-2-0-实战" class="headerlink" title="Navigator 2.0 实战"></a>Navigator 2.0 实战</h3><p>下面，我们就来使用 Navigator 2.0 做一个小小练习，我们将实现一个 Flutter 应用，该应用作用在 Web 上时路由状态会与浏览器中的 URL 连接保持一致，而且也能够处理浏览器的回退按钮，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-05-1*PYHrYurwAGyQC8vsnAaWiA-20201005211118238.gif" alt=""></p><p>接下来，使用 <code>flutter channel master</code> 将 Flutter 切换到 master 版本，<a href="https://flutter.dev/docs/get-started/web#create-a-new-project-with-web-support" target="_blank" rel="noopener">创建一个支持 Web 应用的 Flutter 项目</a>，<code>lib/main.dart</code> 中的代码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(BooksApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> author;</span><br><span class="line"></span><br><span class="line">  Book(<span class="keyword">this</span>.title, <span class="keyword">this</span>.author);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _BooksAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BooksAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BooksApp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Books App'</span>,</span><br><span class="line">      home: Navigator(</span><br><span class="line">        pages: [</span><br><span class="line">          MaterialPage(</span><br><span class="line">            key: ValueKey(<span class="string">'BooksListPage'</span>),</span><br><span class="line">            child: Scaffold(),</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">        onPopPage: (route, result) =&gt; route.didPop(result),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Pages"><a href="#Pages" class="headerlink" title="Pages"></a>Pages</h4><p><code>Navigator</code> 接受一个 <code>pages</code> 参数，如果 Page 列表发生变化，<code>Navigator</code> 也需要更新当前路由栈来保持同步，下面我们就来使用该性质，在新建的项目中开发一个可以展示书单列表的应用</p><p><code>_BooksAppState</code> 中持有两个状态参数：书单列表和当前所选书籍：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BooksAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BooksApp</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// New:</span></span><br><span class="line">  Book _selectedBook;</span><br><span class="line">  <span class="built_in">bool</span> show404 = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">List</span>&lt;Book&gt; books = [</span><br><span class="line">    Book(<span class="string">'Stranger in a Strange Land'</span>, <span class="string">'Robert A. Heinlein'</span>),</span><br><span class="line">    Book(<span class="string">'Foundation'</span>, <span class="string">'Isaac Asimov'</span>),</span><br><span class="line">    Book(<span class="string">'Fahrenheit 451'</span>, <span class="string">'Ray Bradbury'</span>),</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>然后，在中<code>_BooksAppState</code>，返回一个带有 <code>Page</code> 对象列表的 <code>Navigator</code> ：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> MaterialApp(</span><br><span class="line">    title: <span class="string">'Books App'</span>,</span><br><span class="line">    home: Navigator(</span><br><span class="line">      pages: [</span><br><span class="line">        MaterialPage(</span><br><span class="line">          key: ValueKey(<span class="string">'BooksListPage'</span>),</span><br><span class="line">          child: BooksListScreen(</span><br><span class="line">            books: books,</span><br><span class="line">            onTapped: _handleBookTapped,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _handleBookTapped(Book book) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _selectedBook = book;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Book&gt; books;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;Book&gt; onTapped;</span><br><span class="line">BooksListScreen(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.books,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onTapped,</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: ListView(</span><br><span class="line">        children: [</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)</span><br><span class="line">            ListTile(</span><br><span class="line">              title: Text(book.title),</span><br><span class="line">              subtitle: Text(book.author),</span><br><span class="line">              onTap: () =&gt; onTapped(book),</span><br><span class="line">            )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于此应用会有两个页面（一个书单列表也和一个详情的页面），如果选择了某本书（使用 <a href="https://dart.dev/guides/language/language-tour#collection-operators" target="_blank" rel="noopener">collection if</a>），则会加入详细页：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">pages: [</span><br><span class="line">  MaterialPage(</span><br><span class="line">    key: ValueKey(<span class="string">'BooksListPage'</span>),</span><br><span class="line">    child: BooksListScreen(</span><br><span class="line">      books: books,</span><br><span class="line">      onTapped: _handleBookTapped,</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line"><span class="comment">// New:</span></span><br><span class="line">  <span class="keyword">if</span> (show404)</span><br><span class="line">    MaterialPage(key: ValueKey(<span class="string">'UnknownPage'</span>), child: UnknownScreen())</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_selectedBook != <span class="keyword">null</span>)</span><br><span class="line">    MaterialPage(</span><br><span class="line">        key: ValueKey(_selectedBook),</span><br><span class="line">        child: BookDetailsScreen(book: _selectedBook))</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>注意，这里的 key 会由 book 对象中的值定义作为 <code>MaterialPage</code> 的唯一标识，也就是说，book 对象不同这里的 <code>MaterialPage</code> 就不同。没有唯一的 key，框架就无法确定何时显示不同 Page 之间的过渡动画。</p><p>我们还可以继承 <code>Page</code> 来实现自定义行为，例如，在该页面添加了自定义过渡动画：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailsPage</span> <span class="keyword">extends</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Book book;</span><br><span class="line">  </span><br><span class="line">  BookDetailsPage(&#123;</span><br><span class="line">    <span class="keyword">this</span>.book,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: ValueKey(book));</span><br><span class="line">  </span><br><span class="line">  Route createRoute(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> PageRouteBuilder(</span><br><span class="line">      settings: <span class="keyword">this</span>,</span><br><span class="line">      pageBuilder: (context, animation, animation2) &#123;</span><br><span class="line">        <span class="keyword">final</span> tween = Tween(begin: Offset(<span class="number">0.0</span>, <span class="number">1.0</span>), end: Offset.zero);</span><br><span class="line">        <span class="keyword">final</span> curveTween = CurveTween(curve: Curves.easeInOut);</span><br><span class="line">        <span class="keyword">return</span> SlideTransition(</span><br><span class="line">          position: animation.drive(curveTween).drive(tween),</span><br><span class="line">          child: BookDetailsScreen(</span><br><span class="line">            key: ValueKey(book),</span><br><span class="line">            book: book,</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要注意的是，只传入 pages 参数而不传入 <code>onPopPage</code> 也会报错，他接受一个回调函数，每次 <code>Navigator.pop()</code> 被调用时就会出发这个函数，我们可以在其中更新路由状态</p><p>最后，在<code>pages</code>不提供<code>onPopPage</code>回调的情况下提供参数是错误的。每次调用时都会<code>Navigator.pop()</code>调用此函数。应该使用它来更新状态（修改页面列表），这里我们需要调用 <code>didPop</code> 方法确定是否 pop 成功：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">onPopPage: (route, result) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!route.didPop(result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the list of pages by setting _selectedBook to null</span></span><br><span class="line">  setState(() &#123;</span><br><span class="line">    _selectedBook = <span class="keyword">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>我们还必须在更新应用程序状态之前检查是否 pop 失败。这里，我们使用了 <code>setState</code> 方法来通知 Flutter 调用 <code>build()</code> 方法，该方法 <code>_selectedBook</code> 为 null 表示展示书单列表页。</p><p>完整代码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(BooksApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> author;</span><br><span class="line"></span><br><span class="line">  Book(<span class="keyword">this</span>.title, <span class="keyword">this</span>.author);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _BooksAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BooksAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BooksApp</span>&gt; </span>&#123;</span><br><span class="line">  Book _selectedBook;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;Book&gt; books = [</span><br><span class="line">    Book(<span class="string">'Stranger in a Strange Land'</span>, <span class="string">'Robert A. Heinlein'</span>),</span><br><span class="line">    Book(<span class="string">'Foundation'</span>, <span class="string">'Isaac Asimov'</span>),</span><br><span class="line">    Book(<span class="string">'Fahrenheit 451'</span>, <span class="string">'Ray Bradbury'</span>),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Books App'</span>,</span><br><span class="line">      home: Navigator(</span><br><span class="line">        pages: [</span><br><span class="line">          MaterialPage(</span><br><span class="line">            key: ValueKey(<span class="string">'BooksListPage'</span>),</span><br><span class="line">            child: BooksListScreen(</span><br><span class="line">              books: books,</span><br><span class="line">              onTapped: _handleBookTapped,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">if</span> (_selectedBook != <span class="keyword">null</span>) BookDetailsPage(book: _selectedBook)</span><br><span class="line">        ],</span><br><span class="line">        onPopPage: (route, result) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!route.didPop(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Update the list of pages by setting _selectedBook to null</span></span><br><span class="line">          setState(() &#123;</span><br><span class="line">            _selectedBook = <span class="keyword">null</span>;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleBookTapped(Book book) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _selectedBook = book;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailsPage</span> <span class="keyword">extends</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Book book;</span><br><span class="line"></span><br><span class="line">  BookDetailsPage(&#123;</span><br><span class="line">    <span class="keyword">this</span>.book,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: ValueKey(book));</span><br><span class="line"></span><br><span class="line">  Route createRoute(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialPageRoute(</span><br><span class="line">      settings: <span class="keyword">this</span>,</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> BookDetailsScreen(book: book);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Book&gt; books;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;Book&gt; onTapped;</span><br><span class="line"></span><br><span class="line">  BooksListScreen(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.books,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onTapped,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: ListView(</span><br><span class="line">        children: [</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)</span><br><span class="line">            ListTile(</span><br><span class="line">              title: Text(book.title),</span><br><span class="line">              subtitle: Text(book.author),</span><br><span class="line">              onTap: () =&gt; onTapped(book),</span><br><span class="line">            )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailsScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Book book;</span><br><span class="line"></span><br><span class="line">  BookDetailsScreen(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.book,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Padding(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">        child: Column(</span><br><span class="line">          crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">          children: [</span><br><span class="line">            <span class="keyword">if</span> (book != <span class="keyword">null</span>) ...[</span><br><span class="line">              Text(book.title, style: Theme.of(context).textTheme.headline6),</span><br><span class="line">              Text(book.author, style: Theme.of(context).textTheme.subtitle1),</span><br><span class="line">            ],</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前，我们就实现了声明式的路由管理，单此时我们还无法处理浏览器的后退按钮，也不能同步浏览器地址拦中的链接。</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>本节，我们来实现通过  <code>RouteInformationParser</code>, <code>RouterDelegate</code> 更新路由状态，实现与浏览器地址拦中的链接同步</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>首先，我们需要通过 <code>RouteInformationParser</code> 将路由信息解析为指定的数据类型：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookRoutePath</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> id;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isUnknown;</span><br><span class="line"></span><br><span class="line">  BookRoutePath.home()</span><br><span class="line">      : id = <span class="keyword">null</span>,</span><br><span class="line">        isUnknown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  BookRoutePath.details(<span class="keyword">this</span>.id) : isUnknown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  BookRoutePath.unknown()</span><br><span class="line">      : id = <span class="keyword">null</span>,</span><br><span class="line">        isUnknown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isHomePage =&gt; id == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isDetailsPage =&gt; id != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该应用程序中，可以使用 <code>BookRoutePath</code> 类来表示应用程序中的路由路径，我们也可以实现父子类来关系其他各类型的路由信息。</p><h4 id="RouterDelegate"><a href="#RouterDelegate" class="headerlink" title="RouterDelegate"></a>RouterDelegate</h4><p>接下来，我们实现一个 <code>RouterDelegate</code> 的子类 <code>BookRouterDelegate</code>：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookRouterDelegate</span> <span class="keyword">extends</span> <span class="title">RouterDelegate</span>&lt;<span class="title">BookRoutePath</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">ChangeNotifier</span>, <span class="title">PopNavigatorRouterDelegateMixin</span>&lt;<span class="title">BookRoutePath</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">throw</span> UnimplementedError();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  GlobalKey&lt;NavigatorState&gt; <span class="keyword">get</span> navigatorKey =&gt; <span class="keyword">throw</span> UnimplementedError();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; setNewRoutePath(BookRoutePath configuration) &#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="keyword">throw</span> UnimplementedError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>BookRouterDelegate</code> 的泛型为 <code>BookRoutePath</code>，其中包含了决定显示哪个页面所需的所有状态。</p><p>此时，我们就可以将 <code>_BooksAppState</code> 中的路由相关的逻辑放到 <code>BookRouterDelegate</code> 中，这里，我们创建了一个 <code>GlobalKey</code> 对象，其他各个状态也都保存在这里面： </p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookRouterDelegate</span> <span class="keyword">extends</span> <span class="title">RouterDelegate</span>&lt;<span class="title">BookRoutePath</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">ChangeNotifier</span>, <span class="title">PopNavigatorRouterDelegateMixin</span>&lt;<span class="title">BookRoutePath</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> GlobalKey&lt;NavigatorState&gt; navigatorKey;</span><br><span class="line"></span><br><span class="line">  Book _selectedBook;</span><br><span class="line">  <span class="built_in">bool</span> show404 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;Book&gt; books = [</span><br><span class="line">    Book(<span class="string">'Stranger in a Strange Land'</span>, <span class="string">'Robert A. Heinlein'</span>),</span><br><span class="line">    Book(<span class="string">'Foundation'</span>, <span class="string">'Isaac Asimov'</span>),</span><br><span class="line">    Book(<span class="string">'Fahrenheit 451'</span>, <span class="string">'Ray Bradbury'</span>),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  BookRouterDelegate() : navigatorKey = GlobalKey&lt;NavigatorState&gt;();</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>为了能在 URL 中显示正确的路径，我们也需要根据应用程序的当前状态返回一个  <code>BookRoutePath</code>  对象：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BookRoutePath <span class="keyword">get</span> currentConfiguration &#123;</span><br><span class="line">  <span class="keyword">if</span> (show404) &#123;</span><br><span class="line">    <span class="keyword">return</span> BookRoutePath.unknown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _selectedBook == <span class="keyword">null</span></span><br><span class="line">      ? BookRoutePath.home()</span><br><span class="line">      : BookRoutePath.details(books.indexOf(_selectedBook));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，<code>build</code> 方法返回一个 <code>Navigator</code> 组件：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Navigator(</span><br><span class="line">    key: navigatorKey,</span><br><span class="line">    pages: [</span><br><span class="line">      MaterialPage(</span><br><span class="line">        key: ValueKey(<span class="string">'BooksListPage'</span>),</span><br><span class="line">        child: BooksListScreen(</span><br><span class="line">          books: books,</span><br><span class="line">          onTapped: _handleBookTapped,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      <span class="keyword">if</span> (show404)</span><br><span class="line">        MaterialPage(key: ValueKey(<span class="string">'UnknownPage'</span>), child: UnknownScreen())</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (_selectedBook != <span class="keyword">null</span>)</span><br><span class="line">        BookDetailsPage(book: _selectedBook)</span><br><span class="line">    ],</span><br><span class="line">    onPopPage: (route, result) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!route.didPop(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Update the list of pages by setting _selectedBook to null</span></span><br><span class="line">      _selectedBook = <span class="keyword">null</span>;</span><br><span class="line">      show404 = <span class="keyword">false</span>;</span><br><span class="line">      notifyListeners();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为该类并不是组件，而是由 <code>ChangeNotifier</code> 实现，因此这里的 <code>onPopPage</code> 方法需要使用 <code>notifyListeners</code> 替代 <code>setState</code> 来改变状态，当 <code>RouterDelegate</code> 触发状态更新时，<code>Router</code> 同样会触发 <code>RouterDelegate</code> 的 <code>currentConfiguration</code> 方法并调用 <code>build</code> 方法创建出一个新的 <code>Navigator</code> 组件。</p><p><code>_handleBookTapped</code>方法也需要使用 <code>notifyListeners</code> 代替 <code>setState</code>：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _handleBookTapped(Book book) &#123;</span><br><span class="line">  _selectedBook = book;</span><br><span class="line">  notifyListeners();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新页面打开后，<code>Router</code> 会调用<code>setNewRoutePath</code> 方法来更新应用程序的路由状态：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; setNewRoutePath(BookRoutePath path) <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (path.isUnknown) &#123;</span><br><span class="line">    _selectedBook = <span class="keyword">null</span>;</span><br><span class="line">    show404 = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (path.isDetailsPage) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.id &lt; <span class="number">0</span> || path.id &gt; books.length - <span class="number">1</span>) &#123;</span><br><span class="line">      show404 = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _selectedBook = books[path.id];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _selectedBook = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  show404 = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RouteInformationParser"><a href="#RouteInformationParser" class="headerlink" title="RouteInformationParser"></a>RouteInformationParser</h4><p><code>RouteInformationParser</code> 内部含有一个钩子函数，接受路由信息（<code>RouteInformation</code>），我们可以在这里将它转换成指定的数据类型（<code>BookRoutePath</code>）并使用 Uri 解析：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookRouteInformationParser</span> <span class="keyword">extends</span> <span class="title">RouteInformationParser</span>&lt;<span class="title">BookRoutePath</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;BookRoutePath&gt; parseRouteInformation(</span><br><span class="line">      RouteInformation routeInformation) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> uri = <span class="built_in">Uri</span>.parse(routeInformation.location);</span><br><span class="line">    <span class="comment">// Handle '/'</span></span><br><span class="line">    <span class="keyword">if</span> (uri.pathSegments.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> BookRoutePath.home();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle '/book/:id'</span></span><br><span class="line">    <span class="keyword">if</span> (uri.pathSegments.length == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (uri.pathSegments[<span class="number">0</span>] != <span class="string">'book'</span>) <span class="keyword">return</span> BookRoutePath.unknown();</span><br><span class="line">      <span class="keyword">var</span> remaining = uri.pathSegments[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">var</span> id = <span class="built_in">int</span>.tryParse(remaining);</span><br><span class="line">      <span class="keyword">if</span> (id == <span class="keyword">null</span>) <span class="keyword">return</span> BookRoutePath.unknown();</span><br><span class="line">      <span class="keyword">return</span> BookRoutePath.details(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle unknown routes</span></span><br><span class="line">    <span class="keyword">return</span> BookRoutePath.unknown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RouteInformation restoreRouteInformation(BookRoutePath path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.isUnknown) &#123;</span><br><span class="line">      <span class="keyword">return</span> RouteInformation(location: <span class="string">'/404'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path.isHomePage) &#123;</span><br><span class="line">      <span class="keyword">return</span> RouteInformation(location: <span class="string">'/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path.isDetailsPage) &#123;</span><br><span class="line">      <span class="keyword">return</span> RouteInformation(location: <span class="string">'/book/<span class="subst">$&#123;path.id&#125;</span>'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该实现仅针对此应用，并不是常规的路由解析解决方案，具体原理，我们以后再详细了解。最后，要使用这些定义好的类，我们还需要使用全新的 <code>MaterialApp.router</code> 构造函数并传入它们各自的实现：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> MaterialApp.router(</span><br><span class="line">  title: <span class="string">'Books App'</span>,</span><br><span class="line">  routerDelegate: _routerDelegate,</span><br><span class="line">  routeInformationParser: _routeInformationParser,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(BooksApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> author;</span><br><span class="line"></span><br><span class="line">  Book(<span class="keyword">this</span>.title, <span class="keyword">this</span>.author);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksApp</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;StatefulWidget&gt; createState() =&gt; _BooksAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BooksAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BooksApp</span>&gt; </span>&#123;</span><br><span class="line">  BookRouterDelegate _routerDelegate = BookRouterDelegate();</span><br><span class="line">  BookRouteInformationParser _routeInformationParser =</span><br><span class="line">      BookRouteInformationParser();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp.router(</span><br><span class="line">      title: <span class="string">'Books App'</span>,</span><br><span class="line">      routerDelegate: _routerDelegate,</span><br><span class="line">      routeInformationParser: _routeInformationParser,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookRouteInformationParser</span> <span class="keyword">extends</span> <span class="title">RouteInformationParser</span>&lt;<span class="title">BookRoutePath</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;BookRoutePath&gt; parseRouteInformation(</span><br><span class="line">      RouteInformation routeInformation) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> uri = <span class="built_in">Uri</span>.parse(routeInformation.location);</span><br><span class="line">    <span class="comment">// Handle '/'</span></span><br><span class="line">    <span class="keyword">if</span> (uri.pathSegments.length == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> BookRoutePath.home();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle '/book/:id'</span></span><br><span class="line">    <span class="keyword">if</span> (uri.pathSegments.length == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (uri.pathSegments[<span class="number">0</span>] != <span class="string">'book'</span>) <span class="keyword">return</span> BookRoutePath.unknown();</span><br><span class="line">      <span class="keyword">var</span> remaining = uri.pathSegments[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">var</span> id = <span class="built_in">int</span>.tryParse(remaining);</span><br><span class="line">      <span class="keyword">if</span> (id == <span class="keyword">null</span>) <span class="keyword">return</span> BookRoutePath.unknown();</span><br><span class="line">      <span class="keyword">return</span> BookRoutePath.details(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle unknown routes</span></span><br><span class="line">    <span class="keyword">return</span> BookRoutePath.unknown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RouteInformation restoreRouteInformation(BookRoutePath path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.isUnknown) &#123;</span><br><span class="line">      <span class="keyword">return</span> RouteInformation(location: <span class="string">'/404'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path.isHomePage) &#123;</span><br><span class="line">      <span class="keyword">return</span> RouteInformation(location: <span class="string">'/'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path.isDetailsPage) &#123;</span><br><span class="line">      <span class="keyword">return</span> RouteInformation(location: <span class="string">'/book/<span class="subst">$&#123;path.id&#125;</span>'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookRouterDelegate</span> <span class="keyword">extends</span> <span class="title">RouterDelegate</span>&lt;<span class="title">BookRoutePath</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">ChangeNotifier</span>, <span class="title">PopNavigatorRouterDelegateMixin</span>&lt;<span class="title">BookRoutePath</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> GlobalKey&lt;NavigatorState&gt; navigatorKey;</span><br><span class="line"></span><br><span class="line">  Book _selectedBook;</span><br><span class="line">  <span class="built_in">bool</span> show404 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">List</span>&lt;Book&gt; books = [</span><br><span class="line">    Book(<span class="string">'Stranger in a Strange Land'</span>, <span class="string">'Robert A. Heinlein'</span>),</span><br><span class="line">    Book(<span class="string">'Foundation'</span>, <span class="string">'Isaac Asimov'</span>),</span><br><span class="line">    Book(<span class="string">'Fahrenheit 451'</span>, <span class="string">'Ray Bradbury'</span>),</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  BookRouterDelegate() : navigatorKey = GlobalKey&lt;NavigatorState&gt;();</span><br><span class="line"></span><br><span class="line">  BookRoutePath <span class="keyword">get</span> currentConfiguration &#123;</span><br><span class="line">    <span class="keyword">if</span> (show404) &#123;</span><br><span class="line">      <span class="keyword">return</span> BookRoutePath.unknown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _selectedBook == <span class="keyword">null</span></span><br><span class="line">        ? BookRoutePath.home()</span><br><span class="line">        : BookRoutePath.details(books.indexOf(_selectedBook));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator(</span><br><span class="line">      key: navigatorKey,</span><br><span class="line">      pages: [</span><br><span class="line">        MaterialPage(</span><br><span class="line">          key: ValueKey(<span class="string">'BooksListPage'</span>),</span><br><span class="line">          child: BooksListScreen(</span><br><span class="line">            books: books,</span><br><span class="line">            onTapped: _handleBookTapped,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        <span class="keyword">if</span> (show404)</span><br><span class="line">          MaterialPage(key: ValueKey(<span class="string">'UnknownPage'</span>), child: UnknownScreen())</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_selectedBook != <span class="keyword">null</span>)</span><br><span class="line">          BookDetailsPage(book: _selectedBook)</span><br><span class="line">      ],</span><br><span class="line">      onPopPage: (route, result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!route.didPop(result)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the list of pages by setting _selectedBook to null</span></span><br><span class="line">        _selectedBook = <span class="keyword">null</span>;</span><br><span class="line">        show404 = <span class="keyword">false</span>;</span><br><span class="line">        notifyListeners();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; setNewRoutePath(BookRoutePath path) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.isUnknown) &#123;</span><br><span class="line">      _selectedBook = <span class="keyword">null</span>;</span><br><span class="line">      show404 = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path.isDetailsPage) &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.id &lt; <span class="number">0</span> || path.id &gt; books.length - <span class="number">1</span>) &#123;</span><br><span class="line">        show404 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _selectedBook = books[path.id];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _selectedBook = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    show404 = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleBookTapped(Book book) &#123;</span><br><span class="line">    _selectedBook = book;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailsPage</span> <span class="keyword">extends</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Book book;</span><br><span class="line"></span><br><span class="line">  BookDetailsPage(&#123;</span><br><span class="line">    <span class="keyword">this</span>.book,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: ValueKey(book));</span><br><span class="line"></span><br><span class="line">  Route createRoute(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialPageRoute(</span><br><span class="line">      settings: <span class="keyword">this</span>,</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> BookDetailsScreen(book: book);</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookRoutePath</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> id;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isUnknown;</span><br><span class="line"></span><br><span class="line">  BookRoutePath.home()</span><br><span class="line">      : id = <span class="keyword">null</span>,</span><br><span class="line">        isUnknown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  BookRoutePath.details(<span class="keyword">this</span>.id) : isUnknown = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  BookRoutePath.unknown()</span><br><span class="line">      : id = <span class="keyword">null</span>,</span><br><span class="line">        isUnknown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isHomePage =&gt; id == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> isDetailsPage =&gt; id != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Book&gt; books;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;Book&gt; onTapped;</span><br><span class="line"></span><br><span class="line">  BooksListScreen(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.books,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onTapped,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: ListView(</span><br><span class="line">        children: [</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> book <span class="keyword">in</span> books)</span><br><span class="line">            ListTile(</span><br><span class="line">              title: Text(book.title),</span><br><span class="line">              subtitle: Text(book.author),</span><br><span class="line">              onTap: () =&gt; onTapped(book),</span><br><span class="line">            )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailsScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Book book;</span><br><span class="line"></span><br><span class="line">  BookDetailsScreen(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.book,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Padding(</span><br><span class="line">        padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">        child: Column(</span><br><span class="line">          crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">          children: [</span><br><span class="line">            <span class="keyword">if</span> (book != <span class="keyword">null</span>) ...[</span><br><span class="line">              Text(book.title, style: Theme.of(context).textTheme.headline6),</span><br><span class="line">              Text(book.author, style: Theme.of(context).textTheme.subtitle1),</span><br><span class="line">            ],</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnknownScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(<span class="string">'404!'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，在 Chrome 中运行该示例就会展示当前访问链接的路由页面，并在手动修改 URL 后也会导航到正确的页面。</p><h4 id="TransitionDelegate"><a href="#TransitionDelegate" class="headerlink" title="TransitionDelegate"></a>TransitionDelegate</h4><p>我们也可以通过 <code>TransitionDelegate</code> 实现自定义的路由动画。</p><p>首先，向 <code>Navigator</code> 传入一个自定义 <code>TransitionDelegate</code> 对象：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New:</span></span><br><span class="line">TransitionDelegate transitionDelegate = NoAnimationTransitionDelegate();</span><br><span class="line"></span><br><span class="line">      child: Navigator(</span><br><span class="line">        key: navigatorKey,</span><br><span class="line">        <span class="comment">// New:</span></span><br><span class="line">        transitionDelegate: transitionDelegate,</span><br></pre></td></tr></table></figure><p>例如，以下实现回关闭所有路由过渡动画：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoAnimationTransitionDelegate</span> <span class="keyword">extends</span> <span class="title">TransitionDelegate</span>&lt;<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">Iterable</span>&lt;RouteTransitionRecord&gt; resolve(&#123;</span><br><span class="line">    <span class="built_in">List</span>&lt;RouteTransitionRecord&gt; newPageRouteHistory,</span><br><span class="line">    <span class="built_in">Map</span>&lt;RouteTransitionRecord, RouteTransitionRecord&gt;</span><br><span class="line">        locationToExitingPageRoute,</span><br><span class="line">    <span class="built_in">Map</span>&lt;RouteTransitionRecord, <span class="built_in">List</span>&lt;RouteTransitionRecord&gt;&gt;</span><br><span class="line">        pageRouteToPagelessRoutes,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> results = &lt;RouteTransitionRecord&gt;[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> pageRoute <span class="keyword">in</span> newPageRouteHistory) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pageRoute.isWaitingForEnteringDecision) &#123;</span><br><span class="line">        pageRoute.markForAdd();</span><br><span class="line">      &#125;</span><br><span class="line">      results.add(pageRoute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> exitingPageRoute <span class="keyword">in</span> locationToExitingPageRoute.values) &#123;</span><br><span class="line">      <span class="keyword">if</span> (exitingPageRoute.isWaitingForExitingDecision) &#123;</span><br><span class="line">        exitingPageRoute.markForRemove();</span><br><span class="line">        <span class="keyword">final</span> pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];</span><br><span class="line">        <span class="keyword">if</span> (pagelessRoutes != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">final</span> pagelessRoute <span class="keyword">in</span> pagelessRoutes) &#123;</span><br><span class="line">            pagelessRoute.markForRemove();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      results.add(exitingPageRoute);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>NoAnimationTransitionDelegate</code> 重写了 <code>TransitionDelegate</code> 的 <code>resolve()</code> 方法，该方法可以指定各种路由页面过渡动画是否展示，有如下几个方法：</p><ul><li><p><code>markForPush</code> ，打开页面时使用过渡动画。</p></li><li><p><code>markForAdd</code>，打开页面时不使用过渡动画。</p></li><li><p><code>markForPop</code>，弹出页面时使用动画，并通知应用，即将该事件传递给 <code>AppRouterDelegate</code> 的 <code>onPopPage</code> 函数。</p></li><li><p><code>markForComplete</code> ，弹出页面时不使用过渡动画，同样会通知应用。</p></li><li><code>markForRemove</code> ，弹出页面时不使用过渡动画，不会通知应用。</li></ul><p>该类仅影响最新的声明式 API，因此后退按钮仍显示过渡动画。</p><p>大致流程如下：这里遍历了所有声明的页面，包括新页面（<code>newPageRouteHistory</code>）和已存在的页面（<code>locationToExitingPageRoute</code>），使用上述几个方法标记它们。在新页面中使用 <code>markForAdd</code> 去除打开的过渡动画，<code>locationToExitingPageRoute</code> 中则使用 <code>markForRemove</code> 不展示过渡动画，并不会通知应用。<a href="http://gist.github.com/5ce79aee5b5f83cfababa97c9cf0a204" target="_blank" rel="noopener">查看完整示例</a>。</p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>我们也提供了嵌套路由的示例，可以实现 <code>BottomAppBar</code> 中为每个 Tab 中的组件实现各自的路由栈，<a href="http://gist.github.com/bbca91e23bbb4d39247fa922533be7c9" target="_blank" rel="noopener">查看具体代码</a>。</p><h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><p>本文，我们主要探讨了如何针对这个特定的应用使用这些新的路由 API，大家可以以此为基础构建出更高级的实现，在后续的文章中我也会更深入的讨论关于 Navigator 2.0 的更多话题，欢迎关注公众号「MeandNi」。</p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p><a href="https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade" target="_blank" rel="noopener">https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade</a></p><p><a href="https://github.com/flutter/flutter/issues/12146" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/12146</a></p><p>关注公众号「Meandni」，及时阅读最新技术动态。</p><p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Flutter-Navigator-2-0-全面解析&quot;&gt;&lt;a href=&quot;#Flutter-Navigator-2-0-全面解析&quot; class=&quot;headerlink&quot; title=&quot;Flutter Navigator 2.0 全面解析&quot;&gt;&lt;/a&gt;Flutter 
      
    
    </summary>
    
      <category term="flutter" scheme="https://meandni.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="路由" scheme="https://meandni.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>选择合适的数据库（缓存、对象存储、SQL、NoSQL等）</title>
    <link href="https://meandni.com/2020/10/04/how-to-choose-database/"/>
    <id>https://meandni.com/2020/10/04/how-to-choose-database/</id>
    <published>2020-10-04T10:00:30.000Z</published>
    <updated>2020-10-18T07:54:25.658Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何为项目选择合适的数据库（缓存、对象存储、SQL、NoSQL等）"><a href="#如何为项目选择合适的数据库（缓存、对象存储、SQL、NoSQL等）" class="headerlink" title="如何为项目选择合适的数据库（缓存、对象存储、SQL、NoSQL等）"></a>如何为项目选择合适的数据库（缓存、对象存储、SQL、NoSQL等）</h3><p>数据库本身功能非常单一，仅可作为数据的存储介质，但错误的数据库选型带来的代价可能就是项目<strong>性能的大幅下降</strong>，对于很多企业应用来说这也是致命的伤害，另外，选择不同数据库类型同样会决定系统中其他模块的设计，因此，数据库选型对于整个项目非常重要，我们通常也称这种需求为<strong>非功能性需求（NFRs，non-functional requirements）</strong>，对于数据库，主要需要考虑如下三点因素：</p><ul><li><strong>数据结构</strong></li><li><strong>查询模式</strong></li><li><strong>数据规模</strong></li></ul><p>目前，市面上已经有各类存储解决方案了，本文我们就来讨论一下如何在这些方案中选择最适合自己的方案。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>如果项目需要<strong>频繁调用数据库 API 或者一些高延迟的远程服务</strong>，那么可能需要最先考虑在客户端和数据库之间使用缓存来降低延迟。目前，常用的缓存方案有 Memcached，Hazelcast，Redis，这些方案大同小异，但 Redis 使用最广泛且稳定，是目前国内最常用的数据库缓存解决方案。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-04-word-image-86.png" alt="缓存图示"></p><h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><p>如果需要开发一款抖音、B 站之类的产品，就<strong>需要存储大量图像、视频等数据</strong>，仅仅一个数据库可能并不能满足我们的需求，因为这时需要存储的是文件而非一般的数据信息，数据库本质依然只能用来查询信息数据而已，而文件本身也并不用“查询”，只需要按需拿到这整个文件即可，这种情况下，符合项目要求的解决方案就是<strong>对象（Blob）存储方案</strong>，如 Amazon S3，通常，Blob 存储方案还可以与 CDN 结合使用来减少延迟，这样就可以实现无地理位置差异提供内容服务。</p><h3 id="提供文本搜索功能"><a href="#提供文本搜索功能" class="headerlink" title="提供文本搜索功能"></a>提供文本搜索功能</h3><p>淘宝、京东这些大型应用都会提供内容的搜索功能，这样就可以方便用户按照商品类型、品牌对数据进行分类搜索，这种功能通常会使用 <strong>Solr</strong> 或 <strong>Elasticsearch</strong> 之类的搜索引擎服务，这类搜索服务通常也会支持<strong>模糊搜索</strong>，例如会考虑到用户拼写错误的情况，这会很大程度上提升用户体验。</p><p>但是，搜索引擎不是是数据库，并不能保证我们的数据不会丢失，因此我们不能使用 Elasticsearch 这类搜索引擎作为数据源，这里就需要我们配合两者使用，将数据库中的内容加载到 Elasticsearch 中来降低搜索延迟，然后在以此为基础提供搜索功能。</p><h3 id="时序数据库（TSDB，Time-series-database）"><a href="#时序数据库（TSDB，Time-series-database）" class="headerlink" title="时序数据库（TSDB，Time series database）"></a>时序数据库（TSDB，Time series database）</h3><p>时序数据库全称为时间序列数据库（Time series database），是关系型数据库的一种，<strong>主要用于处理带时间标签（按照时间的顺序变化，即时间序列化）的数据，带时间标签的数据也称为时间序列数据</strong>。</p><p>如果我们要开发的系统对时间特别敏感，如股票交易、财务分析系统，此时就需要经常对一定时间的内数据分析，如过去 1周，10天，1个月，1 年等等，TSDB 会以毫秒级的速度给出这些我们需要的数据，传统数据库很难做到这一点。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-04-2020-10-04-2020-10-04-downsample.png" alt=""></p><p>目前，市面上常用的时序数据库有 <strong>OpenTSDB、InfluxDB</strong> 等。</p><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>很多项目也会需要一类能够<strong>存储巨量数据的数据库</strong>，如滴滴需要存储所有订单信息来分析哪个城市、那个时间段为使用率最高，这些系统通常和常规用户可感知的交易不同，可以使用脱机类型的数据仓库。<strong>Hadoop</strong> 是目前主流的数据仓库解决方案。</p><h3 id="SQL-OR-NoSQL"><a href="#SQL-OR-NoSQL" class="headerlink" title="SQL OR NoSQL"></a>SQL OR NoSQL</h3><p>如文章开头所述，数据结构是我们用来做数据库选型时的重要因素之一，如果我们要存储结构化或者可以表格形式表示的数据，则可以使用关系型数据库。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-04-2020-10-04-2020-10-04-2020-10-04-2020-10-04-1*xtPrVMwIcya4ObgwTeg9GA-20201004224940857.jpeg" alt="关系型数据库"></p><p>同时，我们还将考虑数据库是否需要拥有 <strong>ACID</strong> 性质，即原子性（Atomicity），一致性（Consistency），隔离型（Isolation），持久性（Durability）四大性质。</p><ul><li><p><strong>原子性</strong>，保证所有操作要么全有要么全无。</p></li><li><p><strong>一致性</strong>，保证操作前后数据库状态一致。</p></li><li><strong>隔离性</strong>，意味着多个事务单独进行，一个事务将不受另一正在进行的并行事务的影响。这能保证数据库应该能够处理并发事务而不会导致数据不一致的情况。</li><li><strong>持久性</strong>，保证一旦事务完成，更改将被永久写入磁盘，并且不会因系统故障而丢失。</li></ul><p>如果我们的项目需要 ACID，则需要使用关系数据库（RDBMS），如 MySQL，Oracle，Postgres 等，但是，如果不需要 ACID，那么也可以<strong>非关系性数据库</strong>。</p><p>例如，项目中需要为商品建立目录索引，每个商品通常会有不同的属性和信息，如药品有保质期，冰箱有节能等级等等，再例如我们的用户表单中每位用户也可能会有不同的属性值，在这种情况下我们的数据就不能够以表格形式表示，可以选择使用 <strong>NoSQL</strong> 数据库。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-04-2020-10-04-2020-10-04-2020-10-04-1*--zqXFzt3rNFLF4hvkgX7Q-20201004224936367.jpeg" alt="文档型数据库"></p><p>另外，除了储存，我们通常还需要查询这些类型的得到数据，这就需要考虑<strong>查询模式</strong>这个要素，我们会根据存储的数据类型和查询类型来决定最终使用哪种数据库。如果项目中会含有大量数据，包括各种各样的属性和各种各种的查询请求，就需要使用文档型数据库（<strong>Document DB</strong>），如 <strong>Couchbase、MongoDB</strong>。</p><blockquote><p>Elasticsearch 和 Solr 也是特殊文档型数据库。</p></blockquote><p>如果我们的数据并没有各种各样的属性，查询类型也很有限，简单增删改查足以，但是数据库的存储量很大，如滴滴司机的位置，这类数据每时每刻都会增加，这种情况下，我们通常会使用柱状存储模型的数据库，也称<strong>列型（Columnar DBs）数据库</strong>，如 <strong>Cassandra、HBase</strong>。这类数据库每个列都有一个 column key 标识，每个 column key下对应若干 value，可以很轻松的获得包含某个列的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-04-2020-10-04-2020-10-04-1*4qcFp6XOvQj3_uf4_Jx-VA-20201004224928382.jpeg" alt="关系型中的行型数据库与列型数据库"></p><p>在个人的小型项目我们通常会选择 Cassandra，因为非常轻量而且部署起来非常方便，性能也完全不亚于 HBase，而 HBase 基于 Hadoop 显得过于臃肿。因此，我们可以说在数据查询时可以直接通过 where 语句指定 key 查询时，可以选择 Cassandra。</p><p>如果我们将滴滴中与打车相关的订单数据存储在 Cassandra 后，司机的 id 可以作为每个列分区的 column key，当我们想要查询特定时间段内该司机的路程，Cassandra 就可以立即帮我们在对应列中查询到这些数据，但这时，当我们想要查询某个日期内乘客的乘车记录，由于客户 ID 并不是分区 column key，因此 Cassandra 就需要查询整个分区，这时 Cassandra 性能就会大打折扣！</p><p>这种情况下，我们可以使用不同的分区 key 将相同的数据复制到另一个表或列中，这时，当我们收到有关客户 ID 和日期的查询时，我们可以将其直接定向到分区 kay 为客户 ID 的表中，这就是<strong>查询的种类少但数据量大</strong>的意思，只要查询的类型相似，Cassandra（和 HBase）就可以无限扩展，但如果查询的种类非常多的话，我们就必须为每个分区 key 一次又一次地复制，直到达到一定的限制。</p><p>如果我们不能控制查询的类型，还是选择采用 MongoDB 之类的方案，但是，如果我们只需要针对少数几种查询的大规模扩展，那么 Cassandra 就是完美的解决方案。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-04-2020-10-04-2020-10-04-2020-10-04-2020-10-04-choose-database.jpg" alt="数据库选择流程图"></p><p>现在，我们大概知道了基本的方向了，如果存储结构化数据并且需要 ACID 性质，则使用关系数据库（如 MySQL），如果存储具有许多属性的海量数据，则可以使用文档数据库（如 Mongo DB），如果数据非常简单，查询种类较少，则使用列式数据库（如 Cassandra），但是实际项目中，还并不这么简单。</p><h3 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h3><p>我们再以淘宝为例，对于一个商品来说，库存中只有一件，但是很多用户想要买，那么最终应该只能卖给一个用户，这就需要我们的数据库拥有 ACID 性质，因此，需要 MySql 这类关系型数据库，但是淘宝中的商品数据也在不断增加，属性也多种多样，我们也需要使用 Cassandra 这种列存储模型的 NoSQL 数据库。我们应该选择哪一种？在实际项目中，我们通常会混合使用这两种数据库，例如，将尚未交付的订单数据存储在 MySQL 数据库中，一旦订单完成，我们就可以将其移至 Cassandra 进行永久存储。</p><p>我们的需求还会变得更复杂，假如我们需要为购买商品的客户构建一个报告系统，淘宝上的商品通常会由不同品牌、不同版本向不同的客户出售，因此，报告也不能针对单个产品，而应针对产品的子集，这类需求可以使用 Cassandra 或 MySQL 实现，但是更好的方案是使用 Mongo DB 这类文档型数据库，我们可以将订单数据的子集保存在 MongoDB 中，这些数据可以告诉我们哪些用户在什么时候，什么日期购买了某种商品的数量。因此，如果我们要查询有多少人在上个月购买了 MacBook，我们可以从 MongoDB 中获得订单 ID，并使用此订单 ID 来从 Cassandra 或 MySQL 中查询其他的数据。</p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p><a href="https://www.influxdata.com/time-series-database/" target="_blank" rel="noopener">https://www.influxdata.com/time-series-database/</a></p><p><a href="https://en.wikipedia.org/wiki/Column-oriented_DBMS" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Column-oriented_DBMS</a></p><p>关注公众号「Meandni」，及时阅读最新技术动态。</p><p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何为项目选择合适的数据库（缓存、对象存储、SQL、NoSQL等）&quot;&gt;&lt;a href=&quot;#如何为项目选择合适的数据库（缓存、对象存储、SQL、NoSQL等）&quot; class=&quot;headerlink&quot; title=&quot;如何为项目选择合适的数据库（缓存、对象存储、SQL、
      
    
    </summary>
    
      <category term="深入理解计算机" scheme="https://meandni.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="数据库" scheme="https://meandni.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="技术选型" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>观摩！Flutter 1.22 正式发布</title>
    <link href="https://meandni.com/2020/10/02/d81/"/>
    <id>https://meandni.com/2020/10/02/d81/</id>
    <published>2020-10-02T14:09:52.000Z</published>
    <updated>2020-10-18T07:54:23.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter-1-22-正式发布！"><a href="#Flutter-1-22-正式发布！" class="headerlink" title="Flutter 1.22 正式发布！"></a>Flutter 1.22 正式发布！</h2><blockquote><p>继 9 月 23 号发布 <a href="https://mp.weixin.qq.com/s?__biz=MzIzMjYyNzQ2Ng==&amp;mid=2247483816&amp;idx=1&amp;sn=84b9a7cc09253e621632bfcbccf3ea70&amp;chksm=e8934dcddfe4c4dbe0d13f818558098506a7999c19bc2d775cdc937e25cd1fbca2c1f56d3dd1&amp;token=1919414612&amp;lang=zh_CN#rd" target="_blank" rel="noopener">Flutter Windows 内测版</a> 之后刚过几天，Flutter 官方在昨夜凌晨正式发布了 Flutter 1.22。</p><p>本次版本的升级又带来了新一轮地功能发布，性能改进和问题修复。恰逢移动平台新版本（iOS 14/Android 11）的发布季，此次的版本更新保证了 Flutter 应用在 Android 11 和 iOS 14 上的兼容性，面向 iOS 14，本次更新包括了对 Xcode 12，新 Icon 的更新以及 App Clips 功能的预览。对于Android 11，此次更新包括了多种屏幕适配以及软键盘动画的流畅性优化。</p><p>距离上个版本发布刚刚两个月，此次版本的更新最为快速，但质量却依然没有下降，Github 数据显示此次更新共解决了 3,024 个 issue，合并了 197 个贡献者的 1,944 个PR，而在这些贡献者中有 114 位（58％）来自社区的支持，他们共提交了 271 个PR，贡献量最大的是 <a href="https://github.com/a14n" target="_blank" rel="noopener">a14n</a>，共提交了 20 个 PR，</p><p>除了对新平台的全力支持外，Flutter 的本次更新也迎来了很多值得分享的话题，包括社区讨论最为热烈的 Android 状态恢复，新的 Material 按钮组件以及国际化和本地化支持与热重载并用等功能。此次更新也包括了全新的导航器（Navigator），稳定版 Platform Views （支持 Google Maps 和 WebView 插件）以及高频率设备下滚动性能的优化，同时，开发工具的更新也迎来了另一番景象，具体读者们详见正文。</p></blockquote><h3 id="新平台适配"><a href="#新平台适配" class="headerlink" title="新平台适配"></a>新平台适配</h3><h4 id="iOS-14"><a href="#iOS-14" class="headerlink" title="iOS 14"></a>iOS 14</h4><p>每当 Android/iOS 等平台推出系统的新版本时，Flutter 都会进行全面的整改来避免出现不兼容的现象。因此，iOS 14 的发布也推动了 Flutter 的新一轮更新，主要包括如下几点：</p><ul><li>XCode 12 仅支持 iOS 9.0 以上的版本，因此 Flutter 项目已将默认支持的版本从 8.0 更新到了 9.0。</li><li>Flutter 1.22 修复了在 iOS 14 系统下的的闪退和字体渲染的问题。</li><li>自 Flutter 1.20.4 起也已完全解决了部署到真机设备上出现的各种问题。</li><li>当应用程序访问其剪贴板时，会导致 Flutter 应用程序弹出错误通知，该问题也已在 1.20.4 中解决。</li><li>iOS 14 上存在禁止在设备上运行 debug 应用程序的限制（实际开发调试过程除外）。</li><li>考虑到网络安全性的问题，本地调试的 Flutter 应用程序会在 iOS 14 上显示一次性确认对话框（仅开发期间）。</li></ul><blockquote><p>如果你的 Flutter 应用程序需要运行在 iOS 14 系统上，我们强烈建议你将 Flutter 版本更新到 1.22 并立即部署到 App Store 中，这样可以确保你的 iOS 14 用户获得最佳体验。</p></blockquote><p>有关 Flutter 如何适配 iOS 14 的更多信息，包括如何添加到原生应用、deep linking 等问题，可以参阅官网 <a href="https://flutter.dev/docs/development/ios-14" target="_blank" rel="noopener">iOS 14文档</a>。</p><p>我们的目标一直是希望开发者们能完全脱离所有工具和 SDK 的更新而者专注于应用本身的业务逻辑，这就要求我们需要充分支持 iOS 14 的各种新的特性。</p><p>本次，我们就针对  iOS 新发布的 SF Symbols 字体做了更新支持，对 <a href="https://pub.dev/packages/cupertino_icons" target="_blank" rel="noopener">cupertino_icon</a> 库做了一系列的更新，现在只需要将 cupertino_icon 更新到最新的 1.0 版本，就能自动将 CupertinoIcons 映射成新样式的图标，Flutter 1.22 后，CupertinoIcons 也额外提供了 900 个新图标。</p><p><img src="/images/0*ZGKu3IhnPNp6fS_e-20201002011622288.png" alt=""></p><p>读者们可以在 <code>cupertino_icons</code> 预览页面上看到完整的图标列表，详情参见<a href="https://flutter.dev/docs/release/breaking-changes/cupertino-icons-1.0.0" target="_blank" rel="noopener">迁移详细信息页面</a>。</p><p>开发者可以在 iOS 14上 尝试使用 Flutter 的另一个功能就是 <a href="https://developer.apple.com/app-clips/" target="_blank" rel="noopener">App Clips</a>（轻应用），这是 iOS 14 推出的一项新功能，它支持 10MB 以下轻量级应用程序的快速，免安装打开，而在 1.22 版中，我们就可以试一下 Flutter 在 iOS 上支持的 App Clip 功能了。</p><p><img src="/images/0*8MER4IM-IEt2ye2a-20201002011623364.png" alt="Flutter App Clip"></p><p>有关如何使用 Flutter 构建 App Clip 的更多详细信息，参见<a href="https://flutter.dev/docs/development/platform-integration/ios-app-clip" target="_blank" rel="noopener">官方文档</a>，也可以参考这个<a href="https://github.com/flutter/samples/tree/master/ios_app_clip" target="_blank" rel="noopener">简单的示例项目</a>。</p><h4 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a>Android 11</h4><p>Flutter 的此次更新也同样同步了本月发布的 Android 11。为了支持 Android 11 中引入的两个新功能，Flutter 框架层和引擎层都已做了相应的更新。首先，Flutter 现在已经<strong>支持多种全新 Android 屏幕的适配</strong>，如下图：</p><p><img src="/images/0*lPO4ueKwxvV0QP_I-20201002011622857.png" alt=""></p><p>通过使用 <code>MediaQuery</code> 和 <code>SafeArea</code> 这两个组件，开发者就可以确保将展示的 UI 和交互式组件放置在设备显示屏的无障碍区域中。另外，目前我们需要尽量避免在瀑布屏边缘区域使用手势检测器，因为这些手势检测器可能会导致意外触摸。</p><p>其次，显示软件键盘时的动画也已经与 Android 11 同步。</p><p><img src="/images/0*DFRjYzbqIc5kOoDm-20201002011623193.gif" alt=""></p><p>此前， Flutter 一直存在 <a href="https://github.com/flutter/flutter/issues/19279" target="_blank" rel="noopener">#19279</a> 这个问题，其中系统键盘的显示/隐藏动画与 Flutter 并不同步，这个问题也已经在此次更新中被修复。</p><p>关于 Android 插件 API。去年，Flutter 1.12 退出了一套全新的 Flutter 插件 API，我们开发了 v2 API 使开发者们能够更好的将 Flutter 嵌入到已有的原生应用中。据我们统计，到目前为止已经有超过 80％ 的 Android 插件使用了新的 Android API 了，因此，从本次发布 1.22 开后，我们便不再维护旧的 v1 API。</p><p>如果仍在使用 Android v1 API，可能会导致如下问题：</p><ul><li>无法使用新开发的插件</li><li>Flutter工具的 <code>—no-enable-android-embedding-v2</code>config 标志已被默认删除</li><li>仍在使用 v1 API 的旧版应用程序在构建期间会显示弃用警告，并指向<a href="https://flutter.dev/docs/development/packages-and-plugins/plugin-api-migration" target="_blank" rel="noopener">支持新的Android插件API</a>文档</li></ul><p>同时，如果你仍然有基于 v1 Android API 的 Flutter 应用程序，它虽然能够正常运行，但是很可能会使用遇到仅支持 v2 API 的新插件，而这些插件不能被 v1 Android API 使用。更多详细信息，请参见<a href="https://flutter.dev/docs/release/breaking-changes/android-v1-embedding-create-deprecation" target="_blank" rel="noopener">重大更改文档</a>。</p><h3 id="全新的-Button-组件"><a href="#全新的-Button-组件" class="headerlink" title="全新的 Button 组件"></a>全新的 Button 组件</h3><p><img src="/images/1*crNLxg7CCtlQkB4mLI_ErA-20201002011622976.png" alt=""></p><p>之前的版本中，Flutter 已经有了一套完备的按钮组件，但使用起来却很麻烦，Material 规范也增加了多个新样式的按钮。所以，为了使 Flutter 保持与 Material 的同步，我们正式地宣布 Flutter 1.22 将引入全新的 “Button” 按钮。</p><p>新的 Button 组件的命名规范也与 <a href="https://material.io/components/buttons/" target="_blank" rel="noopener">Material Design 规范</a>，如下。</p><p><img src="/images/1*di6uPEKEsRHoFtRryHeWPg-20201002011623006.png" alt=""></p><p>DartPad 上有一个非常好的<a href="https://dartpad.dev/e560e1c2e4455ad53aac245079ccdcf2" target="_blank" rel="noopener">在线演示示例</a>，同时，之前的 <code>FlatButton</code>，<code>OutlineButton</code>，<code>RaisedButton</code>，<code>ButtonBar</code>，<code>ButtonBarTheme</code> 并不会被弃用，开发者可以按照需求混合使用旧按钮与新按钮。</p><h3 id="全新的国际化和本地化的支持"><a href="#全新的国际化和本地化的支持" class="headerlink" title="全新的国际化和本地化的支持"></a>全新的国际化和本地化的支持</h3><p>自 Flutter 发布以来，已经为应用提供了较好的国际化（i18n）和本地化（l10n）所需的核心功能的支持，而在此次的新版本中，我们也将该功能的最佳实践纳入了我们的开发工具中，并且，在添加新的 l10n 信息时启用了热重装支持来直接更新应用程序。</p><p><img src="/images/0*UBVlGmhw5NUWbg5I.gif" alt=""></p><p>如果你想了解有关 Flutter  l10n 的更多信息，包括本地化消息，带有参数，日期，数字和货币的消息，请参见 <a href="http://flutter.dev/go/i18n-user-guide" target="_blank" rel="noopener">Flutter Internationalization 用户指南</a>。</p><p>此外，如果你对 i18n 和 l10n 感兴趣，你可能还对那些字符串不包含在普通 ASCII 字符的字符串，例如 Unicode 和 emoji 的问题比较惯性。本次，Dart 团队也发布了 <a href="https://pub.dev/packages/characters" target="_blank" rel="noopener">characters</a> 软件包可以帮助开发人员处理 Unicode（扩展）字符簇。该库可以帮助开发者们解决诸如如何正确地将字符串（如“ A 🇬🇧 text in English”）缩写为前 15 个字符的问题，使用 <code>String</code> 类，该字符串可以缩写为 “ A 🇬🇧 text in”，它仅是 12 个用户可感知的字符。另一方面，使用 <code>characters</code> 也可以生成 “A 🇬🇧 text in Eng” 的正确缩写。</p><p><a href="https://github.com/flutter/flutter/pull/59267" target="_blank" rel="noopener">此PR</a> 使用 <code>characters</code> 完美的处理了这些复杂的字符，例如，当 <code>TextField</code> 带有最大长度 <code>maxLength</code> 限制时，像 👨‍👩‍👦 这样的字符现在可以正确地算作单个字符，另外，<a href="https://github.com/flutter/flutter/pull/59620" target="_blank" rel="noopener">此PR</a>，在Flutter所在的项目中，字符包均可自动在项目中使用，而无需手动添加。希望这使得处理来自所有语言环境的各种字符串变得更加容易。有关 character 包的更多详细信息，请查看文章 <a href="https://medium.com/dartlang/dart-string-manipulation-done-right-5abd0668ba3e" target="_blank" rel="noopener">Dart string manipulation done right 👉</a>。</p><h3 id="Google-Maps-和-WebView-插件准备投入生产"><a href="#Google-Maps-和-WebView-插件准备投入生产" class="headerlink" title="Google Maps 和 WebView 插件准备投入生产"></a>Google Maps 和 WebView 插件准备投入生产</h3><p>Flutter 团队通常会经过仔细考虑后才会将某些标签标记为 “production ready”，在此之前，我们通常都会对其进行了全面测试。对于<code>google_maps_flutter</code> 和 <code>webview_flutter</code>  这两个插件底层都是使用 <a href="http://flutter.dev/docs/development/platform-integration/platform-views" target="_blank" rel="noopener">Platform Views</a> 实现，从而允许将 Android 和 iOS 的原生 UI 组件嵌入在 Flutter 应用程序中。在此次的 Flutter 版本中，我们欣然宣布，我们已经对框架层进行了强化，完全能够将这两个插件都声明为可投入生产（即 “production ready”）。</p><p><img src="/images/0*luz0EiazQQqsAEC4-20201002011629493.gif" alt=""></p><p>在 Flutter 1.22 中，我们添加了一个可替代 Platform Views 的方案，该方案修复了<a href="https://github.com/flutter/flutter/issues/61133" target="_blank" rel="noopener">所有已知的键盘以及 Android 视图的可访问性问题</a>。此外，它还适用于 19 级及以上的 Android API（以前要求 20 级）。我们还对 iOS 上的线程进行了改进，使平台视图更高效，更可靠（并且不再需要你将 <code>io.flutter.embedded_views_preview</code> 标志添加到 iOS 中 <code>Info.plist</code>）<em>。</em></p><p>该 <code>webview_flutter</code> 插件支持新的 Android Platform Views 模式，但当前需要手动启用，今后在社区中得到广泛应用后，我们会默认开启该功能</p><p>Google Maps 和 WebView 插件已经从 Platform Views 的改进中受益。如果你想使用平台视图在 iOS 或 Android 上<a href="https://flutter.dev/docs/development/platform-integration/platform-views" target="_blank" rel="noopener">嵌入</a>自己的原生 UI 组件，可以参阅 <a href="https://flutter.dev/docs/development/platform-integration/platform-views" target="_blank" rel="noopener">Hosting native Android and iOS views in your Flutter app with Platform Views</a>。</p><h3 id="Navigator-2-0"><a href="#Navigator-2-0" class="headerlink" title="Navigator 2.0"></a>Navigator 2.0</h3><p>如果你之前在 Flutter 应用程序中使用过 Navigator，则可能已经注意到核心数据结构（用户正在浏览的页面路由栈）对你是不可见的。每次要进行管理时，需要调用  <code>Navigator.pop()</code>  或 <code>Navigator.push()</code>。例如，假设你要在主页上显示一系列组件，并允许用户点击一个组件以进入该颜色的详细信息页面，如下图。</p><p><img src="/images/0*OVbaUaMkAXrpLQCy-20201002011624819.png" alt=""></p><p>我们可以使用下面这种方式实现这两个简单的 UI 页面：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorListScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> <span class="built_in">List</span>&lt;Color&gt; colors;</span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">void</span> <span class="built_in">Function</span>(Color color) onTapped;</span><br><span class="line"> ColorListScreen(&#123;<span class="keyword">this</span>.colors, <span class="keyword">this</span>.onTapped&#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">       appBar: AppBar(title: Text(<span class="string">'Colors'</span>)),</span><br><span class="line">       body: Column(</span><br><span class="line">         children: [</span><br><span class="line">           <span class="comment">// you can see and decide on every color in this list</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">final</span> color <span class="keyword">in</span> colors)</span><br><span class="line">             Expanded(</span><br><span class="line">               child: GestureDetector(</span><br><span class="line">                 child: Container(color: color),</span><br><span class="line">                 onTap: () =&gt; onTapped(color),</span><br><span class="line">               ),</span><br><span class="line">             )</span><br><span class="line">         ],</span><br><span class="line">       ),</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Color color;</span><br><span class="line"> <span class="keyword">const</span> ColorScreen(&#123;<span class="keyword">this</span>.color&#125;);</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">       appBar: AppBar(title: Text(<span class="string">'Color'</span>)),</span><br><span class="line">       body: Container(color: color),</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用下面这种 Navigator 1. 0 方式，可以非常简单地实现在这两个页面之间的导航：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ColorAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ColorApp</span>&gt; </span>&#123;</span><br><span class="line"> <span class="built_in">List</span>&lt;Color&gt; _colors = [Colors.red, Colors.green, Colors.blue];</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> Widget build(BuildContext context) =&gt; MaterialApp(</span><br><span class="line">       title: <span class="string">'Color App'</span>,</span><br><span class="line">       home: Builder(</span><br><span class="line">         builder: (context) =&gt; ColorListScreen(</span><br><span class="line">           colors: _colors,</span><br><span class="line">           <span class="comment">// the Navigator manages the list of pages itself; you can only push and pop</span></span><br><span class="line">           onTapped: (color) =&gt; Navigator.push(</span><br><span class="line">             context,</span><br><span class="line">             MaterialPageRoute(builder: (context) =&gt; ColorScreen(color: color)),</span><br><span class="line">           ),</span><br><span class="line">         ),</span><br><span class="line">       ),</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需调用  <code>Navigator.push()</code> ，即可在第一个页面打开第二个页面，从而在路由栈中创建两个页面的实例，但是，和在 ColorListScreen 中的 build 方法中显式地创建 Containers 列表不同，该路由栈并不可见，因此很难管理一些特殊情况，如处理由原生嵌入提供的初始路由的 deep linking，或者来自 Web 的 URL 或来自 Android 的 intent，管理同一页面的不同顺序之间的嵌套路由也极其困难。</p><p>Navigator 2.0 通过使页面堆栈可见解决了这些问题，甚至更多。下面这段代码是在 <code>ColorListScreen</code> 和 <code>ColorScreen</code> 之间的另一个版本 ：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ColorAppState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ColorApp</span>&gt; </span>&#123;</span><br><span class="line"> Color _selectedColor;</span><br><span class="line"> <span class="built_in">List</span>&lt;Color&gt; _colors = [Colors.red, Colors.green, Colors.blue];</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> Widget build(BuildContext context) =&gt; MaterialApp(</span><br><span class="line">       title: <span class="string">'Color App'</span>,</span><br><span class="line">       home: Navigator(</span><br><span class="line">         <span class="comment">// you can see and decide on every page in this list</span></span><br><span class="line">         pages: [</span><br><span class="line">           MaterialPage(</span><br><span class="line">             child: ColorListScreen(</span><br><span class="line">               colors: _colors,</span><br><span class="line">               onTapped: (color) =&gt; setState(() =&gt; _selectedColor = color),</span><br><span class="line">             ),</span><br><span class="line">           ),</span><br><span class="line">           <span class="keyword">if</span> (_selectedColor != <span class="keyword">null</span>) MaterialPage(child: ColorScreen(color: _selectedColor)),</span><br><span class="line">         ],</span><br><span class="line">         onPopPage: (route, result) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!route.didPop(result)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           setState(() =&gt; _selectedColor = <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;,</span><br><span class="line">       ),</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里显式地创建了一个 <code>Navigator</code>，并为其提供代表完整堆栈的页面列表，我们创建一个空 <code>_selectedColor</code> 变量来表示尚未选择任何颜色，因此默认不显示 <code>ColorScreen</code>。当用户选择一种颜色时，我们调用  <code>setState()</code> 更新状态，Flutter 会重新调用 build() 方法，然后就会在 <code>ColorScreen</code> 顶部创建一个 ColorScreen 页面。</p><p>你可以在 <code>OnPopPage</code> 回调函数中更新返回的状态，例如，如果用户回退，则表示他们 “取消选择” 了当前颜色，从而 _<code>selectedColor = null</code> 表示不再希望显示该页面。</p><p>Navigator 2.0 看起来像 Flutter 的其余部分，那正是她的意图，它是声明性的，与 Navigator 1.0 势在必行，这个想法是要在导航和Flutter 的其余部分之间统一模型，同时解决许多问题并添加功能。实际上，这个小例子几乎还不涉及 Navigator 2.0 的内容。有关详细信息，推荐阅读 <a href="https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade" target="_blank" rel="noopener"> Declarative navigation and routing in Flutter</a></p><p>另外，Navigator 1.0 依然可以继续使用，短期内也不会失效，如果你已经喜欢这种路由模式，完全可以继续使用它。但是，如果你尝试使用 Navigator 2.0，我们认为你会喜欢的。</p><h3 id="预览功能"><a href="#预览功能" class="headerlink" title="预览功能"></a>预览功能</h3><h4 id="Android-的状态还原"><a href="#Android-的状态还原" class="headerlink" title="Android 的状态还原"></a>Android 的状态还原</h4><p>在此次的新版本中还能够试用的新功能是 <a href="https://developer.android.com/topic/libraries/architecture/saving-states" target="_blank" rel="noopener">对Android的状态还原的</a> 支持。这是我们在 <a href="https://github.com/flutter/flutter/issues/6827" target="_blank" rel="noopener">Github</a> 上最受欢迎的功能之一，拥有 217 个点赞！</p><p><strong>考虑到读者们可能不熟悉状态还原这个需求</strong>。移动操作系统可能会杀死后台的应用程序，以回收前台应用程序的资源。发生这种情况时，操作系统会通知该应用已经被终止，这样开发者就可以快速保存当前 UI 状态，以便在用户再次回到该应用时可以将其恢复。如果该功能完善，就可以为用户提供无缝的体验了，同时也可以更好地利用设备的资源。目前，Flutter 还病不支持状态还原，如果没有框架层的支持，也很难自行地进行状态地还原，因此，在 Flutter 1.22 中我们也宣布推出该功能的基础实现。</p><p>下面是一个用于恢复默认 Flutter Counter 应用状态的简单示例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">RestorableCounter</span>&gt; <span class="title">with</span> <span class="title">RestorationMixin</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> <span class="keyword">get</span> restorationId =&gt; widget.restorationId;</span><br><span class="line"></span><br><span class="line">  RestorableInt _counter = RestorableInt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> restoreState(RestorationBucket oldBucket) =&gt; registerForRestoration(_counter, <span class="string">'count'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() =&gt; setState(() =&gt; _counter.value++);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; Scaffold(</span><br><span class="line">      body: Center(child: Text(<span class="string">'<span class="subst">$&#123;_counter.value&#125;</span>'</span>)),</span><br><span class="line">      floatingActionButton: FloatingActionButton(onPressed: _incrementCounter),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简要地说，每个组件都有一个存储桶（storage bucket），<code>RestorationMixin</code> 使用唯一的 ID 向其注册。通过使用一种<code>RestorableProperty</code> 类型（如这里的 <code>RestorableInt</code>）来存储特定于 UI 数据，并使用状态恢复功能注册该数据，该数据将在 Android 终止该应用程序之前自动保存，并在其再正常运行时进行恢复。就是这样，<code>Restoration*</code> 可以储任何类型的数据，如<code>RestorableInt</code>，<code>RestorableString</code> 和 <code>RestorableTextEditingController</code>（等等）都将可以被恢复。</p><p>如果系统内置没有涵盖你要还原的数据类型，也可以通过 <code>RestorableProperty&lt;T&gt;</code> 创建自己的类型 。</p><p>为了实现状态恢复的自动测试，我们也向 WidgetTester 增加了全新的 <a href="https://api.flutter.dev/flutter/flutter_test/WidgetTester/restartAndRestore.html" target="_blank" rel="noopener">restartAndRestore API</a>。如果想要手动测试，最简单的方法就是在 Android 设备上打开已经启用状态恢复的 Flutter 应用，在 Android 开发人员设置中启用“不要保留活动”（如下图），然后运行 Flutter 应用，将其置于后台，之后再返回。此时，Android 系统就会先终止再恢复你的应用程序了，你可以查看一切是否按预期工作。</p><p><img src="/images/0*1298qhTKz_FjPuRN-20201002011902051.png" alt="图片发布"></p><p>虽然我们已经推出了状态恢复的预览版，但还有很多其他的工作要做。例如，状态恢复不仅需要适用于 Android，iOS 应用程序也应当及时同步。此外，我们也正着手优化自己的内置组件，以在恢复过程中默认保持其状态。我们已经在 <code>ListView</code> 和 <code>SingleChildScrollView</code>（记住用户的滚动位置）和 <code>TextFields</code> （恢复他们输入的文本）类中提供了该功能支持，我们也正计划将其扩展到其他组件中。</p><p>然而，由于 navigation（1.0 或 2.0）的原因，该功能目前也才出狱预览版，，也就是说，你的用户还不能体验该功能，我们即将会在 Beta 中发布，并在 Flutter 的下一个稳定版本中正式发布。</p><h4 id="滚动性能优化"><a href="#滚动性能优化" class="headerlink" title="滚动性能优化"></a>滚动性能优化</h4><p>由于存在输入和显示频率不同步的情况，Flutter 团队也与 Google 内核部门合作，极大地提高了页面滚动性能。例如，Pixel 4 输入的运行频率为 120hz，而显示屏的运行频率为 90hz，滚动时，这种不匹配会导致性能下降。使用新的 <code>resamplingEnabled</code> 标志，你就可以解决此问题，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  GestureBinding.instance.resamplingEnabled = <span class="keyword">true</span>;</span><br><span class="line">  run(MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据所涉及的频率差异，启用此标志可以使滚动时的颤动减少到 97％，当我们确定这已经是最好的体验时，我们会计划在以后的版本中默认启用此功能。</p><h3 id="工具更新"><a href="#工具更新" class="headerlink" title="工具更新"></a>工具更新</h3><h4 id="统一的-Dart-开发者工具"><a href="#统一的-Dart-开发者工具" class="headerlink" title="统一的 Dart 开发者工具"></a>统一的 Dart 开发者工具</h4><p>与往常的版本一样，对 Flutter 的更新不仅在于引擎和框架层，还包括工具。Flutter 1.22 包括 Dart（2.10）的新版本，还有一个新的dart CLI工具，你可能也会想要其中的新功能。</p><p>Dart 已经存在许多小的开发者工具（例如格式化 <code>dartfmt</code> 和代码分析 <code>dartanalyzer</code> ）。Dart 2.10 中的新功能是 <code>dart</code> 统一了开发者工具，和我们常用的 Flutter tool 类似。</p><p><img src="/images/1*9pvyafhpaMEMhJfLVsz1JQ-20201002012011846.png" alt="“dart help”输出的屏幕截图。"></p><p>从 Flutter 1.22 SDK 开始，你就会发现 <flutter-sdk> / bin 文件夹会同时包含 flutter 和 dart 命令，有关更多详细信息，参见 <a href="https://medium.com/flutter/announcing-flutter-1-22-44f146009e5f" target="_blank" rel="noopener">Dart 2.10博客文章</a>。</p><h4 id="应用程序大小分析工具"><a href="#应用程序大小分析工具" class="headerlink" title="应用程序大小分析工具"></a>应用程序大小分析工具</h4><p>Flutter 1.22 也发布了一款<strong>输出大小分析工具</strong>，该工具可帮助诊断你的 Flutter 应用各部分大小是否发生了变化。</p><p>你可以通过在一下命令中使用 <code>--analyze-size</code> 参数来使用该工具收集分析所需的数据：</p><ul><li><code>flutter build apk</code></li><li><code>flutter build appbundle</code></li><li><code>flutter build ios</code></li><li><code>flutter build linux</code></li><li><code>flutter build macos</code></li><li><code>flutter build windows</code></li></ul><p>使用该参数构建 Flutter 输出 artifact 时可以打印 artifact 尺寸和组成的信息，包括本机原生代码，资源，甚至是已编译 Dart 代码的程序包级的细分。</p><p><img src="/images/0*vfMD0AQZUOUwzfZ4-20201002012034092.png" alt="Flutter Gallery realse APK 包大小分析"></p><p>该信息有助于快速识别应用程序的程序包大小使用中的关键点。此外，收集的数据也可以作为使用 JSON 文件中 Dart DevTools，这允许你能够进一步探索应用的内容，解决包大小大小的问题，如下，通过 flutter.dev 的<a href="https://flutter.dev/docs/development/tools/devtools/app-size" target="_blank" rel="noopener">说明</a>，可以观察两个不同的 JSON 文件之间的变化。加载 JSON 文件后，你将看到一个界面，该界面会提供应用大小的树状图。</p><p><img src="/images/0*gA2waLDAyITCzD7K-20201002012033652.png" alt="Dart DevTools 中的 APK 故障示例"></p><p>关于“应用大小”工具执行的操作的更多详细信息，可以阅读 <a href="https://flutter.dev/docs/development/tools/devtools/app-size" target="_blank" rel="noopener">the Using the app size tool docs</a> </p><h4 id="DevTools-网络页面"><a href="#DevTools-网络页面" class="headerlink" title="DevTools - 网络页面"></a>DevTools - 网络页面</h4><p>此版本中的另一个 DevTools 更新是能够将 HTTP 和 HTTPS 的响应（Response）主体作为 “网络“ tab 中的一部分。</p><p><img src="/images/0*-FukCwELl9DLlefP.png" alt="图片发布"></p><p>此外，对于具有大量网络交互的应用程序，我们也提供了搜索和过滤的功能。</p><p><img src="/images/0*k-fEpOpbV_MiX9Fn-20201002012033617.png" alt="图片发布"></p><p>有关该 “网络” tab 的文档，可以参阅 <a href="https://flutter.dev/docs/development/tools/devtools/network" target="_blank" rel="noopener">Using the Network View</a>。</p><h4 id="DevTools-Inspector"><a href="#DevTools-Inspector" class="headerlink" title="DevTools - Inspector"></a>DevTools - Inspector</h4><p>一直以来，我们一直在维护着两款 Flutter 工具，例如 IntelliJ 中的 <strong>Inspector</strong> 和 Dart DevTools 中的 <strong>Inspector</strong>。这不仅放慢了我们的速度，因为我们必须维护两个代码库，而且某些功能也尚未纳入 IntelliJ 插件中，例如布局资源管理器。因此，为了解决这两个问题，我们启用了直接从 IntelliJ 内部的 Dart DevTools 托管 <strong>Inspector</strong> 选项卡的功能。</p><p><img src="/images/0*RQZ-EVyFP1-BqBIX-20201002012034281.png" alt="图片发布"></p><p>值得关注的是这里添加了 Layout Explorer，你可以在代码旁边即刻使用它。要开启此功能，可以选择菜单 <strong>Preferences</strong> &gt; <strong>Languages &amp; Frameworks</strong> &gt; <strong>Flutter</strong> &gt; <strong>Enable embedded DevTools inspector</strong>。</p><h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h4><p>所有 Flutter 开发人员都需要面临的一个场景是从终端或堆栈跟踪中查找错误输出。在 Visual Studio Code 的 Flutter 最新版扩展程序中，现在可以正确解析这些链接，你可以直接从输出中打开链接。</p><p><img src="/images/0*prigrwpp7gE6ChCE-20201002012034600.png" alt=""></p><p>虽然看着这是一件小事，但我们已经收到了很多积极的反馈。</p><p>与往常一样，此处的工具更改项太多，可以从以下公告中了解详细信息：</p><ul><li><a href="https://groups.google.com/g/flutter-announce/c/UxMv8MzE_uo/m/ED539pi2AAAJ" target="_blank" rel="noopener">Dart DevTools — 0.9.0</a></li><li><a href="https://groups.google.com/g/flutter-announce/c/y27h86ATFJM" target="_blank" rel="noopener">Dart DevTools — 0.9.1</a></li><li><a href="https://groups.google.com/g/flutter-announce/c/24LppkXdMtM" target="_blank" rel="noopener">Dart DevTools — 0.9.3</a></li><li><a href="https://groups.google.com/g/flutter-announce/c/nvgDi3RLAUE/m/Fx4Ze0vrBAAJ" target="_blank" rel="noopener">Flutter IntelliJ插件M48.1发行</a></li><li><a href="https://groups.google.com/g/flutter-announce/c/-ZMKRIBRtGU" target="_blank" rel="noopener">Flutter IntelliJ插件M49发布</a></li><li><a href="https://groups.google.com/g/flutter-announce/c/u0zU6zv3o44/m/2y0JsX1_AwAJ" target="_blank" rel="noopener">Flutter IntelliJ插件M50发布</a></li><li><a href="https://groups.google.com/g/flutter-announce/c/8e8e-ZrgySY" target="_blank" rel="noopener">VS Code扩展v3.14.0</a></li><li><a href="https://dartcode.org/releases/v3-15/" target="_blank" rel="noopener">VS Code扩展v3.15.0</a></li></ul><h3 id="优秀案例：EasyA"><a href="#优秀案例：EasyA" class="headerlink" title="优秀案例：EasyA"></a>优秀案例：EasyA</h3><p>EasyA 是一款可订阅应用，旨在帮助适龄学生通过即时消息与优秀的导师联系，该应用使用 Flutter 开发，最近，它被 Apple 推荐为了 <a href="https://apps.apple.com/gb/story/id1527472788" target="_blank" rel="noopener">their App of the Day</a>。</p><p><img src="/images/0*yLWTxV_YTJ2HKhuz.png" alt=""></p><blockquote><p>“当学校在今年初开始网上授课时，我们知道我们需要快速开发一个辅导应用程序来帮助学生。Flutter 的惊人发展速度意味着我们能够为 iOS 和 Android 实施各种优秀的设计，并且还可以发布到 Web 上！通常，这实际上是不可能的。但是，由于 Flutter 允许我们同时针对所有三个平台，因此我们能够高效地复用代码，并充分利用我们的小型开发人员团队。”</p><p><em>—</em> <a href="https://easya.io/" target="_blank" rel="noopener"><em>EasyA</em></a> <em>联合创始人</em> <a href="https://easya.io/" target="_blank" rel="noopener"><em>Phil Kwok</em></a></p></blockquote><h3 id="重大更新"><a href="#重大更新" class="headerlink" title="重大更新"></a>重大更新</h3><p>与往常一样，我们会尽量保有较少的重大更新。这是 Flutter 1.22 发行版中的列表。</p><ul><li><a href="https://github.com/flutter/flutter/pull/56413" target="_blank" rel="noopener">56413</a> <a href="https://docs.google.com/document/d/1BZhxy176uUnqOCnXdnHM1XetS9mw9WIyUAOE-dgVdUM/edit?usp=sharing" target="_blank" rel="noopener">如果指定的 Rect 已经可见，则阻止 viewport.showOnScreen 滚动视口</a>。</li><li><a href="https://github.com/flutter/flutter/pull/62395" target="_blank" rel="noopener">62395</a> [gen_l10n] 默认情况下生成合成软件包</li><li><a href="https://github.com/flutter/flutter/pull/62588" target="_blank" rel="noopener">62588</a> 简化构建流程。</li></ul><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Flutter 1.22 稳定版会很快推出，其中真的包含了很多值得我们学习的东西，这篇文章也并不能一一列举。我们希望此版本可以帮助你在 iOS 和 Android 平台上开发更出色的应用！感谢你的支持。</p><h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>官方原文：<a href="https://medium.com/flutter/announcing-flutter-1-22-44f146009e5f" target="_blank" rel="noopener">https://medium.com/flutter/announcing-flutter-1-22-44f146009e5f</a></p><p>我的博客：<a href="https://meandni.com/2020/09/28/d206/">https://meandni.com/2020/09/28/d206/</a></p><p>关注公众号「Meandni」，及时阅读移动开发技术和最新技术动态。</p><p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Flutter-1-22-正式发布！&quot;&gt;&lt;a href=&quot;#Flutter-1-22-正式发布！&quot; class=&quot;headerlink&quot; title=&quot;Flutter 1.22 正式发布！&quot;&gt;&lt;/a&gt;Flutter 1.22 正式发布！&lt;/h2&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="flutter" scheme="https://meandni.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="技术动态" scheme="https://meandni.com/tags/%E6%8A%80%E6%9C%AF%E5%8A%A8%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>全方位剖析 Flutter Windows 内测版。</title>
    <link href="https://meandni.com/2020/09/28/d206/"/>
    <id>https://meandni.com/2020/09/28/d206/</id>
    <published>2020-09-28T09:55:37.000Z</published>
    <updated>2020-10-18T07:54:22.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Flutter 最被所我们津津乐道的功能就是能实现 Android 和 iOS 上的开发统一，目前，Google 也已经先后发布了 8 个稳定版，在这两个移动平台上提供了各方面的支持，据不完全统一，Flutter 开发者已经向 Google Play 商店提交了 100,000 多款应用，数字还是挺惊人的。</p><p>但是 Flutter 团队也一直在扩展他们的视野，没准备放过  Web 平台和桌面操作系统，此前，一直在关注 Flutter 发展动向的同学也一定尝鲜了 Flutter 在 MacOs 和 Linux 上的支持，9 月 23 号，Flutter 项目的 Google 产品经理克里斯·塞尔斯（Chris Sells）也在 Medium 上的帖子公开表示未来将致力于 Flutter 对 Windows 平台的支持。</p></blockquote><h4 id="支持-Windows-系统原因？"><a href="#支持-Windows-系统原因？" class="headerlink" title="支持 Windows 系统原因？"></a>支持 Windows 系统原因？</h4><p>Windows 依然是台式机和笔记本电脑最常用的操作系统，不久前，Microsoft 也宣布已经有超过<a href="https://blogs.windows.com/windowsexperience/2020/03/16/windows-10-powering-the-world-with-1-billion-monthly-active-devices/" target="_blank" rel="noopener">十亿台运行 Windows 10 的硬件设备</a>了。我们自己的统计数据也显示，有超过一半的 Flutter 开发者正使用 Windows，因此，它很自然的成为了 Flutter 的下一个目标。对桌面应用的支持也能为 Flutter 开辟了更多激动人心的可能性，包括开发人员工具的改进，减少了新用户的负担等等，当然，我们的核心目的仍然是“一套代码，支持任何设备”。</p><h4 id="Flutter-能为-Windows-带来什么？"><a href="#Flutter-能为-Windows-带来什么？" class="headerlink" title="Flutter 能为 Windows 带来什么？"></a>Flutter 能为 Windows 带来什么？</h4><p>Flutter 团队一直遵守的原则是 “改善性能，拥抱差异”，因此我们总是以优化引擎为核心，为每个特定平台都提供合适的拓展。在移动设备上，我们致力于对 Material Design 的支持，希望尽可能的构建出以移动设备为中心的用户界面。而在其他平台（如 Web、Linux、Windows）上我们也是如此，Flutter 团队会开发一整套全新的服务，其中包括对键盘，鼠标，鼠标滚轮和控制器的特性支持，以及更多定制化的 UI 组件来适应 Web和桌面应用程序的大尺寸。</p><p>除了对 Flutter 框架和引擎本身的修改，每支持一个新平台还会影响很多其他方面：</p><ul><li><strong>工具链的更新</strong>：向 CLI 和 IDE 工具添加新的支持（Windows）</li><li><strong>Shell</strong>：通过 <code>WM_ *</code> 消息机制处理 Windows 的输入，并通过 ANGLE 输出，而 ANGLE 使用 Skia 以原生速度渲染到基础 DirectX 表面</li><li><strong>Runner</strong>：每个项目都会有针对目标平台的 Shell 程序。对于Windows，会有一个Win32 / C++程序，可加载 Flutter 代码并在运行时执行它。如果需要，可以在此处向应用程序添加本机代码。</li><li><strong>插件</strong>：插件可以实现 Dart 代码和原生的混合开发。可以为在 Windows 上 Flutter 应用程序中编译的每个插件添加该本地代码。</li></ul><h4 id="Flutter-团队对社区有哪些支持？"><a href="#Flutter-团队对社区有哪些支持？" class="headerlink" title="Flutter 团队对社区有哪些支持？"></a>Flutter 团队对社区有哪些支持？</h4><p>为了向公众预演 Flutter 桌面端的能力，Flutter 团队先前已经与 <a href="http://gskinner.com/" target="_blank" rel="noopener">gskinner.com</a> 团队共同开发了一款 Flokk 应用。Flokk 是一款能够与用户的 Google Contacts 数据配合使用并展示 GitHub 和 Twitter 上联系人动态的应用程序，如下图所示。</p><p><img src="/images/b49411801875461086b5d16df7b4af55~tplv-k3u1fbpfcp-zoom-1.image" alt="Flokk"></p><p>如果想在 Windows 上使用 Flokk 应用程序，可以直接在 GitHub上下载 <a href="https://github.com/gskinnerTeam/Flokk/releases" target="_blank" rel="noopener">最新版本</a>。如果您想了解构建 gskinner 应用的具体过程，可以参阅其博客文章：<a href="https://blog.gskinner.com/archives/2020/09/flokk---how-we-built-a-desktop-app-using-flutter.html" target="_blank" rel="noopener">Flokk – How we built a Desktop App Using Flutter</a>。</p><p>此外，Flutter Gallery 应用最近也已完全重写来增加对台式机尺寸的支持。现在，开发者完全可以自行运行它来体验 Flutter 是否可以在 Web 以及 Windows，macOS 和 Linux 上正常运行。</p><p><img src="/images/e75f64421a2a433ea3d358a069520a8c~tplv-k3u1fbpfcp-zoom-1.image" alt="Flutter Gallery"></p><p><a href="https://github.com/flutter/gallery" target="_blank" rel="noopener">该项目代码可在GitHub上找到</a>。</p><p>即使刚刚发布 Alpha 版，Flutter 社区也已经开始着手开发 Windows 平台的各个功能插件了：</p><ul><li><a href="https://pub.dev/packages/url_launcher" target="_blank" rel="noopener">url_launcher</a>：在应用程序中使用原生浏览器中打开 URL。</li><li><a href="https://pub.dev/packages/path_provider" target="_blank" rel="noopener">path_provider</a>：在本地上找到指向特殊方向的路径，例如 Document 或 temp。</li><li><a href="https://pub.dev/packages/shared_preferences" target="_blank" rel="noopener">shared_preferences</a>：应用程序数据的磁盘序列化。</li><li><a href="https://pub.dev/packages/biometric_storage" target="_blank" rel="noopener">biometric_storage</a>：生物识别技术加密的存储。</li><li><a href="https://pub.dev/packages/flutter_audio_desktop" target="_blank" rel="noopener">flutter_audio_desktop</a>：在桌面应用上播放音频。</li></ul><p>这些插件中的大多数也支持其他 Flutter 平台，开发者可以将这些功能统一运行在 Android，iOS，Web 等以及 Windows 上。此外，虽然 pub.dev 上约有三分之一的可用软件包是具有特定于平台的代码的插件，但毕竟大多数不是，例如，<a href="https://pub.dev/flutter/favorites" target="_blank" rel="noopener">许多最高质量和最常用的软件包</a> 是 Flutter Favorite 程序的一部分，它们大多数都可以在 Windows 上运行。如果要查看所有能够在 Windows 上运行的库，可以直接<a href="https://pub.dev/flutter/packages?platform=windows" target="_blank" rel="noopener">在pub.dev上查询</a>。</p><p><img src="/images/image-20200928152923494.png" alt="pub.dev"></p><h4 id="Windows-应用初体验"><a href="#Windows-应用初体验" class="headerlink" title="Windows 应用初体验"></a>Windows 应用初体验</h4><p>要使用 Flutter 开发 Windows 桌面应用，首先需要安装官网  <a href="https://flutter.dev/desktop#additional-windows-requirements" target="_blank" rel="noopener">Desktop 文档</a> 中介绍的开发工具。默认情况下，Flutter 项目中并不会配置 Windows 项目程序在 Flutter 项目中。开发者可以在终端执行下述命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> flutter channel dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> flutter upgrade</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> flutter config --<span class="built_in">enable</span>-windows-desktop</span></span><br></pre></td></tr></table></figure><p>第一条命令会将 Flutter 设置为使用 Flutter 开发版的代码（默认为稳定“ stable” 版）。这时，开发者就可以使用仍在内侧的功能，例如 Windows。第二行代码会将开发版的最新代码下载到本地以供我们使用。第三个命令则是设置允许在你的 PC 上进行 Windows 应用的开发。</p><p>设置好之后，每次使用 <a href="https://flutter.dev/docs/get-started/editor?tab=androidstudio" target="_blank" rel="noopener">Android Studio</a> 或 <a href="https://flutter.dev/docs/get-started/editor?tab=vscode" target="_blank" rel="noopener">Visual Studio Code</a>，或者从命令行创建新的 Flutter 应用程序时，都会默认创建一个 Windows 子文件夹了。</p><p><img src="/images/025ed7088ab1456e9ca1dc1c1bacc240~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>我们可以在 Windows 平台下运行默认的计数器应用，如下所示：</p><p><img src="/images/2765d5074c174801905d3fa51af42e36~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h4 id="如何与-Windows-原生交互"><a href="#如何与-Windows-原生交互" class="headerlink" title="如何与 Windows 原生交互?"></a>如何与 Windows 原生交互?</h4><p>开发者也可以为 Flutter Windows 平台开发自己的插件。进入 dev channel ，在终端执行以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">flutter create --template plugin --platforms Windows hello_plugin</span><br></pre></td></tr></table></figure><p>这是，你就可以创建出一个插件项目，并在 <code>lib</code> 子文件夹中编写 Dart 代码，Windows 原生代码被放在 <code>windows</code> 子文件夹中，你可以通过 <a href="https://flutter.dev/docs/development/platform-integration/platform-channels" target="_blank" rel="noopener">Platform Channels</a> 在它们之间进行通信，它的原理就是基于 Dart 和 C++ 代码之间传递的消息。关于开发插件的具体编码方式，<a href="https://github.com/flutter/plugins/tree/master/packages/url_launcher/url_launcher_windows" target="_blank" rel="noopener">请参见url_launcher实现</a>。</p><p>除了 Platform Channels，如果开发者需要，也可以使用 <a href="https://flutter.dev/docs/development/platform-integration/c-interop" target="_blank" rel="noopener">Dart FFI（外部功能接口）</a> 加载库并调用 C 类风格的 API，例如 Win32 API。与使用 Platform Channels 的 url_launcher 不同，path_provider 插件就是使用 FFI 实现的，打开 <a href="https://github.com/flutter/plugins/tree/master/packages/path_provider/path_provider_windows" target="_blank" rel="noopener">GitHub repo</a>，你可以看到 FFI 无需在Dart 和 C++ 之间来回切换，而可以直接编写代码导入所需的 API 即可，下面这一段就是 Dart 调用 MessageBox API 的样例代码：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> MessageBoxNative = Int32 <span class="built_in">Function</span>(</span><br><span class="line">  IntPtr hWnd, </span><br><span class="line">  Pointer&lt;Utf16&gt; lpText, </span><br><span class="line">  Pointer&lt;Utf16&gt; lpCaption,</span><br><span class="line">  Int32 uType</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> MessageBoxDart = <span class="built_in">int</span> <span class="built_in">Function</span>(</span><br><span class="line">  <span class="built_in">int</span> hWnd, </span><br><span class="line">  Pointer&lt;Utf16&gt; lpText, </span><br><span class="line">  Pointer&lt;Utf16&gt; lpCaption, </span><br><span class="line">  <span class="built_in">int</span> uType</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> user32 = DynamicLibrary.open(<span class="string">'user32.dll'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> win32MessageBox =</span><br><span class="line">  user32.lookupFunction&lt;MessageBoxNative, MessageBoxDart&gt;(<span class="string">'MessageBoxW'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> showMessageBox(<span class="built_in">String</span> message, <span class="built_in">String</span> caption) =&gt;</span><br><span class="line">  win32MessageBox(</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// No owner window</span></span><br><span class="line">    Utf16.toUtf16(message), <span class="comment">// Message</span></span><br><span class="line">    Utf16.toUtf16(caption), <span class="comment">// Window title</span></span><br><span class="line">    <span class="number">0</span> <span class="comment">// OK button only</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// call just like any other Dart function</span></span><br><span class="line">showMessageBox(<span class="string">'Test Message'</span>, <span class="string">'Window Caption'</span>);</span><br></pre></td></tr></table></figure><p>FFI 最明显的好处是不会产生在平台通道之类的两个线程之间进行转换的开销，而且还包括对许多不同种类的 API 的支持，包括 Win32，WinRT 和 COM。需要注意的是，在运行打包整个基于 C 的 Windows API 之前，需要先核实 <a href="https://pub.dev/packages/win32" target="_blank" rel="noopener">win32插件</a>，该<a href="https://pub.dev/packages/win32" target="_blank" rel="noopener">插件</a>已经可以很好地做到这一点。另外，<a href="https://pub.dev/packages/path_provider" target="_blank" rel="noopener">path_provider</a> 插件本身是使用 win32 插件实现的。有关 win32 插件如何开发以及如何工作的详细信息，可以查看博客文章 <a href="https://medium.com/@timsneath/windows-fun-with-dart-ffi-687c4619e78d" target="_blank" rel="noopener">Windows fun with Dart FFI</a>。</p><h4 id="如何学习-Flutter-Windows"><a href="#如何学习-Flutter-Windows" class="headerlink" title="如何学习 Flutter Windows?"></a>如何学习 Flutter Windows?</h4><p>Flutter Desktop 文档中含有最新关于桌面版的官方信息。另外，开发者们也可以在 <a href="https://codelabs.developers.google.com/codelabs/flutter-github-graphql-client/#0" target="_blank" rel="noopener">Google 实验室</a>中学习如何构建 Flutter 桌面应用，这里面包括了使用 OAuth 进行身份验证，访问 GitHub API、使用 GraphQL 等等。</p><p>此外，除了上述提到的示例，开发者们也可以参考 <a href="https://github.com/flutter/samples/tree/master/experimental/desktop_photo_search" target="_blank" rel="noopener">desktop_photo_search</a> 学习桌面级组件的使用方式。</p><p><img src="/images/1742ea6509b248308020ba3a27388862~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>我们还推荐使用 <a href="https://github.com/google/flutter-desktop-embedding/tree/master/plugins/menubar" target="_blank" rel="noopener">菜单栏插件</a>，<a href="https://api.flutter.dev/flutter/material/NavigationRail-class.html" target="_blank" rel="noopener">NavigationRail 组件</a> 和 <a href="https://api.flutter.dev/flutter/material/DataTable-class.html" target="_blank" rel="noopener">DataTable 组件</a> 等等一系列适合桌面开发的组件，<a href="https://api.flutter.dev/flutter/widgets/InteractiveViewer-class.html" target="_blank" rel="noopener">InteractiveViewer 组件</a> 也完全支持桌面级应用，它可实现通过鼠标手势来平移和缩放子组件。</p><p>已经被 Windows 开发社区广泛使用的，用于创建图表，仪表，数据网格等这些组件，也可以在 <a href="https://pub.dev/publishers/syncfusion.com/packages" target="_blank" rel="noopener">SyncFusion</a> 找到，如下图。</p><p><img src="/images/49e9828839814dfd9fd613b4c09e31f0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h4 id="Flutter-的下一步？"><a href="#Flutter-的下一步？" class="headerlink" title="Flutter 的下一步？"></a>Flutter 的下一步？</h4><p>目前，Flutter Alpha 版已经发布，之后，我们会将注意力主要集中在功能的完善和稳定版产品的发布上。作为一个开源项目，各位开发者都可以 GitHub 上持续关注我们的进展，还未完成的其他工作包括可访问性，全球化和本地化，增强的键盘和文本处理，对命令行参数的支持等等，一切都还待加强。</p><p>除了支持经典的 Win32 API 外，我们也还在试验 <a href="https://docs.microsoft.com/en-us/windows/uwp/get-started/universal-application-platform-guide" target="_blank" rel="noopener">基于UWP的Flutter shell版本</a> ，该版本能够让 Flutter 可以访问更多的基于 Windows 的设备，包括 Xbox。作为该实验的一部分，本周我们就会向 <a href="https://www.microsoft.com/en-us/p/flutter-gallery/9pdwctdfc7qq" target="_blank" rel="noopener">Windows应用商店</a> 发布了基于UWP的 <a href="https://www.microsoft.com/en-us/p/flutter-gallery/9pdwctdfc7qq" target="_blank" rel="noopener">Flutter Gallery</a> 版本。</p><p>下图展示了在 Xbox 上运行的基于 UWP 的 Flutter Gallery：</p><p><img src="/images/5c2493fee25a4837be415f7f24b4c35a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>同样的应用也可以展示在双屏 Windows 设备上；</p><p><img src="/images/4926007f283d4e0e898bc71d28489b23~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p><a href="https://medium.com/flutter/announcing-flutter-windows-alpha-33982cd0f433" target="_blank" rel="noopener">Announcing Flutter Windows Alpha - Chris Sells</a></p><p><a href="http://flutter.dev/desktop" target="_blank" rel="noopener">Flutter Desktop</a></p><p>关注我的公众号「Meandni」，及时阅读最新技术动态。</p><p><img src="/images/qrcode_for_gh_29437cfed0c3_430.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Flutter 最被所我们津津乐道的功能就是能实现 Android 和 iOS 上的开发统一，目前，Google 也已经先后发布了 8 个稳定版，在这两个移动平台上提供了各方面的支持，据不完全统一，Flutter 开发者已经向 Google Pla
      
    
    </summary>
    
      <category term="flutter" scheme="https://meandni.com/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Linux 容器化技术详解（虚拟化、容器化、Docker）</title>
    <link href="https://meandni.com/2020/05/14/virtualization-containerization-docker/"/>
    <id>https://meandni.com/2020/05/14/virtualization-containerization-docker/</id>
    <published>2020-05-14T11:14:27.000Z</published>
    <updated>2020-10-18T07:54:21.118Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>容器化技术自前几年火热发展后一直都是业内非常热门的话题，为了拓展自己的知识面当然也要学起来，本篇文章从发展的角度来解释了它的前世今生，并将它与传统虚拟化技术做对比，并分析他们各自的运行原理。</p></blockquote><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>虚拟化是过去用来充分利用计算机物理资源的最常用方法。早年间，我们可以用一台服务器运行一个操作系统，处理一个任务，带来的问题是资源利用率极其不足，计算机的潜能并不能完全发挥，而后多道批处理系统、分时系统相继出现，Unix、Linux 等操作系统成为了人类 “压榨” 计算机物理资源的神兵利器，而此时，虚拟化技术却并未崭露头角。</p><p>目光聚焦到 20 世纪的 90 年代，当时 IT 行业逐渐步入工业化，大量公司部署起了自己内部的 IT 环境，他们使用了多个不同供应商提供的价格相对低廉的服务器、操作系统和应用程序，此时就暴露出了一个严重的问题：大多数企业使用的都是物理服务器或者由单家供应商提供的应用，每台服务器又只能运行一个供应商特定的任务，不同供应商之间硬件也并不兼容，如果这时候再各自为他们配备不同的硬件设备必然也会面临物理硬件利用率不足的问题。此时虚拟化技术才得以大展身手，它主要解决了<strong>可对服务器分区</strong>、<strong>可在同一个主机上运行不同环境的应用</strong>两个主要的问题。</p><p>自此，服务器开始得到更高效利用，也降低了企业采购、设置、散热和维护的成本。虚拟化的广泛应用也有助于减少企业对单家供应商的依赖，并为后来云计算的发展奠定了基础。</p><h3 id="虚拟化的工作原理"><a href="#虚拟化的工作原理" class="headerlink" title="虚拟化的工作原理"></a>虚拟化的工作原理</h3><p>虚拟化技术的实现主要依托于 <strong>Hypervisor （虚拟机监控程序）</strong>。它处于计算机物理层与虚拟机之间，能够有效地管理计算机的物理资源并将这些资源分配给不同虚拟环境。作为软件，Hypervisor 可以直接运行在操作系统之上；作为服务器，它也可以直接安装在硬件上，这就是大多数企业使用虚拟化的方式。</p><p>此时，Hypervisor 直接接管物理资源，可以对它们做分区处理，分配给了多个虚拟机使用，而用户在虚拟机中也可以通过它直接和计算机底层交互。当虚拟机运行时，如果用户的程序发出一条硬件指令请求资源，Hypervisor 就会直接将请求传递到物理系统做缓存更改，所有这些操作速度都和本机运行速度几近相同，这种直接运行在物理硬件中的 Hypervisor 即为我们经常听说的 <strong>Type1</strong>，也称为裸机管理程序（Metal Hypervisor），目前市面上常用的 VMware ESXi、MiscroSoft Hyper-V 和 KVM（Kernel-based Virtual Machine）都基于这类 Hypervisor。</p><p><img src="/images/TYPE1.jpg" alt="Hypervisor Type1"></p><p>而另一种运行于操作系统之上的 Hypervisor 即为 <strong>Type2</strong>，这种命名方式非常简单粗暴，让人很难忘记，它的处理方式就是使 Hypervisor 不直接与物理层基础，因此也称作托管程序（Hosted Hypervisor），它主要用于面向个体用户，我们经常在本机中安装的 Virtual Box、VMware WorkStation 就属于这种类型。此时，相较于 Type1 ，Type2 显然多了一些延迟。</p><p><img src="/images/type-2-1024x499.jpg" alt="Hypervisor Type2"></p><p>这样，每个虚拟机在 Hypervisor 之上相互独立，运行不同的操作系统，操作不同的物理资源，这也带来了我们期望了灵活性和可移植性，我们可以将一个虚拟机从一个 Hypervisor 中直接迁移到一个新的 Hypervisor 中，此时就达到了一种<strong>环境复用</strong>的效果。</p><p><img src="/images/how-virtualization-works-400x217.png" alt="虚拟化技术原理"></p><h3 id="虚拟化技术应用"><a href="#虚拟化技术应用" class="headerlink" title="虚拟化技术应用"></a>虚拟化技术应用</h3><p>虚拟化发展之初主要用于服务器虚拟化，但随着这种方式逐渐普及，也衍生出了许多诸如网络虚拟化，应用程序虚拟化，数据虚拟化以及存储虚拟化等技术。本篇文章就不对他们再做一一介绍了，感兴趣的读者可以查阅底部衍生查阅中的相关资料。</p><h2 id="容器化技术"><a href="#容器化技术" class="headerlink" title="容器化技术"></a>容器化技术</h2><p>此时，既然虚拟化技术已经成熟，我们就可以投入生产将它运用起来了，如果希望将自己开发的一个 NodeJs 程序放入虚拟机中，就需要在宿主系统中基于 Hypervisor 安装一个 Linux 虚拟机（单独安装 Linux OS），并在 Linux 中为该服务配置一个完整的 JS 应用运行环境和必要的库，如下图所示。</p><p><img src="/images/vm_js.jpg" alt=""></p><p>这样做带来的问题也明显，NodeJS 运行时需要的资源可能非常少（10M），而虚拟机本身却占有相当多的资源（&gt;400M），如果继续在该服务器中放入更多的服务，资源消耗程度可见一般，服务器迅速过载。</p><p><img src="/images/vm_js_2.jpg" alt=""></p><p>从这方面来看，虚拟化技术虽然做到了在同一宿主系统提供不同的任务，解决了硬件层面的硬件资源共享问题，但在应用上层的资源消耗却仍是一个非常大的难题。同时，在日常开发中，如果我们使用的是自己的个人电脑，像 Macbook 开发应用程序时推入服务端也可能存在其他兼容性问题，通常是表现为我的应用程序在本地运行良好，投入生产环境后却病态百出，不利于 DevOps、持续集成和交付。</p><p>容器化通过将应用程序代码和运行所需的相关配置文件，库和依赖项捆绑起来解决了上面描述的两个问题。此时，应用程序和其他依赖项俨然成为了一个整体，打包在一个文件中，而运行这个文件就会生成一个虚拟容器，程序在这个封闭的虚拟容器里运行，容器提供了它想要的一切资源，就好像在真实的物理机上运行一样。有了容器，再也不用担心环境问题了。另外，如下图所示，容器也不会捆绑应用环境所依赖的操作系统，轻量级不言而喻。</p><p><img src="/images/container_js.jpg" alt=""></p><p>要达到应用程序容器化通常只需三步，首先，定义一个清单文件（如 Docker 中的 Dockerfile 或者 Cloud Fundary 中的 yaml 文件），然后，创建一个镜像文件（如 Docker Image 或者 Rocket 的 ACI），最后生成容器即可，这里就包含了应用运行时所有需要的库、二进制文件等等，在上面的例子中，我们同样可以通过该种方式获得 NodeJS 程序的容器并将放入宿主系统中。</p><p><img src="/images/Containerization.jpg" alt="容器化三大步骤"></p><p>此时，容器化技术也可以摒弃冗余的资源消耗，实现更加轻量级的环境部署。另外，再考虑一个问题，如果在我们的 Nodejs 应用中还需要应用其他环境的库，如需要 python 应用做图像识别、java 应用做数据处理，那么，如果使用虚拟化技术，为了达到云原生的方式就必须在之前的宿主主机中释放出一些资源，然后再将 python 等应用部署进去，而当使用容器化技术时只需要在原服务器中放入一个 python 应用的副本，然后利用剩余的空闲资源做容器之间的共存，这正是容器化技术的伟大之处，它可以实现<strong>容器间隔离的同时做到 CPU 资源共享</strong>。</p><p><img src="/images/container_js_2.jpg" alt=""></p><p>此时，容器引擎（如 Docker 引擎）安装在宿主系统中可以成为所有容器共享同一操作系统资源的渠道。</p><blockquote><p>Linux 容器是我们开发、部署和管理应用方式的又一次飞跃。Linux 容器镜像提供了可移植性和版本控制，确保能够在开发人员的笔记本电脑上运行的应用，同样也能在生产环境中正常运行。相较于虚拟机，Linux 容器在运行时所占用的资源更少，使用的是标准化接口（启动、停止、环境变量等），并会与其他应用隔离。此外，作为（包含多个容器）大型应用的一部分时，容器也更易于管理。</p></blockquote><h3 id="容器化技术应用"><a href="#容器化技术应用" class="headerlink" title="容器化技术应用"></a>容器化技术应用</h3><p>容器化技术日益发展，尤其是在云环境中，许多企业已经在考虑将容器替代虚拟机作为他们应用的通用计算平台了，在其如此广泛的应用，如下几个最为典型：</p><ul><li>微服务：容器小巧轻量，非常适合微服务体系结构，在微体系结构中，应用程序可以由许多松散耦合且可独立部署的较小服务构成。</li><li>DevOps：微服务作为架构和容器与平台的结合，可作为许多团队将 DevOps 视为构建，交付和运行软件的方式的共同基础。</li><li>混合云（hybrid cloud）、多云方案（multi-cloud）：由于容器可以在笔记本电脑，本地和云环境中的任何地方运行，因此它是混合云和多云方案的理想基础架构，在这种情况下，企业可以在多个公有云中与数据中心交互。 </li><li>应用程序现代化迁移：容器化可以使应用程序现代化，并直接迁移到云中。</li></ul><h3 id="容器化技术规范化"><a href="#容器化技术规范化" class="headerlink" title="容器化技术规范化"></a>容器化技术规范化</h3><p>随着容器化技术的不断发展，对容器技术和打包软件代码方法的标准化需求也逐渐显现出来了，2015 年 6 月，Docker 和其他行业推动者成立了开放容器计划（OCI），目的就是为了促进容器技术的通用，轻量，开放标准以及规范化，用户也将不会再被特定厂商的技术所束缚，而可以利用 OCI 认证的技术，这些技术使用户能够使用多种 DevOps 工具构建容器化的应用程序，并在基础架构上以一致地标准流程运行这些应用程序。</p><p>目前，Docker 是应用最广泛的容器引擎技术之一，但它也并不是我们唯一的选择，社区也正在对容器化和其他替代方案（例如 CoreOS rkt，Mesos Containerizer，LXC Linux 容器，OpenVZ 和 crio-d 等等）进行标准化。虽然现在，他们的功能和默认设置可能会有所不同，但是随着不断规范化地发展，利用 OCI 规范就能确保解决方案与特定供应商无关，可以完全在多种环境中使用部署应用。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 技术使用的是 Linux 内核和其相关功能（例如 Cgroups 和 namespaces）来分隔进程，达到各进程相互独立运行。这种独立性正是采用容器的意义所在，它可以独立运行多种进程、多个应用，更加充分地利用基础资源，同时保持各个独立系统的安全性。</p><p>此外。Docker 技术与传统的 Linux 容器也并不完全相同，最初它是基于 <a href="https://linuxcontainers.org/" target="_blank" rel="noopener">LXC</a>（LinuX Containers，Linux 容器） 技术构建，但后来它逐渐摆脱了对这种技术的依赖。与虚拟化相比较，LXC 确实独占鳌头，但它并不能提供良好的用户体验，这一点，Docker 显然更胜一筹，除了运行容器之外，Docker 技术也具备其他多项功能，包括简化用于构建容器、传输镜像以及控制镜像版本的流程等等。</p><p>传统的 Linux 容器使用 init 系统来管理多种进程，这使得所有应用都作为一个整体运行在不同的环境中，而 Docker 技术正与此相反，它力争让应用各自独立运行在进程中，并提供相应工具，帮助实现这一功能，这种精细化运作模式自有其优势。</p><h3 id="Docker-实战"><a href="#Docker-实战" class="headerlink" title="Docker 实战"></a>Docker 实战</h3><p>Docker 在各平台安装请参考<a href="https://docs.docker.com/desktop/" target="_blank" rel="noopener">官方文档</a>，安装之后终端执行下面这条命令可以验证是否安装成功：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version</span></span><br></pre></td></tr></table></figure><p>Docker 把应用程序及其依赖都打包在 image 文件里面，通过这个文件就能生成 Docker 容器。执行下面这条指令可以列出本机的所有 image 文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br></pre></td></tr></table></figure><p>如果是第一次运行 Docker，可以执行下面这条命令启动一个 nginx 服务器测试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 80:80 --name myserver nginx</span></span><br></pre></td></tr></table></figure><p>这条命令执行完之后，由于这是第一次运行，并且 nginx 镜像还没有下载到本地，因此 Docker 会自动从 Docker Hub 库中拉去该镜像，如果命令成功完成，此时在本地访问 <a href="http:// localhost">http:// localhost</a> 后就可以查看道 nginx 服务器的主页了。</p><p>下面我来以使用 Docker 安装 Hadoop 环境演示 Docker 具体使用的方法。要将 Hadoop 安装在 Docker 容器中，首先就需要一个 Hadoop Docker 镜像，要想生成镜像，我们可以使用 Github 中的 docker-hadoop 镜像库，执行如下命令拉取该仓库中的代码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/big-data-europe/docker-hadoop.git</span></span><br></pre></td></tr></table></figure><p>docker-hadoop 镜像中就含有生成镜像的清单文件 Makefile，此时，执行下面这条命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d</span></span><br></pre></td></tr></table></figure><p>docker-Compose 可以用来同时安装多个容器。 -d 参数作用是后台运行命令程序并返回命令提示符。仅使用上面的一条命令，就可以设置一个 Hadoop 集群了。</p><p>如果镜像在本地不可用，docker-compose 也会尝试从 docker-hub 库中拉去远程镜像，构建镜像并启动容器。 完成后，就可以使用以下命令来检查当前正在运行的容器了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br></pre></td></tr></table></figure><p>进入 <a href="http:// localhost:9870">http:// localhost:9870</a> 就可以从名称节点查看系统的当前状态了。</p><p>当然，除了使用这种方法使用别人在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">docker-hub</a> 或者 Github  开源的镜像，我们也可以自定义镜像，这种方式本篇文章先不做讨论。本篇到这里先结束了，看完后关于虚拟化和容器的概念你是不是都掌握了？大家有任何问题可直接联系我，也可在博客评论区讨论。</p><h2 id="参考文章以及衍生阅读"><a href="#参考文章以及衍生阅读" class="headerlink" title="参考文章以及衍生阅读"></a>参考文章以及衍生阅读</h2><p><a href="https://www.redhat.com/en/topics/virtualization/what-is-virtualization" target="_blank" rel="noopener">RED-HAT-what-is-virtualization</a></p><p><a href="https://www.redhat.com/en/topics/containers/whats-a-linux-container" target="_blank" rel="noopener">RED-HAT-What’s a Linux container?</a></p><p><a href="https://opensource.com/article/18/1/history-low-level-container-runtimes" target="_blank" rel="noopener">A history of low-level Linux container runtimes</a></p><p><a href="https://www.redhat.com/zh/topics/virtualization/what-is-KVM" target="_blank" rel="noopener">RED-HAT-what-is-KVM</a></p><p><a href="https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/" target="_blank" rel="noopener">Docker 背后的内核知识——cgroups 资源限制</a></p><p>部分图片来自：<a href="https://blog.resellerclub.com/what-is-virtualization-and-how-does-it-work/" target="_blank" rel="noopener">what-is-virtualization-and-how-does-it-work</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;容器化技术自前几年火热发展后一直都是业内非常热门的话题，为了拓展自己的知识面当然也要学起来，本篇文章从发展的角度来解释了它的前世今生，并将它与传统虚拟化技术做对比，并分析他们各自的运行原理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;虚拟
      
    
    </summary>
    
      <category term="深入理解计算机" scheme="https://meandni.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Linux" scheme="https://meandni.com/tags/Linux/"/>
    
      <category term="容器化" scheme="https://meandni.com/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/"/>
    
      <category term="虚拟化" scheme="https://meandni.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="Docker" scheme="https://meandni.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>深入理解字符编码（ASCII、Unicode、UTF-8、UTF-16、UTF-32）</title>
    <link href="https://meandni.com/2020/05/12/3619/"/>
    <id>https://meandni.com/2020/05/12/3619/</id>
    <published>2020-05-12T13:50:55.000Z</published>
    <updated>2020-10-18T07:54:19.001Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>接近一年没有更新博客了，这是 2020 的第一篇，源于对基础知识的巩固，主要会从多个维度解释字符编码的由来以及内部原理。</p></blockquote><p>大家都知道，程序中的所有信息都是以二进制的形式存储在计算机的底层，也就是说我们在代码中定义的一个 char 字符或者一个 int 整数都会被转换成二进制码储存起来，这个过程可以被称为<strong>编码</strong>，而将计算机底层的二进制码转换成屏幕上有意义的字符（如“hello world”），这个过程就称为<strong>解码</strong>。</p><p>在计算机中字符的编解码就涉及到<strong>字符集（Character Set）</strong>这个概念，他就相当于能够将一个字符与一个整数一一对应的一个映射表，常见的字符集有 ASCII、Unicode 等。</p><p>很多时候我们会将字符集的编码与字符集混为一谈，从这里就可以看出它们并非同一个概念，字符集仅仅是一个字符的集合，而编码却是一个更复杂的过程。至于为什么会经常将这两个概念放在一起，他们之间的联系是什么，我们经常使用的 UTF-8 又是什么，这就是这篇文章我要讨论的话题。</p><h2 id="ASCII-编码"><a href="#ASCII-编码" class="headerlink" title="ASCII 编码"></a>ASCII 编码</h2><p>历史中的很长一段时间里，计算机仅仅应用在欧洲的一些发达国家，因此在他们的程序中只存在他们所理解的拉丁字母（如a、b、c、d等）和阿拉伯数字，他们在编码解码时也只需要考虑这一种情况，就是如何将这些字符转换成计算机所能理解的二进制数，此时 ASCII 字符集应运而生，他们在编码时只需要对照着 ASCII 字符集，每当在程序中遇到字符 a 时，就会相应的找到其中 a 对应的 ASCII 值 97 然后以二进制形式存起来即可。</p><p>下图展示了 ASCII 字符集对照表，其中包括了控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-112705iz0fn8ppf0hqdxfw.jpg" alt="ASCII 码对照表"></p><p>这种编码方式就被称为 ASCII 编码，从字符集对照表中可以看出，ASCII 字符集支持 128 种字符，仅使用 7 个 bit 位，也就是一个字节的后 7 位就可以将它们全部表示出来，而最前面的一位统一规定为 0 即可（如 0110 0001 表示 a）。</p><p>后来，为了能够表示更多的欧洲国家的常用字符如法语中带符号的字符 <code>é</code>，又制定了 ASCII 额外扩展的版本 EASCII，这里就可以使用一个完整子节的 8 个 bit 位表示共 256 个字符，其中就又包括了一些衍生的拉丁字母。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-ascii2-en.jpg" alt="拓展 ASCII 码表"></p><h2 id="非-ASCII-编码"><a href="#非-ASCII-编码" class="headerlink" title="非 ASCII 编码"></a>非 ASCII 编码</h2><p>ASCII 字符集沿用至今，但它最大的缺点在于只能表示基本的拉丁字母、阿拉伯数字和英式标点符号，因此只能表示现代美国英语（而且在处理英语当中的外来词如 naïve、café、élite 等等单词时，所有重音符号都不得不去掉）。而 EASCII 虽然解决了部份西欧语言的显示问题，但是当计算机传入亚洲之后，各国的语言依然不能完整地表示出来。</p><p>在这个年代，每个国家就各自来对 ASCII 字符集做了拓展，最具代表性的就是国内的 GB 类的汉字编码模式，这种模式规定：ASCII 值小于 127 的字符的意义与原来 ASCII 集中的字符相同，但当两个 ASCII 值大于 127 的字符连在一起时，就表示一个简体中文的汉字，前面的一个字节（高字节）从 0xA1 拓展到 0xF7，后面一个字节（低字节）从 0xA1 到 0xFE，这样就可以组合出了大约 7000 多个简体汉字了。</p><p>为了在解码时操作的统一，GB 类编码表中还也加入了数学符号、罗马希腊的字母、日文的假名等，连在 ASCII 里本来就有的数字、标点、字母都统一重新表示为了两个字节长的编码，这就是我们常说的 “全角” 字符，而原来在 127 号以下的那些就叫 “半角” 字符了，这种编码规则就是后来的 GB2312。</p><blockquote><p>“一个汉字算两个英文字符！一个汉字算两个英文字符……”</p></blockquote><p>下图展示了 GB2312 字符集中的一小部分，具体可查看 <a href="http://www.knowsky.com/resource/gb2312tbl.htm" target="_blank" rel="noopener">GB2312 简体中文编码表</a>。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-201105031137227086.png" alt="GB2312 简体中文编码表"></p><p>这样，我们中国就有了属于自己的字符集了，但中国的汉字又实在是太多了，人们很快就发现 GB2312 字符集只能够那点汉字明显不够（如中国前总理朱镕基的 “镕” 字并不在 GB2312 字符集中），于是专家们又继续把 GB2312 没有用到的码位使用到其他没有被收录的汉字中。</p><p>后来还是不够用，于是干脆不再要求低字节一定是 127 号之后的内码，只要第一个字节是大于 127 就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近 20000 个新的汉字（包括繁体字）和符号。</p><p>当时的各个国家都像中国这样制定出了一套自己的编码标准，之后当我们需要使用计算机与国际接轨时，问题出现了！国家与国家之间谁也不懂谁的编码，130 在法语编码中代表了 <code>é</code>，在希伯来语编码中却代表了字母 <code>Gimel</code> (<code>ג</code>)，在俄语编码中又会代表另一个符号。但是所有这些编码方式中，0—127 表示的符号依然都是一样的，因为他们都兼容 ASCII 码，这一点，如今也是一样。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>正如上一节中所说的，世界上各国都有不同的编码方式，同一个二进制数字可以被解码成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为了解决这个问题，最终的集大成者 Unicode 字符集出现了，它将世界上所有的符号都纳入其中，成功实现了每个数字代表唯一的至少在某种语言中使用的符号，目前，Unicode 字符集中已经收录超过 13 万个字符（第十万个字符在2005年获采纳）。值得关注的是，Unicode 依然兼容 ASCII，即 0～127 意义依然不变。</p><h3 id="码点"><a href="#码点" class="headerlink" title="码点"></a>码点</h3><p>Unicode 表示的是一个字符集，与我们通常所说的 UTF-8、UTF-6 等编码方式并不相同，本节介绍的<strong>编号</strong>就相当于 ASCII 码中的 ASCII 值，它就是 Unicode 字符集中唯一表示某个字符的标识，在 Unicode 也称作<strong>码点（Code Point）</strong>，如码点 U+0061，这里的 61 就是 97 的十六进制表示，它就表示 Unicode 字符集中的字符 ‘a‘。</p><p>码点的表示的形式为 U+[XX]XXXX，X 代表一个十六制数字，一般可以有 4-6 位，不足 4 位前补 0 补足 4 位，超过则按是几位就是几位，具体范围是 U+0000~U+10FFFF，大概是 111 万。按 Unicode 官方的说法，码点范围就这样了，以后也不扩充了，一百多万足够用了，目前也只定义了 11 万多个字符左右。</p><p>整个编码过程中码点就作为了一个中间的过渡层，可用下面这张图来表示：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-210113_iRnr_1772009.jpg" alt="字符编码过程"></p><p>从这张图可以看出，整个解码可分为两个过程。首先，将程序中的字符根据字符集中的编号数字化为某个特定的数值，然后根据编号以特定的方式存储到计算机中。</p><p>显然，这时候我们就可以发现<strong>编号并不是最终存储在计算机中的结果</strong>。按照之前的理解，编码即把一个字符编码为一个二进制数字存储起来，然而这种表述并不准确，真正的编码不止这么简单，这其中还涉及了每个数字用几个字节表示，是用定长还是变长表示等具体细节。</p><p>举个例子，字符 a 的码点为 U+0061（十进制为 97），那么这个 U+0061 该如何存储，单纯的表示 U+0061 可以直接使用 7 位的二进制数 110 0001 表示，但在 GB 类的编码模式中就需要以两个字节存储即 0000 0000 0110 0001（空位用 0 填充）。</p><h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><p>Unicode 字符集衍生出来的编码方案有三种，分别是 UTF-32、UTF-16 和 UTF-8，这使他与之前的编码模式不同，因为 ASCII、GBK 等类编码模式的字符集和编码方式都是一一对应的，而 Unicode 的编码实现却有三种，这就是我们需要区分字符集与编码的原因之一，因为此时 Unicode 并不特指  UTF-8 或者 UTF-32。</p><p>下面，我们来看下面这张示意图，探究各种编码模式下，码点是如何具体转换成各种<strong>编码</strong>的：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-unicode%20from%20char%20to%20code%20point%20then%20utf.svg" alt=""></p><p>上面表中包含了四个字符的码点，其中也展示了四个不同的码点在 UTF-32、UTF-16 和 UTF-8 三种编码模式下的编码结果。其中：码点到 UTF-32 的转换最简单，就是在前面填充 0 满 4 字节即可；码点到 UTF-8 的转换，除了最小那个在数值上一样外，其它三个完全看不出两者的关系；码点到 UTF-16 的转换则是最不规则的，可以看出前三个字符 UTF-16 与码点是完全一致的，但那个大码点（准确地说是超过了 U+FFFF 的码点）则有了很大的变化，长度变成了四字节，值也变得很不一样了。</p><p>这其中又涉及到编码过程中<strong>定长</strong>与<strong>变长</strong>两种实现方式，这里的 UTF-32 就属于定长编码，即永远用 4 字节存储码点，而 UTF-8、UTF-16 就属于变长存储，UTF-8 根据不同的情况使用 1-4 字节，而 UTF-16 使用 2 或 4 字节来存储码点。</p><h3 id="定长于变长"><a href="#定长于变长" class="headerlink" title="定长于变长"></a>定长于变长</h3><p>为什么要有定长于变长这两种编码形式？在中文的表达中都会有所谓的断句问题，如果我们处理不好断句很有可能会将意思传递错误。如下面这句来自算命先生纸条中的内容：</p><blockquote><p>大富大贵没有灾难要小心</p></blockquote><p>此时，如果算命侠客这样断句：</p><blockquote><p>大富大贵，没有灾难要小心</p></blockquote><p>表示我福大命大，没有灾难，可以肆意妄为了，但是没过多久这位侠客就去世了，算名先生绝望地说，你会错意了，原来，其实是这样断句的：</p><blockquote><p>大富大贵没有，灾难要小心</p></blockquote><p>表示你没有大富大贵，出门要小心，断句就可能会出现这样严重的后果。</p><p>这也是计算机在解码时需要使用定长与变长的原因。因为计算机底层的二进制码也和算命先生纸条中的内容一样，毫无章法，我们如果想要正确理解其中的意思就要有一个约定俗成的规则。</p><h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>在 UTF-32 这种定长的编码方式下就表示每 4 个子节一个断句，那么字符 A 的码点 U+0041（二进制为 1000001）被 UTF-32 编码后就会变成如下形式存储在计算机中：</p><blockquote><p><strong>00000000 00000000 00000000 01000001</strong></p></blockquote><p>它会将 4 个字节中空出的高位全部填充为 0。这种表示的最大缺点是占用空间太大，因为不管都大的码点都需要四个字节来存储，非常的占空间，那么如何突破这个瓶颈呢？变长方案应运而生。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8 属于变长的编码方式，它可以由 1，2，3，4 四种字节组合，使用的是<strong>高位保留</strong>的方式来区别不同变长，具体方式如下：</p><ol><li><p>对于只有一个字节的符号，字节的第一位设为<code>0</code>，后面 7 位为这个符号的 Unicode 码。此时，对于英语字母UTF-8 编码和 ASCII 码是相同的。</p></li><li><p>对于 <code>n</code> 字节的符号（<code>n &gt; 1</code>），第一个字节的前 <code>n</code> 位都设为 <code>1</code>，第 <code>n + 1</code> 位设为<code>0</code>，后面字节的前两位一律设为 <code>10</code>。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码，如下表所示：</p></li></ol><div class="table-container"><table><thead><tr><th>Unicode 码点范围（十六进制）</th><th>UTF-8 编码方式（二进制）</th><th>字节数</th></tr></thead><tbody><tr><td>0000 0000 ～ 0000 007F</td><td>0xxxxxxx</td><td>一个字节</td></tr><tr><td>0000 0080 ～ 0000 07FF</td><td>110xxxxx 10xxxxxx</td><td>二个子节</td></tr><tr><td>0000 0800 ～ 0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td><td>三个字节</td></tr><tr><td>0001 0000 ～ 0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td><td>四个字节</td></tr></tbody></table></div><p>跟据上表，编码字符时就非常简单了，以汉字 “丑” 为例，它的码点为 0x4E11（0100 1110 0001 0001）在上表的第三行范围（0000 0800 ～ 0000 FFFF）内，因此 “丑” 需要以三个字节的形式编码：</p><p>   <img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-UTF8-3-byte-encoding-20200512210902622.png" alt="UTF-8 占 3 个字节填入格式"></p><p>   这里最高位的第一个字节中的三个 1 表示该字符占 3 个字节，空出的 16 位 x 就会从 “丑” 的最后一个二进制位开始，依次从后向前填入格式中，多出的位补 0，这样就得到了 “丑” 的 UTF-8 编码是 11100100 10111000 10010001，转换成十六进制就是 E4B891。</p><p>   解码 UTF-8 编码也很简单了，如果一个字节的第一位是 0，则这个字节单独就是一个字符；如果第一位是<code>1</code>，则连续有多少个 1，就表示当前字符占用多少个字节，”丑” 有三个 1 表示占三个字符，然后取出有效位即可。 </p><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF-16 使用的是一种变长为 2 或 4 字节编码模式。</p><p>最初，Unicode1.0 被设计为纯 16 位编码，拥有 65,536 个码点（U+0000～U+FFFF），目的就是希望能够表示所有现代字符，然而随着时间推移，16 位对于计算机而言显然是不够的，因此产生了如今的 4 字节的 UTF-16 编码，此时，Unicode 就具有了 1,114,112 个代码点（U+10000 ～ U+10FFFF），这就是我们之前介绍 Unicode。 </p><p>此时，范围在 U+0000～U+FFFF 的码点被称了为 <strong>BMP（Basic Multilingual Plane，基本多语言平面）</strong>，而后来拓展的范围 U+10000 ～ U+10FFFF 称为 <strong>SP（Supplementary Planes，增补平面）</strong>。UTF-16 就是利用 BMP 使用<strong>代理</strong>的方式来对字符进行编码。</p><blockquote><p>何为代理？</p></blockquote><p>代理和 UTF-8 中的高位保留的目的一样，就是为了能够实现变长的编码方式。</p><blockquote><p>什么是代理区？</p></blockquote><p>代理区由两个特殊范围（BMP 中的空闲部分）的 Unicode 码点组成，总共有 2048 个位置，均分为<strong>高代理区</strong>（D800–DBFF）和<strong>低代理区</strong>（DC00–DFFF）两部分，各 1024，这两个区可以组成一个二维的表格，共有 1,024 x 1,024 = 1,048,576 = 16×65536 个单元格，所以它恰好可以表示代理（增补）的 16 位中的所有字符。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-05005221_ENrq.png" alt="BMP中的空闲区域"></p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-05005224_ngsJ.png" alt="代理区二维表格"></p><p>这种从一维存储转换到二维存储的方式就可以实现空间增大的效果了，UTF-16 也就有了能够额外获得码点的方式了。</p><p>一个高代理区（即上图中的 Lead（头），行）的加一个低代理区（即上图中的Trail（尾），列）的编码组成一对<strong>代理对（Surrogate Pair）</strong>。在图中就可以看到一些转换的例子，如</p><p>（<strong>D8 00</strong> <strong><em>DC 00</em></strong>）—&gt;U+10000，左上角，第一个增补字符</p><p>（<strong>DB FF</strong> <strong><em>DF FF</em></strong>）—&gt;U+10FFFF，右下角，最后一个增补字符</p><blockquote><p>从 UTF-16 转换为字符代码的算法是什么？</p></blockquote><p>分成两部分：</p><ol><li><p>BMP 中直接对应，无须做任何转换；</p></li><li><p>增补平面 SP 中，则需要做相应的计算。其实由上图中的表也可看出，码点就是从上到下，从左到右排列过去的，所以只需做个简单的除法，拿到除数和余数即可确定行与列。</p><p>拿到一个码点，先减去 10000，再除以 400（=1024）就是所在行了，余数就是所在列了，再加上行与列所在的起始值，就得到了代理对了。</p></li></ol><script type="math/tex; mode=display">C_H =（码点 – 10000_{16}）\div 400_{16} + D800_{16}</script><script type="math/tex; mode=display">C_L =（码点 – 10000_{16}）\% 400_{16} + DC00_{16}</script><p>需要关注的是，最常用的字符依然是在 BMP 平面中编码的，下表给出了各码点范围内 UTF-16 编码取值方法：</p><div class="table-container"><table><thead><tr><th>Unicode 码点范围</th><th>UTF-16 编码</th></tr></thead><tbody><tr><td>U+0000..U+D7FF</td><td>BMP内，一个字节，不做转换</td></tr><tr><td>U+D800..U+DFFF</td><td>BMP 空闲区</td></tr><tr><td>U+E000..U+FFFF</td><td>BMP内，一个字节，不做转换</td></tr><tr><td>U+10000..U+10FFFF</td><td>两个字节: 高位+低位</td></tr></tbody></table></div><p>下面以码点 U+1D11E 具体示例计算代理对：</p><script type="math/tex; mode=display">高代理 = (1D11E – 10000_{16}) ÷ 400_{16} + DB00 = D11E ÷ 400_{16} + D800 = 34 + D800 = D834</script><script type="math/tex; mode=display">低代理 = (1D11E – 10000_{16}) \% 400_{16} + DC00 = D11E \% 400_{16} + DC00 = 11E + DC00 = DD1E</script><p>所以，码点 U+1D11E 对应的代理对即是 D834 DD1E。下表又列举出了其他字符的 UTF-16 的编码过程：</p><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">码点</th><th style="text-align:center">Unicode 二进制编码</th><th style="text-align:center">UTF-16 代码单元</th><th style="text-align:center">UTF-16 十六进制字节</th></tr></thead><tbody><tr><td style="text-align:center">$</td><td style="text-align:center">U+0024</td><td style="text-align:center">0000 0000 0010 0100</td><td style="text-align:center">0000 0000 0010 0100</td><td style="text-align:center">0024</td></tr><tr><td style="text-align:center">€</td><td style="text-align:center">U+20AC</td><td style="text-align:center">0010 0000 1010 1100</td><td style="text-align:center">0010 0000 1010 1100</td><td style="text-align:center">20AC</td></tr><tr><td style="text-align:center">[𐐷</td><td style="text-align:center">U+10437</td><td style="text-align:center">0001 0000 0100 0011 0111</td><td style="text-align:center">1101 1000 0000 0001 1101 1100 0011 0111</td><td style="text-align:center">D801 DC37</td></tr><tr><td style="text-align:center">𤭢</td><td style="text-align:center">U+24B62</td><td style="text-align:center">0010 0100 1011 0110 0010</td><td style="text-align:center">1101 1000 0101 0010 1101 1111 0110 0010</td><td style="text-align:center">D852 DF62</td></tr></tbody></table></div><p>和 UTF-8 中高位保留的方式一样，UTF-16 在各码点范围内同样拥有一个二进制到实际编码单元的映射表，如下：</p><div class="table-container"><table><thead><tr><th>Codepoint range</th><th>Unicode 二进制</th><th>UTF-16 编码方式（代码单元）</th></tr></thead><tbody><tr><td>U+0000 ～ U+D7FF，U+E000 ～U+EFFF</td><td>00000xxxxxxxxxxxxxxxx</td><td>xxxxxxxxxxxxxxxx</td></tr><tr><td>U+10000 ～ U+10FFFF</td><td>Uuuuuxxxxxxyyyyyyyyyy</td><td>110110wwwwxxxxxx 110111yyyyyyyyyy</td></tr></tbody></table></div><p>按照上面的两个表我们也不难发现其中的规律，在 U+10000 ～ U+10FFFF 范围内的码点在编码时可以分别将第一个子节和第三个字节的高位设为 110110 和 110111，然后再根据 Unicode 二进制码各位填补即可（其中，<strong>这里的uuuuu = wwww + 1</strong>）。</p><p>本篇到此结束，大家有任何问题可直接联系我，也可在博客评论区讨论。</p><h2 id="参考文章以及衍生阅读"><a href="#参考文章以及衍生阅读" class="headerlink" title="参考文章以及衍生阅读"></a>参考文章以及衍生阅读</h2><p><a href="https://unicodebook.readthedocs.io/about.html" target="_blank" rel="noopener">Programming with Unicode</a></p><p><a href="https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&amp;id=IWS-AppendixA" target="_blank" rel="noopener">Mapping codepoints to Unicode encoding forms</a></p><p><a href="https://xiaogd.net/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e4%b8%89%ef%bc%89-%e5%ae%9a%e9%95%bf%e4%b8%8e%e5%8f%98%e9%95%bf/" target="_blank" rel="noopener">字符集与编码（三）——定长与变长</a></p><p><a href="https://xiaogd.net/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e5%9b%9b%ef%bc%89-unicode/#%E7%A0%81%E7%82%B9%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E4%B8%8E%E8%8C%83%E5%9B%B4%E6%98%AF%EF%BC%9F" target="_blank" rel="noopener">字符集与编码（四）——Unicode</a></p><p><a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">wiki-UTF-16</a></p><p><a href="https://unicode.org/faq/utf_bom.html" target="_blank" rel="noopener">General questions, relating to UTF or Encoding Form</a></p><p><a href="https://blog.csdn.net/stilling2006/article/details/4129700" target="_blank" rel="noopener">字符编码详解及由来(UNICODE,UTF-8,GBK)</a></p><p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p><p><a href="https://naveenr.net/unicode-character-set-and-utf-8-utf-16-utf-32-encoding/" target="_blank" rel="noopener">Unicode Character Set and UTF-8, UTF-16, UTF-32 Encoding</a></p><p><a href="https://home.unicode.org/" target="_blank" rel="noopener">Unicode 官网</a></p><p><a href="http://www.chi2ko.com/tool/CJK.htm" target="_blank" rel="noopener">Unicode 中文汉字编码表</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;接近一年没有更新博客了，这是 2020 的第一篇，源于对基础知识的巩固，主要会从多个维度解释字符编码的由来以及内部原理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家都知道，程序中的所有信息都是以二进制的形式存储在计算机的底层，也就是说我们在代码
      
    
    </summary>
    
      <category term="深入理解计算机" scheme="https://meandni.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="字符编码" scheme="https://meandni.com/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    
      <category term="编码原理" scheme="https://meandni.com/tags/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/"/>
    
      <category term="ASCII" scheme="https://meandni.com/tags/ASCII/"/>
    
      <category term="Unicode" scheme="https://meandni.com/tags/Unicode/"/>
    
      <category term="UTF-8" scheme="https://meandni.com/tags/UTF-8/"/>
    
      <category term="UTF-16" scheme="https://meandni.com/tags/UTF-16/"/>
    
      <category term="UTF-32" scheme="https://meandni.com/tags/UTF-32/"/>
    
  </entry>
  
  <entry>
    <title>Flutter动画全解析（动画四要素、动画组件、隐式动画组件原理等）</title>
    <link href="https://meandni.com/2019/07/01/c0f2/"/>
    <id>https://meandni.com/2019/07/01/c0f2/</id>
    <published>2019-06-30T16:00:00.000Z</published>
    <updated>2020-10-18T07:44:46.389Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文通过拆解 Flutter 中动画的实现方式以及原理来介绍动画实现的整个过程。</p></blockquote><h2 id="1-动画四要素"><a href="#1-动画四要素" class="headerlink" title="1. 动画四要素"></a>1. 动画四要素</h2><p>动画在各个平台的实现原理都基本相同，都是由在一段时间内一系列连续变化画面的帧构成的。在 Flutter 中，动画的过程又被量化成一段值区间，我们可以利用这些值设置控件的各个属性来实现动画，其内部由四个关键的部分来实现这一过程。</p><h3 id="1-1-插值器（Tweens）"><a href="#1-1-插值器（Tweens）" class="headerlink" title="1.1 插值器（Tweens）"></a>1.1 插值器（Tweens）</h3><p>tweens 可为动画提供起始值和结束值。默认情况下，Flutter 中的动画将任何给定时刻的值映射到介于 0.0 和 1.0 之间的 double 值。 我们可以使用以下 Tween 将其间值的范围定义为从 -200.0变为 0.0：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">tween = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">-200</span>, end: <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>我们也可以将值设置为相应需要改变的对象值，比如将起始值设置为红色，结束值设置为蓝色，那么 tweens 产生的动画便是由红渐渐的变成蓝色。如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">colorTween = ColorTween(begin: Colors.red, end: Colors.blue);</span><br></pre></td></tr></table></figure><h3 id="1-2-动画曲线（Animation-Curves）"><a href="#1-2-动画曲线（Animation-Curves）" class="headerlink" title="1.2 动画曲线（Animation Curves）"></a>1.2 动画曲线（Animation Curves）</h3><p>Curves 用来调整动画过程中随时间的变化率，默认情况下，动画以均匀的线性模型变化。读者可以通过自定义继承 Curves 的类来定义动画的变化率，比如设置为加速、减速或者先加速后减速等曲线模型。Flutter 内部也提供了一系列实现相应变化率的 Curves 对象：</p><ul><li>linear</li><li>decelerate</li><li>ease</li><li>easeIn</li><li>easeOut</li><li>easeInOut</li><li>fastOutSlowIn</li><li>bounceIn</li><li>bounceOut</li><li>bounceInOut</li><li>elasticIn</li><li>elasticOut</li><li>elasticInOut</li></ul><p>相关动画曲线模型图如下：</p><p><img src="/images/curve_linear.gif" alt="curve_linear"></p><p><img src="/images/curve_bounce_in.gif.gif" alt="curve_bounce_in"></p><p><img src="/images/curve_ease_in.gif.gif" alt="curve_ease_in"></p><h3 id="1-3-Ticker-providers"><a href="#1-3-Ticker-providers" class="headerlink" title="1.3 Ticker providers"></a>1.3 Ticker providers</h3><p>Flutter 中的动画以屏幕频繁的重绘而实现，即每秒 60 帧。Ticker 可以被应用在 Flutter 每个对象中，当对象实现了 Ticker 的功能后，每次动画帧改变便会通知该对象。这里，开发者们不需要为对象手动实现 Ticker，flutter 提供了 TickerProvider 类可以帮助我们快速实现该功能。例如，在有状态控件下使用动画时，通常需要在 State 对象下混入 TickerProviderStateMixin。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAnimationState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyAnimation</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-动画控制器（AnimationController）"><a href="#1-4-动画控制器（AnimationController）" class="headerlink" title="1.4 动画控制器（AnimationController）"></a>1.4 动画控制器（AnimationController）</h3><p>Flutter 中动画的实现还有一个非常重要的类 AnimationController，即动画控制器。很明显，我们用它来控制动画，即动画的启动、暂停等。其接受两个参数，第一个是 vsync，为 Ticker 对象，其作用是当接受到来自 tweens 和 curves 的新值后通知对应对象，第二个 duration 参数为动画持续的时长。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混入 SingleTickerProviderStateMixin 使对象实现 Ticker 功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimatedContainerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimatedContainer</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController _controller;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 创建 AnimationController 动画</span></span><br><span class="line">    _controller = AnimationController(</span><br><span class="line">      <span class="comment">// 传入 Ticker 对象</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">      <span class="comment">// 传入 动画持续时间</span></span><br><span class="line">      duration: <span class="keyword">new</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>),</span><br><span class="line">    );</span><br><span class="line">    startAnimation();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; startAnimation() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 AnimationController 的 forward 方法启动动画</span></span><br><span class="line">    <span class="keyword">await</span> _controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      width: _controller.value;</span><br><span class="line">      child: <span class="comment">//...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnimationController 继承自 Animation，具有一系列控制动画的方法，如可用 <code>forward()</code> 方法来启动动画，可用 <code>repeat()</code> 方法使动画重复执行，也可以通过其 value 属性得到当前值。</p><h4 id="1-4-1-Animation"><a href="#1-4-1-Animation" class="headerlink" title="1.4.1 Animation"></a>1.4.1 Animation</h4><p>我们可以通过在 CurvedAnimation 传入 AnimationController 和 Curve 对象创建一个 Animation 对象，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimationController controller = AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; animation = CurvedAnimation(</span><br><span class="line">  parent: controller,</span><br><span class="line">  curve: Curves.ease,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>也可以通过调用 tween 的 animate 方法传入 controller 对象创建 Animation 对象，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimationController controller = AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(controller);</span><br></pre></td></tr></table></figure><p>Animation 是一个抽象类，其中保存了动画的过程值（value）和状态，下面是四种状态类型。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> AnimationStatus &#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">动画处于停止状态</span></span></span><br><span class="line">  dismissed,</span><br><span class="line">  <span class="comment">/// <span class="markdown">动画从头到尾执行</span></span></span><br><span class="line">  forward,</span><br><span class="line">  <span class="comment">/// <span class="markdown">动画从尾到头执行</span></span></span><br><span class="line">  reverse,</span><br><span class="line">  <span class="comment">/// <span class="markdown">动画已执行完成</span></span></span><br><span class="line">  completed,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnimationController 是它的一个实现类。其内部通过范型机制可实现对各类型对象的动画，比如 <code>Animation&lt;double&gt;</code>、<code>Animation&lt;Color&gt;</code>、<code>Animation&lt;Size&gt;</code> 等。其另一个实现类 Curved­Animation，可以用来与 Curves 结合实现各类曲线模型函数的动画。</p><p>Animation 另一个实现方法是调用 tween 对象的 animate 方法传入 Animation 对象创建另一个 Animation 对象，该方法可通过将使动画值定义在 tween 区间内，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimationController controller = AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> Animation curve =</span><br><span class="line">    CurvedAnimation(parent: controller, curve: Curves.easeOut);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(curve);</span><br></pre></td></tr></table></figure><h4 id="1-4-5-动画监听"><a href="#1-4-5-动画监听" class="headerlink" title="1.4.5 动画监听"></a>1.4.5 动画监听</h4><p>Animation 对象可以有设置两种监听器，分别是帧监听器和状态监听器。使用 <code>addListener()</code> 添加帧监听器，使用<code>addStatusListener()</code>  添加状态监听器。</p><p>只要动画的值发生变化，就会触发帧监听器的回调。 通常，我们在其内部调用 <code>setState()</code> 来重建组件来实现动画效果，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">animation = <span class="keyword">new</span> CurvedAnimation(</span><br><span class="line">        parent: animationController, curve: Curves.elasticOut)</span><br><span class="line">animation.addListener(() =&gt; <span class="keyword">this</span>.setState(() &#123;&#125;))</span><br></pre></td></tr></table></figure><p>动画开始，结束，前进或后退时会触发 StatusListener 的回调，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">animation = <span class="keyword">new</span> CurvedAnimation(</span><br><span class="line">        parent: animationController, curve: Curves.elasticOut)</span><br><span class="line">animation.addStatusListener((AnimationStatus status) &#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="2-动画组件"><a href="#2-动画组件" class="headerlink" title="2. 动画组件"></a>2. 动画组件</h2><p>我们已经知道了 Flutter 控制动画的四大要素，其中涉及的各个概念可以帮助我们设计出各种各样的动画效果，但不免也多了一些需要重复编写的模版代码，比如，在 Animation 的帧监听器设置的监听器回调里，几乎所有场景中我们都只是调用 <code>setState()</code>，再比如 State 对象每次都需要我们手动地混入 <code>SingleTickerProviderStateMixin</code> 等等这类情况。Flutter 为了提高开发者的开发效率，提供了 AnimatedWidget 抽象类来封装这部分模版代码，其源码非常简单，如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimatedWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">该 Widget 在 listenable 状态改变后将会重建.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[listenable] 为必要参数.</span></span></span><br><span class="line">  <span class="keyword">const</span> AnimatedWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.listenable</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(listenable != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The [Listenable] to which this widget is listening.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">一般是一个 [Animation] 或者 [ChangeNotifier] 对象.</span></span></span><br><span class="line">  <span class="keyword">final</span> Listenable listenable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">继承该方法构建依赖 listenable（当前 value 值等） 状态的 Widget.</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _AnimatedState createState() =&gt; _AnimatedState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimatedState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimatedWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    widget.listenable.addListener(_handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(AnimatedWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">    <span class="keyword">if</span> (widget.listenable != oldWidget.listenable) &#123;</span><br><span class="line">      oldWidget.listenable.removeListener(_handleChange);</span><br><span class="line">      widget.listenable.addListener(_handleChange);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    widget.listenable.removeListener(_handleChange);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleChange() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// 状态改变，重建 Widget.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; widget.build(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnimatedWidget 作为一个抽象类可供我们实现一个我们自己的具体类，其接受一个 Listenable 对象作为参数，并需要重写 <code>build</code> 方法。我们上一节中多次提到的 Animation 继承自 Listenable。下面的这个这个组件就是我自己实现的动画组件：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sun</span> <span class="keyword">extends</span> <span class="title">AnimatedWidget</span> </span>&#123;</span><br><span class="line">  Sun(&#123;Key key, Animation&lt;Color&gt; animation&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key, listenable: animation);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> Animation&lt;Color&gt; animation = listenable;</span><br><span class="line">    <span class="keyword">var</span> maxWidth = MediaQuery.of(context).size.width;</span><br><span class="line">    <span class="keyword">var</span> margin = (maxWidth * <span class="number">.3</span>) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AspectRatio(</span><br><span class="line">        aspectRatio: <span class="number">1.0</span>,</span><br><span class="line">        child: <span class="keyword">new</span> Container(</span><br><span class="line">            margin: EdgeInsets.symmetric(horizontal: margin),</span><br><span class="line">            constraints: BoxConstraints(</span><br><span class="line">              maxWidth: maxWidth,</span><br><span class="line">            ),</span><br><span class="line">            decoration: <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">              shape: BoxShape.circle,</span><br><span class="line">              color: animation.value,</span><br><span class="line">            )));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过传入已经定义好的 Animation 对象来使用该组件：??</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimateWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimateWidget</span>&gt; </span>&#123;</span><br><span class="line">  AnimationController _animationController;</span><br><span class="line">  ColorTween _colorTween;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: </span><br><span class="line">          Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Sun(animation: _colorTween.animate(_animationController)),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就封装了自己的一个动画组件，另外，Flutter 内部为我们提供了多个已经封装好的动画组件，利用好这些组件可以大大地提高我们的开发效率：</p><ul><li>SlideTransition</li><li>ScaleTransition</li><li>RotationTransition</li><li>SizeTransition</li></ul><h2 id="3-隐式动画组件"><a href="#3-隐式动画组件" class="headerlink" title="3. 隐式动画组件"></a>3. 隐式动画组件</h2><p>利用动画组件我们已经可以方便地封装出一系列控件动画了，但是这种实现方式均需要我们自己提供 Animation 对象，然后通过提供的接口方法来启动我们的动画，控件的属性由 Animation 对象提供并在动画过程中改变而达到动画的效果。为了使动画使用起来更加方便，Flutter 帮助了开发者从另一个角度以更简单的方式实现了动画效果——隐式动画组件（ImplicitlyAnimatedWidget）。</p><p>通过隐式动画组件，我们不需要手动实现插值器、曲线等对象，开发者甚至也不需要使用 AnimationController 来启动动画，它的实现方式更贴近对组件本身的操作，我们可以直接通过 <code>setState()</code> 的方法改变隐式动画组件的属性值，其内部自行为我们实现动画过程的过渡效果，即隐藏了所有动画实现的细节。Flutter 内部为我们提供了多个实用的隐式动画组件，我们本节分别介绍 AnimatedContainer 和 AnimatedOpacity 这两个最常用的隐式动画组件。</p><h3 id="3-1-AnimatedContainer"><a href="#3-1-AnimatedContainer" class="headerlink" title="3.1 AnimatedContainer"></a>3.1 AnimatedContainer</h3><p>AnimatedContainer 是我们最常使用到的隐式动画组件之一，从名字可以看出这个控件是以动画形式而成的 Contianer 控件，它们都是页面中渲染一个空的容器并且使用方法也非常相似。我们可以用下面的方式使用 Contianer 控件：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> height = <span class="number">40.0</span>  </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">Container(</span><br><span class="line">    width: <span class="number">60.0</span>,</span><br><span class="line">    height: height,</span><br><span class="line">    color: Color(<span class="number">0xff14ff65</span>),</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure><p>上面的代码中，我们将 Container 的高度设置为 height 变量，即为 40.0，当我们使用一个 Button 按钮触发改变 height 值的事件并且重绘界面时，Container 的高度会随之改变：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onPressed: ()&#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    height = <span class="number">320.0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>但这种变化很明显仅是属性的改变并不是一个平滑的过渡动画，然而同样的事件发生在 AnimatedContainer 控件上，便会有一个渐变的效果：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimatedContainer(</span><br><span class="line">  duration: <span class="built_in">Duration</span>(seconds: <span class="number">5</span>),</span><br><span class="line">  width: <span class="number">60.0</span>,</span><br><span class="line">  height: height,</span><br><span class="line">  color: Color(<span class="number">0xff14ff65</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用 AnimatedContainer 后，我们再次触发 height 变量改变后，页面中的 AnimatedContainer 便会平滑的过渡到相应的高度，其 duration 属性用于设置动画过渡的时间，这里，我们设置为 5 秒??。</p><p>我们可以用相同的方式为 Container 的 Color、width 等各种属性设置动画，同时也可以通过为其设置 alignment 属性来设置其内部子控件的位置。</p><h3 id="3-2-AnimatedOpacity"><a href="#3-2-AnimatedOpacity" class="headerlink" title="3.2 AnimatedOpacity"></a>3.2 AnimatedOpacity</h3><p>在 Flutter 中，另一种常用的动画是控件透明度的过渡动画，其对应的隐式动画组件为 AnimatedOpacity。它的用法与 Opacity 相似，内部持有的 opacity 属性可以设置为 0.0～1.0 中的任意浮点数，分别对应完全透明与完全不透明，使用下面的方式，我们便可以设置了一个半透明的 Opacity 控件：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Opacity(</span><br><span class="line">    opacity: <span class="number">0.5</span>,</span><br><span class="line">    child: Text(<span class="string">"hello"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们以相同的方法使用 AnimatedOpacity：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> opacity = <span class="number">1.0</span>;</span><br><span class="line">...</span><br><span class="line">AnimatedOpacity(</span><br><span class="line">    opacity: opacity,</span><br><span class="line">    duration: <span class="built_in">Duration</span>(seconds: <span class="number">1</span>),</span><br><span class="line">    child: Text(<span class="string">"hello"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>它也接受 duration 属性来设置过渡时间，通过改变 opacity 变量的值可以实现透明度变化的动画效果：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">setState(() &#123;</span><br><span class="line">opacity = <span class="number">0.0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-3-隐式动画原理简析"><a href="#3-3-隐式动画原理简析" class="headerlink" title="3.3 隐式动画原理简析"></a>3.3 隐式动画原理简析</h3><p>我们已经在之前部分介绍了 Flutter 中的三棵重要的树及它们在组件渲染中的作用了。在元素树中，每个 Element 对象持有控件树中 Widget 组件的状态信息，这里我们将它称为 State 对象，Widget 刷新重建时，Element 会对比自己所对应 Widget 是否更新而做出相应屏幕渲染上的改变。</p><p>在各个隐式动画组件中，其动画信息便储存在 Element 所持有的 State 对象中，Widget 每次刷新都会引起 Element 对其重新引用，当对应的 Widget 类型改变则其 Element 会连带 State 对象自然而然的需要重新渲染，然而当 Widget 类型不变，则 Element 不需要重建，只需要改变 State 对象储存的动画信息即可。这样一种连续更新属性的过程便实现了更为我们所方便使用的隐式动画。</p><h3 id="3-4-实现自定义隐式动画组件"><a href="#3-4-实现自定义隐式动画组件" class="headerlink" title="3.4 实现自定义隐式动画组件"></a>3.4 实现自定义隐式动画组件</h3><p>实现自定义的隐式动画组件，我们需要使用到两个类：ImplicitlyAnimatedWidget 和 AnimatedWidgetBaseState。</p><p>ImplicitlyAnimatedWidget 是所有隐式动画组件的父类，继承自 StatefulWidget，并且仅需要接受动画曲线 curve 与动画过渡时长 duration 两个参数：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ImplicitlyAnimatedWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.curve = Curves.linear,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.duration</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在我们自定义的隐式动画组件可以扩充他的参数类型满足我们的需求。</p><p>AnimatedWidgetBaseState 即 ImplicitlyAnimatedWidget 这个有状态组件所对应的 State 对象类，我们自定义的隐式动画组件所对应的 State 也必须继承该类，其内部需要重写 <code>forEachTween</code> 方法。</p><p>下面就是我自己定义的隐式动画组件：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnimatedWidget</span> <span class="keyword">extends</span> <span class="title">ImplicitlyAnimatedWidget</span> </span>&#123;</span><br><span class="line">  MyAnimatedWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.param, <span class="comment">//导致动画的参数</span></span><br><span class="line">    Curve curve = Curves.linear,</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">Duration</span> duration,</span><br><span class="line">  &#125;) :<span class="keyword">super</span>(key: key, curve: curve, duration: duration);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> param;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyAnimatedWidgetState createState() =&gt; _MyAnimatedWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAnimatedWidgetState</span> <span class="keyword">extends</span> <span class="title">AnimatedWidgetBaseState</span>&lt;<span class="title">MyAnimatedWidget</span>&gt; </span>&#123;</span><br><span class="line">  Tween&lt;<span class="built_in">double</span>&gt; _param; <span class="comment">// State 内部保存的当前状态信息，类型为 Tween</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> forEachTween(TweenVisitor&lt;<span class="built_in">dynamic</span>&gt; visitor) &#123;</span><br><span class="line">    _param = visitor(_param, widget.param, (value) =&gt; Tween&lt;<span class="built_in">double</span>&gt;(begin: value));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//return a widget built on a parameter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我们在父类的基础之上拓展了 param 参数，它是我们在动画过程中需要关注的动画属性值。我们还需要重点关注 _MyAnimatedWidgetState 类中 <code>forEachTween</code> 方法，它是隐式动画实现的核心方法，其用于每次更新组件的动画属性，接受一个 <code>TweenVisitor</code> 对象 visitor 作为参数。visitor 同时接受是那个参数，第一个为一个插值器对象 <code>Tween&lt;T&gt;</code>，其是应用在属性中的插值器当前补间值，第二个参数为一个 <code>T</code> 类型的值，即新的目标属性值，第三个参数为一个回调函数，用于配置给定的 value 值作为新的插值器开始值。<code>TweenVisitor&lt;T&gt;</code> 函数返回一个 <code>Tween&lt;T&gt;</code> 对象，我们将其赋值给组件中当前的插值器对象作为下次调用 <code>forEachTween</code> 方法时的当前值。</p><p>按照以上原理，我们就完成自己的隐式动画组件了。</p><p>关注公众号「Meandni」，及时阅读最新技术动态。</p><p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文通过拆解 Flutter 中动画的实现方式以及原理来介绍动画实现的整个过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-动画四要素&quot;&gt;&lt;a href=&quot;#1-动画四要素&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
      <category term="Flutter" scheme="https://meandni.com/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="动画" scheme="https://meandni.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>Flutter原理：三棵重要的树(渲染过程、布局约束、应用视图的构建等)</title>
    <link href="https://meandni.com/2019/05/05/flutter-principle/"/>
    <id>https://meandni.com/2019/05/05/flutter-principle/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2020-10-18T07:44:42.918Z</updated>
    
    <content type="html"><![CDATA[<p>了解 HTML 的读者一定听说过 DOM 树这个概念，它由页面中每一个控件组成，这些控件所形成的一种天然的嵌套关系使其可以表示为 “树” 结构，我们也可以将这个概念应用在 Flutter 中，例如默认的计数器应用的结构如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-16abfeb58e1ee300.jpeg" alt=""></p><p>我们也可以看到上图中每个控件所形成的树结构中隐含了一些关系，例如在上图中，我们可以说 Text 组件是 Column 组件的子组件，Scaffold 是 AppBar 的父组件，这样的层级关系使得每个控件都清晰的连接到了一起，树结构由此而来（俄罗斯套娃）。</p><p>在 Flutter 中，Container、Text 等组件都属于 Widget，所以我们将这种树称为 Widget 树，也可以叫做控件树，它就表示了我们在 dart 代码中所写的控件的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-17154511dae84325.png" alt=""></p><p>然而，在 Flutter 体系结构中，真正做组件渲染在屏幕上这个任务的并非在 控件层（Widget）层，而是在渲染（Rendering）层，那么我们在代码中所写组件又是怎么通过渲染层显示的呢？Flutter 中又引入了 Element 树和 RenderingObject 树两棵树。</p><p>Element 是什么，我们可以把它称之为 Widget 另一种抽象。读者也可以把它看作一个更为实际控件，因为在我们的手机屏幕上显示的控件并非我们在代码中所写的 Widget，我们在代码中所使用的像 Container、Text 等这类组件和其属性只不过是我们想要构建的组件的配置信息，当我们第一次调用 <code>build()</code> 方法想要在屏幕上显示这些组件时，Flutter 会根据这些信息生成该 Widget 控件对应的 Element，同样地，Element 也会被放到相应的 Element 树当中。在 Flutter 中，一个 Widget 通过多次复用可以对应多个 Element 实例，Element 才是我们真正在屏幕上显示的元素。</p><blockquote><p>Element 与 Widget 另一个区别在于，Widget 天然是不可变的（immutable），它如要更新便需要重建，如果想要把可变状态与 Widget 关联起来，可以使用 StatefulWidget，StatefulWidget 通过使用StatefulWidget.createState 方法创建 State 对象，并将之扩充到 Element 以及合并到树中；</p></blockquote><p>这里，为了更为深刻的理解以上描述的含义，我们可以举一个更为形象的例子。Widget 作为大 Boss，他把近期的战略部署，即配置信息，写在纸上下发给经理人 Element，Element 看到详细的配置信息开始真正的开起活来了。我们还需要注意一点，大 Boss 随时会改变战略部署，然后不会在原有的纸上修改而是重新写下来，这时经理人为了减少工作量需要将新的计划与旧的计划比较来作出相应的更新措施。这也是 Flutter 框架层做的一大优化。下面又来了，Element 作为经理人也很体面，当然不会把活全干完，于是又找了一个 RenderObject 的员工来帮它做粗重的累活。</p><p>RenderObject 在 Flutter 当中做组件布局渲染的工作，其为了组件间的渲染搭配及布局约束也有对应的 RenderObject 树，我们也称之为渲染树。</p><p>熟悉了 Flutter 中的上述三颗树，相信读者会对组件的渲染过程有了一个清晰的认识，这对我们之后学习常用组件有很大的帮助，我们需要用不同的眼光去看待我们所建立的布局和控件，之后我们也会更加深入的去理解其中更不为人知的奥秘。</p><h2 id="组件渲染过程简述"><a href="#组件渲染过程简述" class="headerlink" title="组件渲染过程简述"></a>组件渲染过程简述</h2><p>从上文中，我们知道控件树中的每个控件都会实现一个 RenderObject 对象做渲染任务，并将所有的RenderObject 组成渲染树。Flutter 渲染组件的过程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-render-pipeline.png" alt=""></p><p>Flutter 的渲染过程由用户的输入开始，当接受到用户输入的信号时，就会触发动画的进度更新，例如我们第一次渲染时的启动动画，或者我们在滚动手机屏幕时单个列表项复用时的移动动画。之后便需要开始视图数据的构建（build），这一步中 Flutter 创建了前文所描述的三棵视图树。</p><p>在这之后，视图才会进行布局（layout），计算各个部分的大小，然后进行绘制（paint），生成每个视图的视觉数据，这部分的任务主要就是由 RenderObject 所做。这里，Flutter 中的布局过程可用下图表示，在上述构建完成渲染树后，父渲染对象会将布局约束信息向下传递，子渲染对象根据自己的渲染情况返回 Size，Size 数据会向上传递，最终父渲染对象完成布局过程。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-1652326d2270f049.png" alt=""></p><p>最后一步进行“光栅化”（Rasterize），前一步得到合成的视图数据其实还是一份矢量描述数据，光栅化帮助把这份数据真正地生成一个一个的像素填充数据。在 Flutter 中，光栅化这个步骤被放在了 Engine 层中。</p><p>在日常开发学习中，我们只需要在代码层配置好我们的 Widget 树，了解各种 Widget 特性及使用方法，其余的工作都可以交给我们的框架层去实现。</p><h2 id="元素树详解"><a href="#元素树详解" class="headerlink" title="元素树详解"></a>元素树详解</h2><p>我们已经知道了各类控件的作用及其使用方法，这些 Widget 被我们开发人员配置了多个属性来定义它的展现形式，例如配置 Text 组件需要显示的字符串，配置输入框组件需要显示的内容。我们 Element 树会记录这些配置信息。熟悉 React 的读者可能了解过其中的 “虚拟 DOM” 这个概念，上述 Flutter 这种操作也正体现了这一概念。Widget 是不可变，它的改变就意味着要重建，而其重建也非常频繁，如果我们将更多的任务都交给它将会对性能造成很大的损伤，因此我们把 Widget 组件当作一个虚拟的组件树，而真正被渲染在屏幕上的其实是 Elememt 这棵树，它持有其对应 Widget 的引用，如果他对应的 Widget 发生改变，它就会被标记为 dirty Element，于是下一次更新视图时根据这个状态只更新被修改的内容，从而达到提升element-3845797性能的效果。</p><p>每次，当控件挂载到控件树上时，Flutter 调用其 createElement() 方法，创建其对应的 Element。Flutter 再将这个 Element 放到元素树上，并持有创建它控件的引用，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-element-3845797.svg" alt=""></p><p>控件会有它的子树：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-element2.svg" alt=""></p><p>子控件也会创建相应 Element 被放在元素树上：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-element3.svg" alt=""></p><h3 id="Element-中的状态"><a href="#Element-中的状态" class="headerlink" title="Element 中的状态"></a>Element 中的状态</h3><p>我们上文提到了 Widget 的不可变性，相应的 Element 就有其可变性，正如我们前文所说的它被标记为 dirty Element 便是作为需要更新的状态，另外一个我们需要格外注意的是，有状态组件（statefulWidget）对应的 State 对象其实也被 Element 所管理，如下图所示。</p><p>Flutter 中的 Widget 一直在重建，每次重建之后，Element 都会采用相应的措施来确定是否我对应的新控件跟之前引用旧控件是否有所改变，如果没改变则只需要做更新操作，如果前后不同则会重创建。那么，Element 根据什么来确定控件是否改变呢？它会比较 Widget 以下两个属性：</p><ul><li>组件类型</li><li>Widget 的 Key （如果有）</li></ul><p>组件类型即前后控件的是否是同一个类所创建的，Key 即为每个控件的唯一标识。</p><h2 id="渲染树详解"><a href="#渲染树详解" class="headerlink" title="渲染树详解"></a>渲染树详解</h2><p>我们已经大致知道 Flutter 中的三棵重要的树及 Element 树的工作原理，其中第三棵渲染树的任务就是做组件的具体的布局渲染工作。</p><p>渲染树上每个节点都是一个继承自 RenderObject 类的对象，其由 Element 中的 renderObject 或  RenderObjectWidget 中的 createRenderObject 方法生成，该对象内部提供多个属性及方法来帮助框架层中的组件如何布局渲染。</p><blockquote><p>我们在本章之前已经介绍了 StatelessWidget 和 StatefulWidget 两种直接继承自 Widget 的类，在 Flutter 中，还有另一个类 RenderObjectWidget 也同样直接继承自 Widget，它没有 build 方法，可通过 createRenderObject 直接创建 RenderObject 对象放入渲染树中。Column 和 Row 等控件都间接继承自RenderObjectWidget。 </p></blockquote><p>主要属性和方法如下：</p><ul><li>constraints 对象，从其父级传递给它的约束</li><li>parentData 对象，其父对象附加有用的信息。</li><li>performLayout 方法，计算此渲染对象的布局。</li><li>paint 方法，绘制该组件及其子组件。</li></ul><p>RenderObject 作为一个抽象类。每个节点需要实现它才能进行实际渲染。扩展 RenderOject 的两个最重要的类是RenderBox 和 RenderSliver。这两个类分别是应用了 Box 协议和 Sliver 协议这两种布局协议的所有渲染对象的父类，其还扩展了数十个和其他几个处理特定场景的类，并实现了渲染过程的细节，如 RenderShiftedBox 和 RenderStack 等等。</p><h3 id="布局约束"><a href="#布局约束" class="headerlink" title="布局约束"></a>布局约束</h3><p>在上面，我们介绍组件渲染流程时，我们了解到了 Flutter 中的控件在屏幕上绘制渲染之前需要先进行布局（layout）操作。其具体可分为两个线性过程：从顶部向下传递约束，从底部向上传递布局信息，其过程可用下图表示。</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-16a866a9a0b9cb4e.png" alt=""></p><p>第一个线性过程用于传递布局约束。父节点给每个子节点传递约束，这些约束是每个子节点在布局阶段必须要遵守的规则。就好像父母告诉自己的孩子 ：“你必须遵守学校的规定，才可以做其他的事”。常见的约束包括规定子节点最大最小宽度或者子节点最大最小的高度。这种约束会向下延伸，子组件也会产生约束传递给自己的孩子，一直到叶子结点。</p><p>第二的线性过程用来传递具体的布局信息。子节点接受到来自父节点的约束后，会依据它产生自己具体的布局信息，如父节点规定我的最小宽度是 500 的单位像素，子节点按照这个规则可能定义自己的宽度为 500 个像素，或者低于 500 像素的任何一个值。这样，确定好自己的布局信息之后，将这些信息告诉父节点。父节点也会继续此操作向上传递一直到最顶部。</p><p>下面我们具体介绍有哪些具体的布局约束可在树中传递。Flutter 中有两种主要的布局协议：Box 盒子协议和 Sliver 滑动协议。这里我们先以盒子协议为例展开具体的介绍。</p><p>在盒子协议中，父节点传递给其子节点的约束为 BoxConstraints。该约束规定了允许每个子节点的最大和最小宽度和高度。如下图，父节点传入 Min Width 为 150，Max Width 为 300 的 BoxConstraints：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-16a866ad567eb16f.png" alt=""></p><p>当子节点接受到该约束，便可以取得上图中绿色范围内的值，即宽度在 150 到 300 之间，高度大于 100，当取得具体的值之后再将取得具体的大小的值上传给父节点，从而达到父子的布局通信。</p><h3 id="自定义一个-Center-控件"><a href="#自定义一个-Center-控件" class="headerlink" title="自定义一个 Center 控件"></a>自定义一个 Center 控件</h3><p>之后更新，大家也可以看各组件的源码探究其如何应用上面提到的原理。</p><p>—-2019.07.03 更新</p><p>现在，我们可以应用前文中提到的布局约束与渲染树相关的概念自己定义一个类似居中布局的组件 RenderObject 对象渲染在屏幕上。</p><p>所以我们称自己自定义组件为 CustomCenter：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(</span><br><span class="line">    home: Scaffold(</span><br><span class="line">      body: Container(</span><br><span class="line">        color: Colors.blue,</span><br><span class="line">        constraints: BoxConstraints(</span><br><span class="line">            maxWidth: <span class="built_in">double</span>.infinity,</span><br><span class="line">            minWidth: <span class="number">100.0</span>,</span><br><span class="line">            maxHeight: <span class="built_in">double</span>.infinity,</span><br><span class="line">            minHeight: <span class="number">100.0</span>),</span><br><span class="line">        child: CustomCenter(</span><br><span class="line">          child: Container(</span><br><span class="line">            color: Colors.red,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来实现我们的 CustomCenter：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCenter</span> <span class="keyword">extends</span> <span class="title">SingleChildRenderObjectWidget</span> </span>&#123;</span><br><span class="line">  Stingy(&#123;Widget child&#125;) : <span class="keyword">super</span>(child: child);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  RenderObject createRenderObject(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement createRenderObject</span></span><br><span class="line">    <span class="keyword">return</span> RenderCustomCenter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CustomCenter</code> 继承了 <code>SingleChildRenderObjectWidget</code>，表明这个 Widget 只能有一个子控件， 其中，<code>createRenderObject(...)</code> 方法用于真正创建并返回我们的 <code>RenderObject</code> 对象实例， 我们的 RenderObject 为 <code>RenderCustomCenter</code>，代码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderCustomCenter</span> <span class="keyword">extends</span> <span class="title">RenderShiftedBox</span> </span>&#123;</span><br><span class="line">  RenderStingy() : <span class="keyword">super</span>(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写绘制方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement paint</span></span><br><span class="line">    <span class="keyword">super</span>.paint(context, offset);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写布局方法</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">    <span class="comment">// 布局子元素并向下传递布局约束</span></span><br><span class="line">    child.layout(</span><br><span class="line">        BoxConstraints(</span><br><span class="line">            minHeight: <span class="number">0.0</span>,</span><br><span class="line">            maxHeight: constraints.minHeight,</span><br><span class="line">            minWidth: <span class="number">0.0</span>,</span><br><span class="line">            maxWidth: constraints.minWidth),</span><br><span class="line">        parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'constraints: <span class="subst">$constraints</span>'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定子元素的偏移位置</span></span><br><span class="line">    <span class="keyword">final</span> BoxParentData childParentData = child.parentData;</span><br><span class="line">    childParentData.offset = Offset((constraints.maxWidth - child.size.width)/<span class="number">2</span>,</span><br><span class="line">        (constraints.maxHeight - child.size.height)/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'childParentData: <span class="subst">$childParentData</span>'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义自己（CustomCenter）的大小，这里选择约束对象的最大值</span></span><br><span class="line">    size = Size(constraints.maxWidth, constraints.maxHeight);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'size: <span class="subst">$size</span>'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RenderCustomCenter</code> 继承自 <code>RenderShiftedBox</code>，该类是继承自 <code>RenderBox</code>。<code>RenderShiftedBox</code> 满足盒子协议，并且提供了 <code>performLayout()</code> 方法的实现。我们需要在 <code>performLayout()</code> 方法中布局我们的子元素。??</p><p>我们在使用 <code>child.layout(...)</code> 方法布局 <em>child</em> 的时候传递了两个参数，第一个为 <em>child</em> 的布局约束，而另外一个参数是 <code>parentUserSize</code>， 该参数如果设置为 <code>false</code>，则意味着 <em>parent</em> 不关心 <em>child</em> 选择的大小，这对布局优化比较有用；因为如果 <em>child</em> 改变了自己的大小，<em>parent</em> 就不必重新 <code>layout</code> 了。但是在我们的例子中，我们的需要把 <em>child</em> 放置在 <em>parent</em> 的中心，就是 <em>child</em> 的<strong>大小（Size）一旦改变，则其对应的偏移量（Offset）</strong> 也会改变，于是 <em>parent</em> 需要重新布局，所以我们这里传递了一个 <code>true</code>。</p><p>当 <code>child.layout(...)</code> 完成了以后，<em>child</em> 就确定了自己的 <em>Layout Details</em>。然后我们就还可以为其设置偏移量来将它放置到我们想放的位置。在我们的例子中为 <strong>居中</strong>。</p><p>最后，和 <em>child</em> 根据 <em>parent</em> 传递过来的约束选择了一个尺寸一样，我们也需要为 <strong>CustomCenter</strong> 选择一个尺寸。</p><p>运行效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-11-16bb5b297356deab.png" alt=""></p><h2 id="应用视图的构建"><a href="#应用视图的构建" class="headerlink" title="应用视图的构建"></a>应用视图的构建</h2><p>Flutter App 入口的部分发生于如下代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里的 MyApp是一个 Widget</span><br><span class="line">void main() &#x3D;&gt; runApp(new MyApp());</span><br></pre></td></tr></table></figure><p><code>runApp</code>函数接受一个 Widget类型的对象作为参数，也就是说在 Flutter的概念中，只存在 View，而其他的任何逻辑都只为 View的数据、状态改变服务，不存在 ViewController(或者叫 Activity）。<br>接下来看 <code>runApp</code>做了什么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..attachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, RendererBinding, WidgetsBinding &#123;</span><br><span class="line">  static WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    if (WidgetsBinding.instance &#x3D;&#x3D; null)</span><br><span class="line">      new WidgetsFlutterBinding();</span><br><span class="line">    return WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>runApp</code> 中，传入的 widget 被挂载到根 widget 上。这个 <code>WidgetsFlutterBinding</code> 其实是一个单例，通过 mixin 来使用框架中实现的其他 binding 的 Service，比如手势、基础服务、队列、绘图等等。然后会调用 <code>scheduleWarmUpFrame</code> 这个方法，从这个方法注释可知，调用这个方法会主动构建视图数据。这样做的好处是因为 Flutter 依赖 Dart 的 MicroTask 来进行帧数据构建任务的 schedule，这里通过主动调用进行整个周期的 “热身”，这样最近的下次 VSync 信号同步时就有视图数据可提供，而不用等到 MicroTask 的 next Tick。</p><p>然后我们再来看 <code>attachRootWidget</code> 这个函数干了什么：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    _renderViewElement &#x3D; new RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: &#39;[root]&#39;,</span><br><span class="line">      child: rootWidget</span><br><span class="line">    ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>attachRootWidget</code> 把 widget交给了 <code>RenderObjectToWidgetAdapter</code>这座桥梁，通过这座桥梁，Element 被创建，并且同时能持有 Widget 和 RenderObject的引用。然后我们从上文就知道后面发生的就是第一次的视图数据构建了。</p><p><strong>从这一部分能印证了：Flutter应用通过 Widget、Element、RenderObject 三种树结构来维护整个应用的视图数据。</strong></p><p>关注公众号「Meandni」，及时阅读最新技术动态。</p><p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;了解 HTML 的读者一定听说过 DOM 树这个概念，它由页面中每一个控件组成，这些控件所形成的一种天然的嵌套关系使其可以表示为 “树” 结构，我们也可以将这个概念应用在 Flutter 中，例如默认的计数器应用的结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:
      
    
    </summary>
    
      <category term="Flutter" scheme="https://meandni.com/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>2019第二次阅读记录</title>
    <link href="https://meandni.com/2019/03/12/reading-record2/"/>
    <id>https://meandni.com/2019/03/12/reading-record2/</id>
    <published>2019-03-12T06:53:59.000Z</published>
    <updated>2020-10-10T18:30:32.536Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/fb59c770160c" target="_blank" rel="noopener">强缓存和协商缓存</a></p><p><a href="https://juejin.im/post/5a6c87c46fb9a01ca560b4d7" target="_blank" rel="noopener">缓存详解</a></p><p><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" target="_blank" rel="noopener">轻松理解JS函数节流和函数防抖</a></p><p><a href="https://juejin.im/post/5c80e846518825355a71d154" target="_blank" rel="noopener">Flutter 的渲染逻辑及和 Native 通信</a></p><p><a href="https://mp.weixin.qq.com/s/CQQXD0TrlbaNWjoClIcDtw" target="_blank" rel="noopener">Flutter 原理简解</a></p><p><a href="http://www.cnblogs.com/shanyou/p/4085802.html" target="_blank" rel="noopener">TCP/IP, WebSocket 和 MQTT</a></p><p><a href="https://blog.csdn.net/jamesliulyc/article/details/6711828" target="_blank" rel="noopener">android开发时，finish()跟System.exit(0)的区别(转)</a></p><hr><p><a href="https://juejin.im/post/5b1cebece51d4506ae71addf" target="_blank" rel="noopener">Ajax原理一篇就够了</a></p><p><a href="https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html" target="_blank" rel="noopener">【原创】说说JSON和JSONP，也许你会豁然开朗，含jQuery用例</a></p><p><a href="https://zhenhua-lee.github.io/react/history.html" target="_blank" rel="noopener">react-router的实现原理</a></p><p><a href="http://blog.poetries.top/2018/12/20/react-router-anaylse/" target="_blank" rel="noopener">React Router原理</a>🌟</p><p><a href="https://juejin.im/post/5b50b0dd6fb9a04f932ff53f" target="_blank" rel="noopener">面试官所认为的单例模式</a></p><hr><p><a href="https://www.toutiao.com/i6545790064104833539/" target="_blank" rel="noopener">为什么HashMap非线程安全</a></p><p><a href="https://juejin.im/post/5c6fbf54f265da2db718216a" target="_blank" rel="noopener">TCP和UDP比较</a></p><p> <a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" target="_blank" rel="noopener">稳定排序和不稳定排序</a></p><p><a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" target="_blank" rel="noopener">稳定排序和不稳定排序</a></p><p><a href="https://juejin.im/entry/58371f13a22b9d006882902d" target="_blank" rel="noopener">面试旧敌之红黑树（直白介绍深入理解）</a></p><p><a href="https://blog.csdn.net/sinat_35297665/article/details/80979181" target="_blank" rel="noopener">TCP第四次挥手为什么要等待2MSL</a></p><p><a href="https://juejin.im/post/5ad43b86f265da239236cedc" target="_blank" rel="noopener">Web安全防范——-防止重放攻击</a></p><p><a href="https://blog.csdn.net/u012758088/article/details/76020966" target="_blank" rel="noopener">网络编程—链路层报文、网络层IP报文、传输层TCP报文</a></p><hr><p><a href="https://juejin.im/post/5c98a834f265da6111675253" target="_blank" rel="noopener">Flutter 实现原理及在马蜂窝的跨平台开发实践</a></p><hr><p><a href="https://www.jianshu.com/p/b0b6b88fe9fe" target="_blank" rel="noopener">1- Https流程和原理</a></p><p><a href="https://www.cnblogs.com/liyuhui-Z/p/7844880.html" target="_blank" rel="noopener">HTTPS 建立连接的详细过程</a></p><p><a href="https://www.cnblogs.com/chentingk/p/6497107.html" target="_blank" rel="noopener">生产者消费者模式-Java实现</a></p><p><a href="https://www.cnblogs.com/gavinsp/p/5513536.html" target="_blank" rel="noopener">数据库索引详解</a></p><p><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></p><p><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></p><p><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></p><hr><p><a href="http://web.jobbole.com/85541/" target="_blank" rel="noopener">谈谈HTTP协议中的短轮询、长轮询、长连接和短连接</a></p><p><a href="https://www.cnblogs.com/lizhengxian/p/5075635.html" target="_blank" rel="noopener">Android进程间通信的几种方式</a></p><p><a href="https://blog.csdn.net/wh_sjc/article/details/70283843" target="_blank" rel="noopener">进程间的五种通信方式介绍</a></p><p><a href="https://www.cnblogs.com/withyou/p/4789170.html" target="_blank" rel="noopener">面向对象之多态理解，多态的作用与好处</a></p><p><a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">算法导论—最小生成树（Kruskal和Prim算法）</a></p><p><a href="https://juejin.im/entry/584abdff61ff4b0058d50547" target="_blank" rel="noopener">面试旧敌之 Java 泛型 ：主要概念及特点</a></p><hr><p><a href="https://blog.csdn.net/hrn1216/article/details/51465270" target="_blank" rel="noopener">最小堆 构建、插入、删除的过程图解</a></p><p><a href="https://www.cnblogs.com/ygj0930/p/5862684.html" target="_blank" rel="noopener">【数据库】数据库的并发问题与锁机制</a></p><p><a href="https://www.cnblogs.com/lxmhhy/p/6041001.html" target="_blank" rel="noopener">进程和线程、协程的区别</a></p><p><a href="https://juejin.im/post/5caf0f89f265da038145c66e" target="_blank" rel="noopener">渣渣二本的辛酸面试之路</a></p><p><a href="https://blog.csdn.net/zbuger/article/details/50827762" target="_blank" rel="noopener">java static锁和非static锁区别</a></p><p><a href="https://jishusuishouji.github.io/2017/05/10/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">一个Java类被JVM虚拟机加载的详细流程</a></p><hr><p><a href="https://blog.csdn.net/adobesolo/article/details/76221597" target="_blank" rel="noopener">Java泛型原理详解</a></p><p><a href="https://www.cnkirito.moe/tcp-talk/" target="_blank" rel="noopener">聊聊 TCP 长连接和心跳那些事</a></p><p><a href="https://juejin.im/post/5b82c02df265da436152f5ad" target="_blank" rel="noopener">理解Java的强引用、软引用、弱引用和虚引用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/fb59c770160c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;强缓存和协商缓存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5a6c8
      
    
    </summary>
    
      <category term="整理" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/"/>
    
      <category term="阅读" scheme="https://meandni.com/categories/%E6%95%B4%E7%90%86/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="阅读" scheme="https://meandni.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Flutter进阶：路由、路由栈详解及案例分析</title>
    <link href="https://meandni.com/2019/03/04/flutter-route/"/>
    <id>https://meandni.com/2019/03/04/flutter-route/</id>
    <published>2019-03-04T12:18:54.000Z</published>
    <updated>2020-10-18T07:44:36.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由初体验"><a href="#路由初体验" class="headerlink" title="路由初体验"></a>路由初体验</h1><p>路由（Routes）是什么？路由是屏幕或应用程序页面的抽象。</p><p>Flutter 使我们能够优雅地管理路由主要依赖的是 Navigator（导航器）类。这是一个用于管理一组具有某种进出规则的页面的 Widget，也就是说用它我们能够实现各个页面间有规律的切换。而这里的规则便是在其内部维护的一个“ 路由栈”。</p><p>学习 Android 的同学知道 Activity 的启动模式可以实现各种业务需求，iOS 中也有嵌套路由的功能，Flutter 作为最有潜力的跨平台框架当然要吸取众家之精华，它当然完全有能力实现原生的各种效果！</p><p>我们先尝试实现一个小的功能。</p><h2 id="组件路由"><a href="#组件路由" class="headerlink" title="组件路由"></a>组件路由</h2><p>当我们第一次打开应用程序，出现在眼前的便是路由栈中的第一个也是最底部实例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(home: Screen1()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要在堆栈上推送新的实例，我们可以调用导航器 <code>Navigator.push</code> ，传入当前 context 并且使用构建器函数创建 MaterialPageRoute 实例，该函数可以创建您想要在屏幕上显示的内容。 例如：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">   onPressed:()&#123;</span><br><span class="line">   Navigator.push(context, MaterialPageRoute&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> Scaffold(</span><br><span class="line">          appBar: AppBar(title: Text(<span class="string">'My Page'</span>)),</span><br><span class="line">          body: Center(</span><br><span class="line">            child: FlatButton(</span><br><span class="line">              child: Text(<span class="string">'POP'</span>),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Navigator.pop(context);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    ));</span><br><span class="line">   &#125;,</span><br><span class="line">   child: <span class="keyword">new</span> Text(<span class="string">"Push to Screen 2"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>点击执行上方操作，我们将成功打开第二个页面。</p><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>在一般应用中，我们用的最多的还是命名路由，它是将应用中需要访问的每个页面命名为不重复的字符串，我们便可以通过这个字符串来将该页面实例推进路由。</p><blockquote><p>例如，’/ home’ 表示 HomeScreen， ‘/ login’ 表示 LoginScreen。 ‘/‘ 表示主页面。 这里的命名规范与 REST API 开发中的路由类似。 所以 ‘/‘ 通常表示的是我们的根页面。</p></blockquote><p>请看下方案例：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MaterialApp(</span><br><span class="line">  home: <span class="keyword">new</span> Screen1(),</span><br><span class="line">  routes: &lt;<span class="built_in">String</span>, WidgetBuilder&gt; &#123;</span><br><span class="line">    <span class="string">'/screen1'</span>: (BuildContext context) =&gt; <span class="keyword">new</span> Screen1(),</span><br><span class="line">    <span class="string">'/screen2'</span> : (BuildContext context) =&gt; <span class="keyword">new</span> Screen2(),</span><br><span class="line">    <span class="string">'/screen3'</span> : (BuildContext context) =&gt; <span class="keyword">new</span> Screen3(),</span><br><span class="line">    <span class="string">'/screen4'</span> : (BuildContext context) =&gt; <span class="keyword">new</span> Screen4()</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><em>Screen1()、Screen2()等是每个页面的类名。</em></p><p>我们同样可以实现前面的功能：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">   onPressed:()&#123;</span><br><span class="line">     Navigator.of(context).pushNamed(<span class="string">'/screen2'</span>);</span><br><span class="line">   &#125;,</span><br><span class="line">   child: <span class="keyword">new</span> Text(<span class="string">"Push to Screen 2"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">   onPressed:()&#123;</span><br><span class="line">     Navigator.pushNamed(context, <span class="string">"/screen2"</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   child: <span class="keyword">new</span> Text(<span class="string">"Push to Screen 2"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>同样可以实现上方效果。</p><h2 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h2><p>实现上面两种方法，此时，路由栈中的情况如下：</p><p><img src="/images/route1.png" alt="1_RKtC1MKJbjSfMjUlR-2K7g"></p><p>现在，当我们想要回退的到主屏幕时，我们则需要使用 pop 方法从 Navigator 的堆栈中弹出 Routes。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pop();</span><br></pre></td></tr></table></figure><p><img src="/images/route2.png" alt="1_hq7qfAer0wCCSyIBKr7sfg"></p><p>使用 Scaffold 时，通常不需要显式弹出路径，因为 Scaffold 会自动向其 AppBar 添加一个“后退”按钮，按下时会调用 <code>Navigator.pop()</code>。 </p><p>在 Android 中，按下设备后退按钮也会这样做。但是，我们也有可能需要将此方法用于其他组件，例如在用户单击“取消”按钮时弹出 AlertDialog。</p><blockquote><p><strong>这里要注意的是：</strong>切勿用 push 代替 pop，有同学说我在 Screen2 push Screen1 部照样能实现这个功能吗？其实不然啊，请看下图：</p></blockquote><p><img src="/images/route3.png" alt="1_Xsyo5c8s1JwO6f2OQ1nNEg"></p><blockquote><p>所以 <strong>push 只用于向栈中添加实例，pop 弹出实例！（特殊需求除外）</strong></p></blockquote><h1 id="详解路由栈"><a href="#详解路由栈" class="headerlink" title="详解路由栈"></a>详解路由栈</h1><p>前面，我们已经知道如何简单在路由栈中 push、pop 实例，然而，当遇到一些特殊的情况，这显然不能满足需求。学习 Android 的同学知道 Activity 的各种启动模式可以完成相应需求，Flutter 当然也有类似的可以解决各种业务需求的实现方式！</p><p>请看下面使用方法与案例分析。</p><h2 id="pushReplacementNamed-与-popAndPushNamed"><a href="#pushReplacementNamed-与-popAndPushNamed" class="headerlink" title="pushReplacementNamed 与 popAndPushNamed"></a>pushReplacementNamed 与 popAndPushNamed</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.pushReplacementNamed(context, <span class="string">"/screen4"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">"pushReplacementNamed"</span>),</span><br><span class="line">),</span><br><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.popAndPushNamed(context, <span class="string">"/screen4"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">"popAndPushNamed"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><em>我们在 Screen3 页面使用 <code>pushReplacementNamed</code> 与 <code>popAndPushNamed</code> 方法 push 了 Screen4。</em></p><p>此时路由栈情况如下：</p><p><img src="/images/route4.png" alt="1_cr77kgOgz7KRjwvMAVXoAg"></p><p><strong>Screen4 代替了 Screen</strong>。</p><p><code>pushReplacementNamed</code> 与 <code>popAndPushNamed</code> 的区别在于：  <code>popAndPushNamed</code>  能够执行 Screen2 弹出的动画与 Screen3 推进的动画而 <code>pushReplacementNamed</code> 仅显示 Screen3 推进的动画。</p><p><img src="/images/route10.gif" alt="1_cr77kgOgz7KRjwvMAVXoAg"></p><p>案例：</p><blockquote><p><strong>pushReplacementNamed</strong>：当用户成功登录并且现在在 <code>HomeScreen</code> 上时，您不希望用户还能够返回到 <code>LoginScreen</code>。因此，登录应完全由首页替换。另一个例子是从 <code>SplashScreen</code> 转到 <code>HomeScreen</code>。 它应该只显示一次，用户不能再从 <code>HomeScreen</code> 返回它。 在这种情况下，由于我们要进入一个全新的屏幕，我们可能需要借助此方法。</p><p><strong>popAndPushNamed</strong>：假设您正在有一个 <code>Shopping</code> 应用程序，该应用程序在 <code>ProductsListScreen</code> 中显示产品列表，用户可以在 <code>FiltersScreen</code> 中应用过滤商品。 当用户单击“应用筛选”按钮时，应弹出 <code>FiltersScreen</code> 并使用新的过滤器值推回到 <code>ProductsListScreen</code>。 这里 <code>popAndPushNamed</code> 显然更为合适。</p></blockquote><h2 id="pushNamedAndRemoveUntil"><a href="#pushNamedAndRemoveUntil" class="headerlink" title="pushNamedAndRemoveUntil"></a>pushNamedAndRemoveUntil</h2><blockquote><p>用户已经登陆进入 <code>HomeScreen</code> ，然后经过一系列操作回到配合只界面想要退出登录，你不能够直接 Push 进入 <code>LoginScreen</code> 吧？<strong>你需要将之前路由中的实例全部删除是的用户不会在回到先前的路由中。</strong></p></blockquote><p>pushNamedAndRemoveUntil 可实现该功能：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pushNamedAndRemoveUntil(<span class="string">'/screen4'</span>, (Route&lt;<span class="built_in">dynamic</span>&gt; route) =&gt; <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>这里的 <code>(Route&lt;dynamic&gt; route) =&gt; false</code> 能够确保删除先前所有实例。</p><p><img src="/images/route5.png" alt="Logging out removes all routes and takes user back to LoginScreen"></p><p>现在又有一个需求：我们不希望删除先前所有实例，<strong>我们只要求删除指定个数的实例</strong>。</p><blockquote><p>我们有一个需要付款交易的购物应用。在应用程序中，一旦用户完成了支付交易，就应该从堆栈中删除所有与交易或购物车相关的页面，并且用户应该被带到 <code>PaymentConfirmationScreen</code> ,单击后退按钮应该只将它们带回到 <code>ProductsListScreen</code> 或 <code>HomeScreen</code>：</p></blockquote><p><img src="/images/route6.png" alt="1_aaZxoLUbKdFPgiIkBAmw7w"></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pushNamedAndRemoveUntil(<span class="string">'/screen4'</span>, ModalRoute.withName(<span class="string">'/screen1'</span>));</span><br></pre></td></tr></table></figure><p>通过代码，我们推送 <code>Screen4</code> 并删除所有路由，直到 <code>Screen1</code>：</p><p><img src="/images/route7.png" alt="1_D81iZF-BikxXJHak7_NkhA"></p><h2 id="popUntil"><a href="#popUntil" class="headerlink" title="popUntil"></a>popUntil</h2><p>想象一下，我们在应用程序中要填写一系列信息，表单分布在多个页面中。假设需要填写三个页面的表单一步接着一步。  然而，在表单的第 3 部分，用户取消了填写表单。 用户单击取消并且应弹出所有之前与表单相关的页面，并且应该将用户带回 <code>HomeScreen</code> 或者 <code>DashboardScreen</code>，这种情况下数据属于数据无效！ 我们不会在这里推新任何新东西，只是回到以前的路由栈中。</p><p><img src="/images/route8.png" alt="1_qV7mF0Kow2zch-fjksmA_Q"></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.popUntil(context, ModalRoute.withName(<span class="string">'/screen2'</span>));</span><br></pre></td></tr></table></figure><h2 id="Popup-routes（弹出路由）"><a href="#Popup-routes（弹出路由）" class="headerlink" title="Popup routes（弹出路由）"></a>Popup routes（弹出路由）</h2><p>路由不一定要遮挡整个屏幕。 <a href="https://docs.flutter.io/flutter/widgets/PopupRoute-class.html" target="_blank" rel="noopener">PopupRoute</a>s 使用 <a href="https://docs.flutter.io/flutter/widgets/ModalRoute/barrierColor.html" target="_blank" rel="noopener">ModalRoute.barrierColor</a>  覆盖屏幕，<a href="https://docs.flutter.io/flutter/widgets/ModalRoute/barrierColor.html" target="_blank" rel="noopener">ModalRoute.barrierColor</a> 只能部分不透明以允许当前屏幕显示。 弹出路由是“模态”的，因为它们阻止了对下面其他组件的输入。</p><p>有一些方法可以创建和显示这类弹出路由。 例如：showDialog，showMenu 和 showModalBottomSheet。 如上所述，这些函数返回其推送路由的 Future（异步数据，参考下面的数据部分）。 执行可以等待返回的值在弹出路由时执行操作。</p><p>还有一些组件可以创建弹出路由，如 PopupMenuButton 和 DropdownButton。 这些组件创建 PopupRoute 的内部子类，并使用 Navigator 的 push 和 pop 方法来显示和关闭它们。</p><h2 id="自定义路由"><a href="#自定义路由" class="headerlink" title="自定义路由"></a>自定义路由</h2><p>您可以创建自己的一个窗口z组件库路由类（如 PopupRoute，ModalRoute 或 PageRoute）的子类，以控制用于显示路径的动画过渡，路径的模态屏障的颜色和行为以及路径的其他各个特性。</p><p>PageRouteBuilder 类可以根据回调定义自定义路由。 下面是一个在路由出现或消失时旋转并淡化其子节点的示例。 此路由不会遮挡整个屏幕，因为它指定了opaque：false，就像弹出路由一样。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(context, PageRouteBuilder(</span><br><span class="line">  opaque: <span class="keyword">false</span>,</span><br><span class="line">  pageBuilder: (BuildContext context, _, __) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">'My PageRoute'</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  transitionsBuilder: (___, Animation&lt;<span class="built_in">double</span>&gt; animation, ____, Widget child) &#123;</span><br><span class="line">    <span class="keyword">return</span> FadeTransition(</span><br><span class="line">      opacity: animation,</span><br><span class="line">      child: RotationTransition(</span><br><span class="line">        turns: Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0.5</span>, end: <span class="number">1.0</span>).animate(animation),</span><br><span class="line">        child: child,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p><img src="/images/route9.gif" alt="ezgif-3-14c32a6d8764"></p><p>路由两部分构成，“pageBuilder”和“transitionsBuilder”。 该页面成为传递给 buildTransitions 方法的子代的后代。 通常，页面只构建一次，因为它不依赖于其动画参数（在此示例中以_和__表示）。 过渡是建立在每个帧的持续时间。</p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>一个应用程序可以使用多个路由导航器。将一个导航器嵌套在另一个导航器下方可用于创建“内部旅程”，例如选项卡式导航，用户注册，商店结帐或代表整个应用程序子部分的其他独立个体。</p><p>iOS应用程序的标准做法是使用选项卡式导航，其中每个选项卡都维护自己的导航历史记录。因此，每个选项卡都有自己的导航器，创建了一种“并行导航”。</p><p>除了选项卡的并行导航之外，还可以启动完全覆盖选项卡的全屏页面。例如：入职流程或警报对话框。因此，必须存在位于选项卡导航上方的“根”导航器。因此，每个选项卡的 Navigators 实际上都是嵌套在一个根导航器下面的 Navigators。</p><p>用于选项卡式导航的嵌套导航器位于 WidgetApp 和 <a href="https://docs.flutter.io/flutter/cupertino/CupertinoTabView-class.html" target="_blank" rel="noopener">CupertinoTabView</a> 中，因此在这种情况下您无需担心嵌套的导航器，但它是使用嵌套导航器的真实示例。</p><p>以下示例演示了如何使用嵌套的 Navigator 来呈现独立的用户注册过程。</p><p>尽管此示例使用两个 Navigators 来演示嵌套的 Navigators，但仅使用一个 Navigato r就可以获得类似的结果。 </p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      <span class="comment">// ...some parameters omitted...</span></span><br><span class="line">      <span class="comment">// MaterialApp contains our top-level Navigator</span></span><br><span class="line">      initialRoute: <span class="string">'/'</span>,</span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">'/'</span>: (BuildContext context) =&gt; HomePage(),</span><br><span class="line">        <span class="string">'/signup'</span>: (BuildContext context) =&gt; SignUpPage(),</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line">   <span class="comment">// SignUpPage builds its own Navigator which ends up being a nested</span></span><br><span class="line">   <span class="comment">// Navigator in our app.</span></span><br><span class="line">   <span class="keyword">return</span> Navigator(</span><br><span class="line">     initialRoute: <span class="string">'signup/personal_info'</span>,</span><br><span class="line">     onGenerateRoute: (RouteSettings settings) &#123;</span><br><span class="line">       WidgetBuilder builder;</span><br><span class="line">       <span class="keyword">switch</span> (settings.name) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'signup/personal_info'</span>:</span><br><span class="line">           <span class="comment">// Assume CollectPersonalInfoPage collects personal info and then</span></span><br><span class="line">           <span class="comment">// navigates to 'signup/choose_credentials'.</span></span><br><span class="line">           builder = (BuildContext _) =&gt; CollectPersonalInfoPage();</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'signup/choose_credentials'</span>:</span><br><span class="line">           <span class="comment">// Assume ChooseCredentialsPage collects new credentials and then</span></span><br><span class="line">           <span class="comment">// invokes 'onSignupComplete()'.</span></span><br><span class="line">           builder = (BuildContext _) =&gt; ChooseCredentialsPage(</span><br><span class="line">             onSignupComplete: () &#123;</span><br><span class="line">               <span class="comment">// Referencing Navigator.of(context) from here refers to the</span></span><br><span class="line">               <span class="comment">// top level Navigator because SignUpPage is above the</span></span><br><span class="line">               <span class="comment">// nested Navigator that it created. Therefore, this pop()</span></span><br><span class="line">               <span class="comment">// will pop the entire "sign up" journey and return to the</span></span><br><span class="line">               <span class="comment">// "/" route, AKA HomePage.</span></span><br><span class="line">               Navigator.of(context).pop();</span><br><span class="line">             &#125;,</span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">throw</span> Exception(<span class="string">'Invalid route: <span class="subst">$&#123;settings.name&#125;</span>'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> MaterialPageRoute(builder: builder, settings: settings);</span><br><span class="line">     &#125;,</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Navigator.of 在给定 BuildContext 中最近的根 Navigator 上运行。 确保在预期的 Navigator 下面提供BuildContext，尤其是在创建嵌套 Navigators 的大型构建方法中。 Builder 组件可用于访问组件子树中所需位置的 BuildContext。</p><h1 id="页面间数据传递"><a href="#页面间数据传递" class="headerlink" title="页面间数据传递"></a>页面间数据传递</h1><h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>在上面的大多数示例中，我们推送新路由时没有发送数据，但在实际应用中这种情况应用很少。 要发送数据，我们将使用 Navigator 将新的 MaterialPageRoute 用我们的数据推送到堆栈上（这里是 <code>userName</code>）</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> userName = <span class="string">"John Doe"</span>;</span><br><span class="line">Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">        builder: (BuildContext context) =&gt;</span><br><span class="line">        <span class="keyword">new</span> Screen5(userName)));</span><br></pre></td></tr></table></figure><p>要在 <code>Screen5</code> 中得到数据，我们只需在 <code>Screen5</code> 中添加一个参数化构造函数：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen5</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> userName;</span><br><span class="line">  Screen5(<span class="keyword">this</span>.userName);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="built_in">print</span>(userName)</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表示我们不仅可以使用 <code>MaterialPageRoute</code> 作为 <code>push</code> 方法，还可以使用 <code>pushReplacement</code> ，<code>pushAndPopUntil</code> 等。基本上从我们描述的上述方法中路由方法，第一个参数现在将采用 <code>MaterialPageRoute</code> 而不是 <code>namedRoute</code> 的 <code>String</code>。</p><h2 id="数据返回"><a href="#数据返回" class="headerlink" title="数据返回"></a>数据返回</h2><p>我们可能还想从新页面返回数据。 就像一个警报应用程序，并为警报设置一个新音调，您将显示一个带有音频音调选项列表的对话框。 显然，一旦弹出对话框，您将需要所选的项目数据。 它可以这样实现：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(onPressed: ()<span class="keyword">async</span>&#123;</span><br><span class="line">  <span class="built_in">String</span> value = <span class="keyword">await</span> Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> GestureDetector(</span><br><span class="line">              child: <span class="keyword">new</span> Text(<span class="string">'OK'</span>),</span><br><span class="line">              onTap: () &#123; Navigator.pop(context, <span class="string">"Audio1"</span>); &#125;</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">  )</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">print</span>(value);</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">  child: <span class="keyword">new</span> Text(<span class="string">"Return"</span>),)</span><br></pre></td></tr></table></figure><p><em>在 <code>Screen4</code> 中尝试并检查控制台的打印值。</em></p><p>另请注意：当路由用于返回值时，路由的类型参数应与 pop 的结果类型匹配。 这里我们需要一个 String 数据，所以我们使用了 <code>MaterialPageRoute &lt;String&gt;</code>。 不指定类型也没关系。</p><h1 id="其他效果解释"><a href="#其他效果解释" class="headerlink" title="其他效果解释"></a>其他效果解释</h1><h2 id="maybePop"><a href="#maybePop" class="headerlink" title="maybePop"></a>maybePop</h2><p>源码：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;<span class="built_in">bool</span>&gt; maybePop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, [ T result ]) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.of(context).maybePop&lt;T&gt;(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; maybePop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;([ T result ]) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Route&lt;T&gt; route = _history.last;</span><br><span class="line">    <span class="keyword">assert</span>(route._navigator == <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">final</span> RoutePopDisposition disposition = <span class="keyword">await</span> route.willPop();</span><br><span class="line">    <span class="keyword">if</span> (disposition != RoutePopDisposition.bubble &amp;&amp; mounted) &#123;</span><br><span class="line">      <span class="keyword">if</span> (disposition == RoutePopDisposition.pop)</span><br><span class="line">        pop(result);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果我们在初始路由上并且有人错误地试图弹出这个唯一页面怎么办？ 弹出堆栈中唯一的页面将关闭您的应用程序，因为它后面已经没有页面了。这显然是不好的体验。 这就是 <code>maybePop()</code> 起的作用。 点击 <code>Screen1</code> 上的 <code>maybePop</code> 按钮，没有任何效果。 在 <code>Screen3</code> 上尝试相同的操作，可以正常弹出。</p><p>这种效果也可通过 canPop 实现：</p><h2 id="canPop"><a href="#canPop" class="headerlink" title="canPop"></a>canPop</h2><p>源码：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> canPop(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> NavigatorState navigator = Navigator.of(context, nullOk: <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> navigator != <span class="keyword">null</span> &amp;&amp; navigator.canPop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> canPop() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_history.isNotEmpty);</span><br><span class="line">    <span class="keyword">return</span> _history.length &gt; <span class="number">1</span> || _history[<span class="number">0</span>].willHandlePopInternally;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果占中实例大于 1 或 willHandlePopInternally 属性为 true 返回 true，否则返回 false。</p><p>我们可以通过判断 canPop 来确定是否能够弹出该页面。</p><h2 id="如何去除默认返回按钮"><a href="#如何去除默认返回按钮" class="headerlink" title="如何去除默认返回按钮"></a>如何去除默认返回按钮</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.leading,</span><br><span class="line">    <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="keyword">this</span>.actions,</span><br><span class="line">    <span class="keyword">this</span>.flexibleSpace,</span><br><span class="line">    <span class="keyword">this</span>.bottom,</span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">4.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="keyword">this</span>.brightness,</span><br><span class="line">    <span class="keyword">this</span>.iconTheme,</span><br><span class="line">    <span class="keyword">this</span>.textTheme,</span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.centerTitle,</span><br><span class="line">    <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line">    <span class="keyword">this</span>.toolbarOpacity = <span class="number">1.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.bottomOpacity = <span class="number">1.0</span>,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(automaticallyImplyLeading != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(elevation != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(primary != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(titleSpacing != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(toolbarOpacity != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(bottomOpacity != <span class="keyword">null</span>),</span><br><span class="line">       preferredSize = Size.fromHeight(kToolbarHeight + (bottom?.preferredSize?.height ?? <span class="number">0.0</span>)),</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br></pre></td></tr></table></figure><p>将 <code>automaticallyImplyLeading</code>置为 <code>false</code></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://docs.flutter.io/flutter/widgets/Navigator-class.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/widgets/Navigator-class.html</a></p><p><a href="https://medium.com/flutter-community/flutter-push-pop-push-1bb718b13c31" target="_blank" rel="noopener">https://medium.com/flutter-community/flutter-push-pop-push-1bb718b13c31</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;路由初体验&quot;&gt;&lt;a href=&quot;#路由初体验&quot; class=&quot;headerlink&quot; title=&quot;路由初体验&quot;&gt;&lt;/a&gt;路由初体验&lt;/h1&gt;&lt;p&gt;路由（Routes）是什么？路由是屏幕或应用程序页面的抽象。&lt;/p&gt;
&lt;p&gt;Flutter 使我们能够优雅地管理路由
      
    
    </summary>
    
      <category term="Flutter" scheme="https://meandni.com/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter实践：深入 Flutter 的状态管理方式(3)——Redux与旅途小结</title>
    <link href="https://meandni.com/2019/02/09/flutter-state3/"/>
    <id>https://meandni.com/2019/02/09/flutter-state3/</id>
    <published>2019-02-09T08:54:54.000Z</published>
    <updated>2020-10-18T07:44:33.986Z</updated>
    
    <content type="html"><![CDATA[<p>至此，这已经是探索 Flutter 状态管理方式文章的最后一篇，同时这也是新年后的第一篇文章，之后我将将他们应用在实际项目中开发并将值的学习的项目开源出来。对于其中讲解可能有点浅尝则止，因为给出的实例相对简单，但相信聪明的程序员都会有自己的学习方法，你可以从给出的实例结合自己的所学引深出更好的设计方法。</p><p>同时要送给大家的建议是：请在需要这些状态管理方式时使用它，我见过不少的开发者都有用大刀砍白菜的意思，这并不是一个好习惯，你会发现这些状态管理方式有时候不但不会使开发简单，其实还会加大代码量，使其变得复杂，对于如何选择，这里还不够说清楚，希望你们都能找到自己的管理应用程序的方式。</p><p>所有实例：</p><p> github 地址：<a href="https://github.com/MeandNi/Flutter_StateManagement" target="_blank" rel="noopener">https://github.com/MeandNi/Flutter_StateManagement</a></p><ul><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/inheritedValue" target="_blank" rel="noopener">InheritedWidget</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/scoped" target="_blank" rel="noopener">ScopedModel</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/bloc_counter" target="_blank" rel="noopener">bloc_counter</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/bloc_cart" target="_blank" rel="noopener">bloc_cart</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/bloc_inherited" target="_blank" rel="noopener">bloc with inherited</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/redux_counter" target="_blank" rel="noopener">Redux_counter</a></li><li><a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/redux_cart" target="_blank" rel="noopener">Redux_Cart</a></li></ul><hr><p>Redux 由 Facebook 2015年提出，是基于 Flux 理念实现的一个响应式框架的状态管理方式，最早应用于 React 中，而后 React Native 、 Flutter 等多个框架也同样可以使用。</p><p>学习 Redux 之前，请了解 Redux 所能做到的事情：</p><ul><li>单一状态来源：整个应用程序的状态存储在单个的对象树中。</li><li>状态只读：更改状态的唯一方法是发出一个 action（一个描述发生什么事件的对象）。</li><li>使用纯函数更改状态：通过 reducers，状态知道如何通过操作进行改变，reducers便是一个纯函数。</li></ul><p><img src="/images/redux1.png" alt=""></p><p>如果你用过 React ，相信你对上面的概念已经很清晰了，没使用过？也 OK，下面慢慢道来….</p><p>整体的思路：所有状态存放在 store 中，Redux 将 store 内所有状态放入对应的组件中呈现在 Ui 上，用户与 UI 交互（如点击）发起一个 action（一个描述行为的对象），store 可判别 action类型并作用相应的 reducer（操作改变状态的纯函数），reducer 完成相应改变后将数据放到全局的 store 中，实现改变。</p><p><img src="/images/redux2.png" alt=""></p><p>思路简单，描述起来蛮复杂，其实它的目的就是实现代码作用域的分离。</p><p>那么如何让将以上描述应用于实际的应用程序中呢？</p><h2 id="redux-实现计数器应用"><a href="#redux-实现计数器应用" class="headerlink" title="redux 实现计数器应用"></a>redux 实现计数器应用</h2><p>其中的实现与 ScopedModel 很相似，<strong>抓住两个要点，如何在 UI 中呈现以及如何 发起 action 改变状态。</strong></p><p>我们首先定义 一个全局状态 AppState：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> counter;</span><br><span class="line">  AppState(<span class="keyword">this</span>.counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面有一个 counter 变量用于计数。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>如前面所述，State 的变化，会导致 UI 的变化。但是，用户接触不到 State，只能接触到 UI。所以，State 的变化必须是 UI 导致的。Action 就是 UI 发出的通知，表示 State 应该要发生变化了。</p><p>我们这里有一个促使 counter 增加的 action：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Actions &#123; Increment &#125;</span><br></pre></td></tr></table></figure><h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p><p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppState reducer(AppState prev, action) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action == Actions.Increment) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppState(prev.counter + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reducer 中判断了 action 时 Increment 这一类型，将一个新的 AppState 返回到 store。</p><h3 id="在-UI-中呈现-StoreConnector"><a href="#在-UI-中呈现-StoreConnector" class="headerlink" title="在 UI 中呈现(StoreConnector)"></a>在 UI 中呈现(StoreConnector)</h3><p>首先初始化状态：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> store = <span class="keyword">new</span> Store(reducer, initialState: <span class="keyword">new</span> AppState(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>然后显示状态：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> StoreConnector(</span><br><span class="line">  converter: (store) =&gt; store.state.counter,</span><br><span class="line">  builder: (context, counter) =&gt; <span class="keyword">new</span> Text(</span><br><span class="line">    <span class="string">'<span class="subst">$counter</span>'</span>,</span><br><span class="line">    style: Theme.of(context).textTheme.display1,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>通过 converter 属性拿到 state 中的 counter 属性。</p><p>然后传入 builder 应用在组件中。</p><h3 id="发起-action-改变状态"><a href="#发起-action-改变状态" class="headerlink" title="发起 action 改变状态"></a>发起 action 改变状态</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> StoreConnector(</span><br><span class="line">    converter: (store) &#123;</span><br><span class="line">      <span class="keyword">return</span> () =&gt; store.dispatch(Actions.Increment);</span><br><span class="line">    &#125;,</span><br><span class="line">    builder: (context, callback) =&gt; <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">      onPressed: callback,</span><br><span class="line">      tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">      child: <span class="keyword">new</span> Icon(Icons.add),</span><br><span class="line">    ), </span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>同样是使用 StoreConnector，然而这次通过 converter 拿到的是一个 <code>store.dispatch(Actions.Increment)</code>，<code>store.dispatch()</code>是 View 发出 Action 的唯一方法。而后在组件中调用该回调方法即可。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>完整代码被放在一个文件中：<a href="https://github.com/MeandNi/Flutter_StateManagement/blob/master/lib/redux/main.dart" target="_blank" rel="noopener">样例代码</a></p><p>Redux 应用在 ShoppingCart：<a href="https://github.com/MeandNi/Flutter_StateManagement/tree/master/lib/redux_cart" target="_blank" rel="noopener">样例代码</a></p><p><img src="/images/redux6.png" alt=""></p><p><img src="/images/redux5.gif" alt=""></p><h2 id="将-Redux-用于更复杂的应用中"><a href="#将-Redux-用于更复杂的应用中" class="headerlink" title="将 Redux 用于更复杂的应用中"></a>将 Redux 用于更复杂的应用中</h2><p>在复杂的应用中我们可以将应用程序中的 reducer 根据业务类型分离，例如用户信息、产品信息等不同业务的操作分离到单独的模块，</p><p><img src="/images/redux3.png" alt=""></p><p>而后将其合并：</p><p><img src="/images/redux4.png" alt=""></p><p>实现上看的分离后，又可只将相应业务的数据放到相应业务根 widget（其子组件的所有数据和操作来自该根组件）</p><p>我们将需要的数据及操作到一个对象中，传递到组件中：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeviceFragment</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: <span class="keyword">new</span> StoreConnector&lt;AppState, _ViewModel&gt;(</span><br><span class="line">          converter: _ViewModel.fromStore,</span><br><span class="line">          builder: (context, vm) &#123;</span><br><span class="line">            <span class="keyword">return</span> DeviceList(</span><br><span class="line">              devices: vm.devices,</span><br><span class="line">              onStateChanged: vm.onStateChanged,</span><br><span class="line">              onRemove: vm.onRemove,</span><br><span class="line">              onUndoRemove: vm.onUndoRemove,</span><br><span class="line">            );</span><br><span class="line">          &#125;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Device&gt; devices;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// final bool loading;</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span>(Device) onStateChanged;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span>(Device) onRemove;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span>(Device) onUndoRemove;</span><br><span class="line"></span><br><span class="line">  _ViewModel(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.devices,</span><br><span class="line">    <span class="comment">// @required this.loading,</span></span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onStateChanged,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onRemove,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.onUndoRemove,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> _ViewModel fromStore(Store&lt;AppState&gt; store) &#123;</span><br><span class="line">    <span class="keyword">return</span> _ViewModel(</span><br><span class="line">      devices: store.state.devices,</span><br><span class="line">      <span class="comment">// loading: store.state.isLoading,</span></span><br><span class="line">      onStateChanged: (device) &#123;</span><br><span class="line">        store.dispatch(editItem(device.copyWith(state: !device.state)));</span><br><span class="line">      &#125;,</span><br><span class="line">      onRemove: (device) &#123;</span><br><span class="line">        store.dispatch(deleteDevice(device));</span><br><span class="line">      &#125;,</span><br><span class="line">      onUndoRemove: (device) &#123;</span><br><span class="line">        store.dispatch(AddDeviceAction(device));</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使得产生模块化管理的思想！（以上实例来自正在开发的一个真实项目，目前还未开源。）</p><p>同时，在实际的应用程序中，你一定需要在程序启动初期来加载来自云端或者数据本地的数据，你可以在入口的页面中接受一个加载数据的函数，放入 initState 函数中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;至此，这已经是探索 Flutter 状态管理方式文章的最后一篇，同时这也是新年后的第一篇文章，之后我将将他们应用在实际项目中开发并将值的学习的项目开源出来。对于其中讲解可能有点浅尝则止，因为给出的实例相对简单，但相信聪明的程序员都会有自己的学习方法，你可以从给出的实例结合自
      
    
    </summary>
    
      <category term="Flutter" scheme="https://meandni.com/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="状态管理" scheme="https://meandni.com/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Flutter实践：深入 Flutter 的状态管理方式(2)——演化BloC</title>
    <link href="https://meandni.com/2019/02/02/flutter-state1/"/>
    <id>https://meandni.com/2019/02/02/flutter-state1/</id>
    <published>2019-02-02T04:34:27.000Z</published>
    <updated>2020-10-18T07:44:29.939Z</updated>
    
    <content type="html"><![CDATA[<p>在上篇文章中，我详细介绍了 InheritedWidget 及 ScopedModel 实现原理与方法，有同学说找不到源码，其实上篇文章包括这篇文章里的源码都按步骤放在<a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">样例代码</a>里了，有同学说有点懵，其实上一篇的概念过多而且本身我表达也不是很清晰，英文文档中我也解释的没有完全语义化，所以还请谅解，<strong>结合实际代码你会有更好地理解</strong>。</p><p>这篇的重点我将放在 BloC 的实现上面，我们已经知道 Strems 的概念，RXDart 是依赖 Streams 使用的输入（_Sink_）和输出（<em>stream</em>）封装而成的响应式库，BloC 基于此便可以实时侦听数据的变化而改变数据，并且，BloC 主要解决的问题就是他不会一刀切的更新整个状态树，它关注的是数据，经过一系列处理后得到它并且只改变应用它的 widget。</p><p><img src="/images/flutterstate2.png" alt=""></p><h3 id="如何将-Stream-中的数据应用到-Widget？"><a href="#如何将-Stream-中的数据应用到-Widget？" class="headerlink" title="如何将 Stream 中的数据应用到 Widget？"></a>如何将 Stream 中的数据应用到 Widget？</h3><p>我们先来实践一下如何在 widget 中使用数据。Flutter 提供了一个名为 <a href="https://docs.flutter.io/flutter/widgets/StreamBuilder-class.html" target="_blank" rel="noopener">StreamBuilder</a> 的 StatefulWidget。</p><p>StreamBuilder 监听 Stream，每当一些数据流出 Stream 时，它会自动重建，调用其构建器回调。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">StreamBuilder&lt;T&gt;(</span><br><span class="line">    key: ...optional, the unique ID of <span class="keyword">this</span> Widget...</span><br><span class="line">    stream: ...the stream to listen to...</span><br><span class="line">    initialData: ...any initial data, <span class="keyword">in</span> <span class="keyword">case</span> the stream would initially be empty...</span><br><span class="line">    builder: (BuildContext context, AsyncSnapshot&lt;T&gt; snapshot)&#123;</span><br><span class="line">        <span class="keyword">if</span> (snapshot.hasData)&#123;</span><br><span class="line">            <span class="keyword">return</span> ...the Widget to be built based <span class="keyword">on</span> snapshot.data</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ...the Widget to be built <span class="keyword">if</span> no data <span class="keyword">is</span> available</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>以下示例使用 Stream 而不是 setState() 模拟默认的“计数器”应用程序：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;<span class="built_in">int</span>&gt; _streamController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _streamController.close();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: _streamController.stream,</span><br><span class="line">          initialData: _counter,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          _streamController.sink.add(++_counter);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第24-30行：我们监听流，每次有一个新值流出这个流时，我们用该值更新 Text;</li><li>第35行：当我们点击 FloatingActionButton 时，我们递增计数器并通过接收器将其发送到 Stream; 侦听它的 StreamBuilder 注入了该值相应到后重建并“刷新”计数器;</li><li>我们不再需要 State，所有东西都可以通过 Stream 接受;</li><li>这里实现了相当大的优化，因为调用 setState() 方法会强制整个 Widget（和任何子组件）重新渲染。 而在这里，只重建 StreamBuilder（当然还有其子组件）;</li><li>我们仍需要使用 StatefulWidget 的唯一原因，仅仅是因为我们需要通过 dispose 方法第15行释放StreamController;</li></ul><h3 id="实现真正的-BloC"><a href="#实现真正的-BloC" class="headerlink" title="实现真正的 BloC"></a>实现真正的 BloC</h3><p>是时候展现真正的计技术了，我们依然将 BloC 用于默认的计数器应用中：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">          bloc: IncrementBloc(),</span><br><span class="line">          child: CounterPage(),</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: bloc.outCounter,</span><br><span class="line">          initialData: <span class="number">0</span>,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          bloc.incrementCounter.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _counterController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  StreamSink&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> _inAdd =&gt; _counterController.sink;</span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> outCounter =&gt; _counterController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the action on the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController _actionController = StreamController();</span><br><span class="line">  StreamSink <span class="keyword">get</span> incrementCounter =&gt; _actionController.sink;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  IncrementBloc()&#123;</span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    _actionController.stream</span><br><span class="line">                     .listen(_handleLogic);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _actionController.close();</span><br><span class="line">    _counterController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleLogic(data)&#123;</span><br><span class="line">    _counter = _counter + <span class="number">1</span>;</span><br><span class="line">    _inAdd.add(_counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是上篇文章的最后给打大家制造悬念的代码？五脏俱全，基本已经实现了 BloC。</p><p>结合上面的例子来分析 BloC 体现出来的优势：（建议先将<a href="https://github.com/MeandNi/Flutter_StatePro/blob/master/lib/bloc_counter/main.dart" target="_blank" rel="noopener">这段代码</a>跑起来！）</p><h4 id="一，BloC-实现了责任分离"><a href="#一，BloC-实现了责任分离" class="headerlink" title="一，BloC 实现了责任分离"></a>一，BloC 实现了责任分离</h4><p>你可以看到 CounterPage（第21-45行），其中没有任何业务逻辑。</p><p>它承担的负责仅有：</p><ul><li>显示计数器，现在只在必要时更新</li><li>提供一个按钮，当按下时，请求执行动作</li></ul><p>此外，整个业务逻辑集中在一个单独的类“IncrementBloc”中。</p><p>如果现在，如果我们需要更改业务逻辑，只需更新方法 _handleLogic（第77-80行）。 也许新的业务逻辑将要求做非常复杂的事情…… CounterPage 永远与它无关！</p><h4 id="二，可测试性"><a href="#二，可测试性" class="headerlink" title="二，可测试性"></a>二，可测试性</h4><p>现在，测试业务逻辑也变得更加容易。</p><p>无需再通过用户界面测试业务逻辑。 只需要测试 IncrementBloc 类。</p><h4 id="三，任意组织布局"><a href="#三，任意组织布局" class="headerlink" title="三，任意组织布局"></a>三，任意组织布局</h4><p>由于使用了 Streams，您现在可以独立于业务逻辑组织布局。</p><p>你可以从应用程序中的任何位置用任何操作：只需调用 <em>.incrementCounter</em> 接收器即可。</p><p>您可以在任何页面的任何位置显示计数器，只需舰艇监听 .outCounter 流。</p><h4 id="四，减少-“build”-的数量"><a href="#四，减少-“build”-的数量" class="headerlink" title="四，减少 “build” 的数量"></a>四，减少 “build” 的数量</h4><p>不用 <code>setState()</code>而是使用 StreamBuilder，从而大大减少了“构建”的数量，只减少了所需的数量。</p><p>这是性能上的巨提高！</p><h4 id="只有一个约束……-BLoC的可访问性"><a href="#只有一个约束……-BLoC的可访问性" class="headerlink" title="只有一个约束…… BLoC的可访问性"></a>只有一个约束…… BLoC的可访问性</h4><p>为了达到各种目的，BLoC 需要可访问。</p><p>有以下几种方法可以访问它：</p><ul><li><p>通过全局单例的变量</p><p>这种方式很容易实现，但不推荐。 此外，由于 Dart 中没有类析构函数，因此我们永远无法正确释放资源。</p></li><li><p>作为本地实例</p><p>您可以实例化 BLoC 的本地实例。 在某些情况下，此解决方案完全符合需求。 在这种情况下，您应该始终考虑在 StatefulWidget 中初始化，以便您可以利用 dispose() 方法来释放它。</p></li><li><p>由根组件提供<br>使其可访问的最常见方式是通过根 Widget，将其实现为 StatefulWidget。</p><p>以下代码给出了一个通用 BlocProvider 的示例：（这个例子牛逼！）</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generic Interface for all BLoCs</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic BLoC provider</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  BlocProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;();</span><br><span class="line">    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type);</span><br><span class="line">    <span class="keyword">return</span> provider.bloc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">BlocBase</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    widget.bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这段通用的 <em>BlocProvider</em> 仔细回味，你会发现其精妙之处！</p><p>通用 <em>BlocProvider</em> 的一些解释：</p><p>首先，如何将其用作数据提供者？</p><p>如果你看了上面<a href="https://gist.github.com/MeandNi/1161560bf90c5bc7f341844e8126a8f4" target="_blank" rel="noopener">BloC 计数器的示例代码</a>示例代码，您将看到以下代码行（第12-15行）</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">         bloc: IncrementBloc(),</span><br><span class="line">         child: CounterPage(),</span><br><span class="line">       ),</span><br></pre></td></tr></table></figure><p>使用以上代码，我们实例化了一个想要处理 _IncrementBloc_ 的新 _BlocProvider_，并将 _CounterPage_ 呈现为子组件。</p><p>从 _BlocProvider_ 开始的子组件的任何组件部分都将能够通过以下行访问 _IncrementBloc_：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br></pre></td></tr></table></figure></li></ul><p>BLoC 的基本使用就介绍完了，所有<a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">实例代码在这里</a> ，我将每种状态管理的方法分模块放在里面，选择使用哪种方式运行代码即可。</p><h3 id="BloC-其他你必须知道的事情"><a href="#BloC-其他你必须知道的事情" class="headerlink" title="BloC 其他你必须知道的事情"></a>BloC 其他你必须知道的事情</h3><h4 id="可以实现多个-BloC"><a href="#可以实现多个-BloC" class="headerlink" title="可以实现多个 BloC"></a>可以实现多个 BloC</h4><p>在大型项目中，这是非常可取的。 给以下几个建议：</p><ul><li>（如果有任何业务逻辑）每页顶部有一个BLoC，</li><li>用一个 ApplicationBloc 来处理应用程序所有状态</li><li>每个“足够复杂的组件”都有相应的BLoC。</li></ul><p>以下示例代码在整个应用程序的顶部使用 _ApplicationBloc_，然后在 _CounterPage_ 顶部使用 _IncrementBloc_。该示例还展示了如何使用两个 Bloc：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(</span><br><span class="line">  BlocProvider&lt;ApplicationBloc&gt;(</span><br><span class="line">    bloc: ApplicationBloc(),</span><br><span class="line">    child: MyApp(),</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">      home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">        bloc: IncrementBloc(),</span><br><span class="line">        child: CounterPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc counterBloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line">    <span class="keyword">final</span> ApplicationBloc appBloc = BlocProvider.of&lt;ApplicationBloc&gt;(context);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为何不用-InheritedWidget-来全局管理-BloC-的状态"><a href="#为何不用-InheritedWidget-来全局管理-BloC-的状态" class="headerlink" title="为何不用 InheritedWidget 来全局管理 BloC 的状态"></a>为何不用 InheritedWidget 来全局管理 BloC 的状态</h4><p>我为此也整理了一个将 BLoC 结合 InheritedWidget 使用的示例：</p><p>在很多与 BLoC 相关的文章中，您将看到 _Provider_ 的实现其实是一个 _InheritedWidget_。</p><p>当然，  这是完全可以实现的，然而，</p><ul><li>一个 <em>InheritedWidget</em> 没有提供任何 <em>dispose</em> 方法，记住，在不再需要资源时总是释放资源是一个很好的做法。</li><li>当然，你也可以将 <em>InheritedWidget</em> 包装在另一个 <em>StatefulWidget</em> 中，但是，乍样使用 <em>InheritedWidget</em> 并没有什么便利之处！</li><li>最后，如果不受控制，使用 <em>InheritedWidget</em> 经常会导致一些副作用（请参阅下面的  _InheritedWidget_ 上的提醒）。</li></ul><p>这 3 点解释了我为何将通用 BlocProvider 实现为 StatefulWidget，这样我就可以<strong>释放资源</strong>。</p><blockquote><p>Flutter无法实例化泛型类型</p><p>不幸的是，Flutter 无法实例化泛型类型，我们必须将 BLoC 的实例传递给 BlocProvider。 为了在每个BLoC中强制执行 dispose() 方法，所有BLoC都必须实现 BlocBase 接口。</p></blockquote><h4 id="关于使用-InheritedWidget-的提醒"><a href="#关于使用-InheritedWidget-的提醒" class="headerlink" title="关于使用 InheritedWidget 的提醒"></a>关于使用 InheritedWidget 的提醒</h4><p>在使用 <em>InheritedWidget</em> 并通过 <em>context.inheritFromWidgetOfExactType(…)</em> 获取指定类型最近的 <em>Widget</em> 时，每当InheritedWidget 的父级或者子布局发生变化时，这个方法会自动将当前 “<em>context</em>”（= <em>BuildContext</em>）注册到要重建的 <em>widget</em> 当中。</p><blockquote><p>请注意，为了完全正确，我刚才解释的与 <em>InheritedWidget</em> 相关的问题只发生在我们将 <em>InheritedWidget</em> 与 <em>StatefulWidget</em> 结合使用时。 当您只使用没有 State 的 InheritedWidget 时，问题就不会发生。 </p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flutter 状态管理的这几种模式同样可以适用于很多软件开发中，而 BloC 模式最初的设想是实现允许独立于平台重用相同的代码！因此多花时间学习这类模式便是软件开发的根基。</p><p>我的建议是将<strong>实例代码运行出来阅读代码</strong>，依靠文章理解！希望能帮助到你！</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>这篇内容是我反复看完 <a href="https://www.youtube.com/watch?v=RS36gBEp8OI&amp;index=115&amp;list=PLOU2XLYxmsIInFRc3M44HUTQc3b_YJ4-Y" target="_blank" rel="noopener">Build reactive mobile apps with Flutter (Google I/O ‘18)</a> 谷歌大会写完的。</p><p>并且大量借鉴了 <a href="https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/" target="_blank" rel="noopener">Reactive Programming - Streams - BLoC</a> 这篇文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上篇文章中，我详细介绍了 InheritedWidget 及 ScopedModel 实现原理与方法，有同学说找不到源码，其实上篇文章包括这篇文章里的源码都按步骤放在&lt;a href=&quot;https://github.com/MeandNi/Flutter_StatePro&quot;
      
    
    </summary>
    
      <category term="Flutter" scheme="https://meandni.com/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="状态管理" scheme="https://meandni.com/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Flutter实践：深入探索 Flutter 中的状态管理方式(1)</title>
    <link href="https://meandni.com/2019/01/30/flutter-state1/"/>
    <id>https://meandni.com/2019/01/30/flutter-state1/</id>
    <published>2019-01-30T12:54:19.000Z</published>
    <updated>2020-10-18T07:44:27.215Z</updated>
    
    <content type="html"><![CDATA[<p>利用 Flutter 内置的许多控件我们可以打造出一款不仅漂亮而且完美跨平台的 App 外壳，我利用其特性完成了类似<a href="https://github.com/MeandNi/Flutter_ZhiHu" target="_blank" rel="noopener">知乎App的UI界面</a>，然而一款完整的应用程序显然不止有外壳这么简单。填充在外壳里面的是数据，数据来源或从本地，或从云端，大量的数据处理很容易造成数据的混乱，耦合度提高，不便于维护，于是诞生了很多设计模式和状态管理的方式。</p><p>目前 Flutter 常用状态管理方式有如下几种：</p><ul><li>ScopedModel</li><li>BLoC (Business Logic Component) / Rx</li><li>Redux</li></ul><p>这篇文章暂且不提这些比较复杂的模式。我们简单的提出三个问题：</p><ul><li>Flutter 中组件之间如何通信？</li><li>更新 State 后组件以何种方式重新渲染？</li><li>如何在路由转换之间保持状态同步？</li></ul><h3 id="初探-State"><a href="#初探-State" class="headerlink" title="初探 State"></a>初探 State</h3><p>我以创建新项目 Flutter 给我们默认的计数器应用为例，通过路由我将其拆分为两部分 <code>MyHomePage</code>和 <code>PageTwo</code>，</p><p>MyHomePage，持有一个<code>_counter</code>变量和一个增加计数的方法，PageTwo，接收两个参数(计数的至和增加计数的方法)：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageTwo</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> count;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span> increment;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> PageTwo(&#123;Key key, <span class="keyword">this</span>.count, <span class="keyword">this</span>.increment&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  _PageTwoState createState() =&gt; _PageTwoState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_PageTwoState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">PageTwo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">"Page Two"</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Text(widget.count.toString(), style: TextStyle(fontSize: <span class="number">30.0</span>),),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">        onPressed: widget.increment,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现的状况是：我们在首页点击按钮触发计数器增加，路由到 PageTwo 后，数值正常显示，然而点击这个界面中的 add 按钮该页面的数值并未发生改变，通过观察父页面的 count 值确实发生了改变，因此再次通过路由到第二个界面界面才显示正常。解答上面三个问题：</p><ul><li><p>Flutter 中组件之间如何通信？</p><p>参数传递。</p></li><li><p>更新 State 后组件以何种方式重新渲染？</p><p>只渲染当前的组件（和子组件，这里暂未证明，但确实是触发 SetSate() 后，其所有子组件都将重新渲染。）</p></li><li><p>如何在路由转换之间保持状态同步？</p><p>父组件传递状态值到子组件，子组件拿到并显示，但却不能实时更改😀，我一时半会还正没想出什么解决方法，我相信即使能做到也不优雅。</p></li></ul><p>证明触发 SetSate() 后，其所有子组件都将重新渲染：我在副组件中添加两个子组件，一旦触发渲染变打印相关数据：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TestStateless(),</span><br><span class="line">TestStateful()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStateless</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'build TestStateless'</span>);</span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'TestStateless'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStateful</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TestStatefulState createState() =&gt; _TestStatefulState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TestStatefulState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TestStateful</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'build TestStateful'</span>);</span><br><span class="line">    <span class="keyword">return</span> Text(<span class="string">'_TestStatefulState'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时到 PageTwo 触发 add 事件，日志出来：</p><p><img src="/images/flutterstate1.png" alt=""></p><p>通过这种简单的方式已经可以说明一个问题，即以最简单的方式我们已经可以完成状态传递和组件渲染，而路由间保持状态一致还不能解决。</p><p><img src="/images/flutterstate8.gif" alt=""></p><h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>Google 官方给我们的解决方案是 <code>InheritedWidget</code>，怎么理解他，我们可以称它为“状态树”，它使得所有的 widget 的 State 来源统一，这样一旦有一处触发状态改变，Flutter 以某种方式感应到了（有个监听器），砍掉它，长出一个新树，Perfect！所有地方都能感受到他的变化。上面提到的第一种状态管理方式 <code>ScopedModel</code>便是基于此而产生的一套第三方库。</p><p>其实现在看来 InheritedWidget 已经非常简单了，我们抓住两个点即可完全掌握它：</p><ol><li><p>状态树中的数据</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInheritedValue</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> MyInheritedValue(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.value,</span><br><span class="line">    <span class="meta">@required</span> Widget child,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(value != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(child != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> value;</span><br><span class="line">  <span class="keyword">static</span> MyInheritedValue of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.inheritFromWidgetOfExactType(MyInheritedValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(MyInheritedValue old) =&gt; </span><br><span class="line">        value != old.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入到根组件中：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> MyInheritedValue(</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    child: ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用状态树中数据的其他 Widget</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 拿到状态树中的值</span><br><span class="line">MyInheritedValue.of(context).value</span><br></pre></td></tr></table></figure><p>请注意：这种情况下是不能改 InheritedWidget 中的值的，需要改也很简单就是将 MyInheritedValue 的值封装成一个对象，每次改变这个对象的值，具体法相看我的<a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">样例代码</a>！</p><p><img src="/images/flutterstate7.png" alt=""></p></li></ol><p>上面所说砍掉整棵树过于粗暴却并不夸张，因为一处改变它将联动整棵树，</p><p>ScopedModel 是基于 InheritedWidget 的库，实现起来与 InheritedWidget 大同小异，而且其有一种可以让局部组件不改变的方式：设置 rebuildOnChange 为 false。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> ScopedModelDescendant&lt;CartModel&gt;(</span><br><span class="line">          rebuildOnChange: <span class="keyword">false</span>,</span><br><span class="line">          builder: (context, child, model) =&gt; ProductSquare(</span><br><span class="line">                product: product,</span><br><span class="line">                onTap: () =&gt; model.add(product),</span><br><span class="line">              ),</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><p>具体代码请看 GitHub，ScopedModel 样例截取一个老外给的实例，就是下方参考链接 Google 开发者大会上演讲的那两位其中之一。</p><p><img src="/images/flutterstate9.gif" alt=""></p><p>这种方式显然有点不足之处就是一旦遇到小规模变动就要引起大规模重新渲染，所以当项目达到一定的规模考虑 Google 爸爸给我们的另一种解决方案。</p><h3 id="Streams（流）"><a href="#Streams（流）" class="headerlink" title="Streams（流）"></a>Streams（流）</h3><p>在 Android 开发中我们经常会用到 RxJava 这类响应式编程方法的框架，其强大之处无须多言，而 Stream 看上去就是在 Dart 语言中的响应式编程的一种实现。</p><ul><li><p>Streams 是什么鬼？</p><p>如果要具体把 Streams 说清楚，一篇文章绝对不够，这里先介绍一下其中的概念，这篇文章目的就是如此。待我后续想好怎么具体描述清楚。</p><p>你可以把它想象成一个管道，有入口（StreamSink）和出口（），我们将想要处理的数据从入口放入经过该管道经过一系列处理（经由 <em>StreamController</em>）从出口中出来，而出口又有一个类似监听器之物，我们不知道它何时到来或者何时处理结束。但是当出口的监听器拿到东西便立即做出相应的反应。</p></li><li><p>那些东西可以放入管道？<br>任何变量、对象、数组、甚至事件都可以被当作数据源从入口放进去。</p></li><li><p>Streams 种类</p><ol><li>Single-subscription Stream，“单订阅”流，这种类型的流只允许在该流的整个生命周期内使用单个侦听器。即使在第一个订阅被取消后，也无法在此类流上收听两次。</li><li>Broadcast Streams，第二种类型的Stream允许任意数量的侦听器。可以随时向广播流添加侦听器。 新的侦听器将在它开始收听 Stream 时收到事件。</li></ol><p>例子：</p></li></ul><p>第一个示例显示了“单订阅”流，只打印输入的数据。 你会发现是哪种数据类型无关紧要。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;dart:async&#39;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F; Initialize a &quot;Single-Subscription&quot; Stream controller</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  final StreamController ctrl &#x3D; StreamController();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F; Initialize a single listener which simply prints the data</span><br><span class="line">  &#x2F;&#x2F; as soon as it receives it</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  final StreamSubscription subscription &#x3D; ctrl.stream.listen((data) &#x3D;&gt; print(&#39;$data&#39;));</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F; We here add the data that will flow inside the stream</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  ctrl.sink.add(&#39;my name&#39;);</span><br><span class="line">  ctrl.sink.add(1234);</span><br><span class="line">  ctrl.sink.add(&#123;&#39;a&#39;: &#39;element A&#39;, &#39;b&#39;: &#39;element B&#39;&#125;);</span><br><span class="line">  ctrl.sink.add(123.45);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  &#x2F;&#x2F; We release the StreamController</span><br><span class="line">  &#x2F;&#x2F;</span><br><span class="line">  ctrl.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个示例显示“广播”流，它传达整数值并仅打印偶数。 我们用 StreamTransformer 来过滤（第14行）值，只让偶数经过。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a "Broadcast" Stream controller of integers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;<span class="built_in">int</span>&gt; ctrl = StreamController&lt;<span class="built_in">int</span>&gt;.broadcast();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Initialize a single listener which filters out the odd numbers and</span></span><br><span class="line">  <span class="comment">// only prints the even numbers</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">final</span> StreamSubscription subscription = ctrl.stream</span><br><span class="line">      .where((value) =&gt; (value % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line">      .listen((value) =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$value</span>'</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We here add the data that will flow inside the stream</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;<span class="number">11</span>; i++)&#123;</span><br><span class="line">  ctrl.sink.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We release the StreamController</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  ctrl.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RxDart"><a href="#RxDart" class="headerlink" title="RxDart"></a>RxDart</h3><p>RxDart包是 ReactiveX API 的 Dart 实现，它扩展了原始的 Dart Streams API 以符合 ReactiveX 标准。</p><p><img src="/images/flutterstate2.png" alt=""></p><p>由于它最初并未由 Google 定义，因此它使用不同于 Dart 的变量。 下表给出了 Dart 和 RxDart 之间的关系。</p><div class="table-container"><table><thead><tr><th>Dart</th><th>RxDart</th></tr></thead><tbody><tr><td>Stream</td><td>Observable</td></tr><tr><td>StreamController</td><td>Subject</td></tr></tbody></table></div><p>RxDart 扩展了原始的 Dart Streams API 并提供了 StreamController 的3个主要变体：</p><ol><li><p>PublishSubject</p><p>PublishSubject 是一个普通的 <strong>broadcast</strong> StreamController ，有一点不同：stream 返回一个 Observable 而不是一个 Stream 。</p><p><img src="/images/flutterstate3.png" alt=""></p><p>如您所见，PublishSubject 仅向侦听器发送在订阅之后添加到 Stream 的事件。</p></li><li><p>BehaviorSubject</p><p>BehaviorSubject 也是一个 broadcast StreamController，它返回一个 Observable 而不是一个Stream。</p><p><img src="/images/flutterstate4.png" alt=""></p><p>与 PublishSubject 的主要区别在于 BehaviorSubject 还将最后发送的事件发送给刚刚订阅的侦听器。</p></li><li><p>ReplaySubject</p><p>ReplaySubject 也是一个广播 StreamController，它返回一个 Observable 而不是一个 Stream。(萝莉啰嗦)</p><p><img src="/images/flutterstate5.png" alt=""></p><p>默认情况下，ReplaySubject 将Stream 已经发出的所有事件作为第一个事件发送到任何新的侦听器。</p></li></ol><h3 id="BloC"><a href="#BloC" class="headerlink" title="BloC"></a>BloC</h3><p>BLoC 代表业务逻辑组件 (<strong>B</strong>usiness <strong>Lo</strong>gic <strong>C</strong>omponent)。一般的 Flutter 代码业务逻辑和UI组件糅合在一起，不方便测试，不利于单独的测试业务逻辑部分，不能更好的重用业务逻辑代码，体现在，如果网络请求的逻辑有所变动的话，加入这个业务功能被两个端（web、flutter）使用的话，是需要改动两个地方的。</p><p>简而言之，业务逻辑需要：</p><ul><li>被移植到一个或几个 BLoC 中，</li><li>尽可能从表示层中删除。 也就是说，UI组件应该只关心UI事物而不关心业务，</li><li>依赖 Streams 使用输入（Sink）和输出（<em>stream</em>），</li><li>保持平台独立，</li><li>保持环境独立。</li></ul><p>事实上，BLoC 模式最初的设想是实现允许独立于平台重用相同的代码：Web应用程序，移动应用程序，后端。</p><p>Bloc 的大概就是 Stream 在 Flutter 中的最佳实践：</p><p><img src="/images/flutterstate6.png" alt=""></p><ul><li>组件通过 Sinks 向 BLoC 发送事件，</li><li>BLoC 通过 stream 通知组件，</li><li>由 BLoC 实现的业务逻辑。</li></ul><p>将 BloC 应用在计数器应用中：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">          bloc: IncrementBloc(),</span><br><span class="line">          child: CounterPage(),</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: bloc.outCounter,</span><br><span class="line">          initialData: <span class="number">0</span>,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          bloc.incrementCounter.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _counterController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  StreamSink&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> _inAdd =&gt; _counterController.sink;</span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> outCounter =&gt; _counterController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the action on the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController _actionController = StreamController();</span><br><span class="line">  StreamSink <span class="keyword">get</span> incrementCounter =&gt; _actionController.sink;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  IncrementBloc()&#123;</span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    _actionController.stream</span><br><span class="line">                     .listen(_handleLogic);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _actionController.close();</span><br><span class="line">    _counterController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleLogic(data)&#123;</span><br><span class="line">    _counter = _counter + <span class="number">1</span>;</span><br><span class="line">    _inAdd.add(_counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你一定在说，卧槽，哇靠～～什么吊玩意，那么就留着悬念吧，今天写不动了！</p><p>Bolc 的具体实现我在样例代码里分两步走放在两个文件夹里！如果需要可以先去看看尝尝鲜。</p><p>这篇文章的目的就是介绍一些概念给大家关于 Streams、RXDart 及 Bloc 详细明了的解释后续更新！</p><h3 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h3><p><a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">https://github.com/MeandNi/Flutter_StatePro</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.youtube.com/watch?v=RS36gBEp8OI&amp;index=115&amp;list=PLOU2XLYxmsIInFRc3M44HUTQc3b_YJ4-Y" target="_blank" rel="noopener">Build reactive mobile apps with Flutter (Google I/O ‘18)</a></p><p><a href="https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/" target="_blank" rel="noopener">Reactive Programming - Streams - BLoC</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用 Flutter 内置的许多控件我们可以打造出一款不仅漂亮而且完美跨平台的 App 外壳，我利用其特性完成了类似&lt;a href=&quot;https://github.com/MeandNi/Flutter_ZhiHu&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="Flutter" scheme="https://meandni.com/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
      <category term="状态管理" scheme="https://meandni.com/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Flutter知乎App实践：UI+Json+Utils</title>
    <link href="https://meandni.com/2019/01/29/flutter-zhihu/"/>
    <id>https://meandni.com/2019/01/29/flutter-zhihu/</id>
    <published>2019-01-29T07:17:22.000Z</published>
    <updated>2020-10-18T07:52:25.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter实践之知乎App"><a href="#Flutter实践之知乎App" class="headerlink" title="Flutter实践之知乎App"></a>Flutter实践之知乎App</h2><p>预览图：</p><p><img src="/images/showapp.jpg" alt="app展示"></p><p><img src="/images/showapp2.jpg" alt="app展示"></p><p><img src="/images/showgif.gif" alt="app展示"></p><p><img src="/images/showgif2.gif" alt="app展示"></p><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flutter 1.0.0 • channel stable • https:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;flutter.git</span><br><span class="line">Framework • revision 5391447fae (9 weeks ago) • 2018-11-29 19:41:26 -0800</span><br><span class="line">Engine • revision 7375a0f414</span><br><span class="line">Tools • Dart 2.1.0 (build 2.1.0-dev.9.4 f9ebf21297)</span><br></pre></td></tr></table></figure><h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><ol><li><p>克隆代码</p><p>源码地址：<a href="https://github.com/MeandNi/Flutter_ZhiHu" target="_blank" rel="noopener">https://github.com/MeandNi/Flutter_ZhiHu</a></p></li><li><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter packages get</span><br></pre></td></tr></table></figure></li></ol><h4 id="UI-大致结构"><a href="#UI-大致结构" class="headerlink" title="UI 大致结构"></a>UI 大致结构</h4><p><img src="/images/common.png" alt=""></p><p>采用类似 Android 模块化思想，将整个 App 的内容分为5个部分.</p><p><img src="/images/common2.png" alt=""></p><h4 id="Ui-细节"><a href="#Ui-细节" class="headerlink" title="Ui 细节"></a>Ui 细节</h4><p>暂不叙述，项目目前还在更新完善中，预计使用Redux、Sqlflite等技术栈填充数据部分，本项目部分界面及工具类来自<a href="https://github.com/MeandNi/Flutter_CommonApp" target="_blank" rel="noopener">Flutter_CommonApp</a> 。</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p><img src="/images/recommend.png" alt=""></p><p><img src="/images/idea.png" alt=""></p><p><img src="/images/question.png" alt=""></p><p>结构图壕无专业性可言，仅供观赏😀。</p><h4 id="第三方框架"><a href="#第三方框架" class="headerlink" title="第三方框架"></a>第三方框架</h4><div class="table-container"><table><thead><tr><th>库</th><th>功能</th></tr></thead><tbody><tr><td><strong>dio</strong></td><td><strong>网络框架</strong></td></tr><tr><td><strong>carousel_slider</strong></td><td><strong>轮播图</strong></td></tr><tr><td><strong>cached_network_image</strong></td><td><strong>图片加载</strong></td></tr><tr><td><strong>share</strong></td><td><strong>链接分享</strong></td></tr><tr><td><strong>flutter_webview_plugin</strong></td><td><strong>WebView</strong></td></tr></tbody></table></div><h4 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h4><p>感谢那些热爱开源、一起奋斗的朋友们。</p><p>值得学习请Star啊^_^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Flutter实践之知乎App&quot;&gt;&lt;a href=&quot;#Flutter实践之知乎App&quot; class=&quot;headerlink&quot; title=&quot;Flutter实践之知乎App&quot;&gt;&lt;/a&gt;Flutter实践之知乎App&lt;/h2&gt;&lt;p&gt;预览图：&lt;/p&gt;
&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="Flutter" scheme="https://meandni.com/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】Flutter进阶：在应用中实现 Hero(飞行) 动画</title>
    <link href="https://meandni.com/2019/01/27/flutter-hero/"/>
    <id>https://meandni.com/2019/01/27/flutter-hero/</id>
    <published>2019-01-27T12:12:07.000Z</published>
    <updated>2020-10-18T07:51:36.244Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>标题</th><th>链接</th></tr></thead><tbody><tr><td>Flutter进阶：深入探究 ListView 和 ScrollPhysics</td><td><a href="https://juejin.im/post/5c4c202df265da615064ce4b" target="_blank" rel="noopener">https://juejin.im/post/5c4c202df265da615064ce4b</a></td></tr><tr><td>Flutter进阶：深入探究 TextField</td><td><a href="https://juejin.im/post/5c4c4e22f265da6174652fb4" target="_blank" rel="noopener">https://juejin.im/post/5c4c4e22f265da6174652fb4</a></td></tr></tbody></table></div><h2 id="hero-动画介绍"><a href="#hero-动画介绍" class="headerlink" title="hero 动画介绍"></a>hero 动画介绍</h2><p>Hero 指的是可以在路由(页面)之间“飞行”的 widget，从一个页面打开另一个页面时产生一个简单的过渡动画，看下图实例：</p><p><img src="/images/hero1.gif" alt=""></p><center><img width="384px" height="640"  src="/images/hero2.gif"></center><p>Hero Animations 采用类似图标的 widget ，称为“hero”，一旦触发页面过渡，例如通过单击图标，hero 将会“飞”到下一页。 当用户导航回到上一页面时，也将实现原路返回的动画。</p><p>更多介绍，请看<a href="https://flutter.io/docs/development/ui/animations/hero-animations" target="_blank" rel="noopener">官网</a>。</p><p>这里我们不仅学习如何使用 hero 动画，也将会自定义一些我们自己实现的动画。</p><h2 id="构建一个普通的-hero-动画"><a href="#构建一个普通的-hero-动画" class="headerlink" title="构建一个普通的 hero 动画"></a>构建一个普通的 hero 动画</h2><p>hero 动画允许我们在 Flutter 中用最简单的方式实现漂亮动画，无需太多设置。 在上面的例子中，我们可以看到两个页面上都存在相同的图标或者图片。 我们需要做的只是 <strong>让这两者以某种方式相关联</strong>。</p><p>要实现它，我们可以通过在 Hero 组件中包含图标之类的组件。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">  child: Icon(</span><br><span class="line">    Icons.add,</span><br><span class="line">    size: <span class="number">70.0</span>,</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>我们需要设置了一个 tag 参数，给这个  hero 一个独立的名字（类比 Android 中的 ID），因为如果我们在同一页面上有多个 hero ，每个 hero 都需要知道它们将飞往何处且在各不相同的地方。</p><p>现在应用程序有一个 hero 组件想要飞到下一页。接下来就是要告诉它将要飞向何处。</p><p>我们仅需要在第二页上添加带有相同标签的Hero小部件就可实现这个效果。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">  child: Icon(</span><br><span class="line">    Icons.add,</span><br><span class="line">    size: <span class="number">150.0</span>,</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>实例如下：</p><p><img src="/images/hero3.gif" alt=""></p><h2 id="自定义-hero-动画"><a href="#自定义-hero-动画" class="headerlink" title="自定义 hero 动画"></a>自定义 hero 动画</h2><p>Hero 组件允许我们自定义各种过渡效果。 有以下几种方法。</p><h3 id="添加占位符"><a href="#添加占位符" class="headerlink" title="添加占位符"></a>添加占位符</h3><p>在组件飞离它曾经处于的位置并且到达目标位置之前，目标处有一处空的地方。 我们可以在此位置添加<strong>占位符</strong>。</p><p>我们现在使用 CircularProgressIndicator 作为占位符。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Hero(</span><br><span class="line">    tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">    child: Icon(</span><br><span class="line">      Icons.add,</span><br><span class="line">      size: <span class="number">150.0</span>,</span><br><span class="line">    ),</span><br><span class="line">    placeholderBuilder: (context, widget) &#123;</span><br><span class="line">      <span class="keyword">return</span> Container(</span><br><span class="line">        height: <span class="number">150.0</span>,</span><br><span class="line">        width: <span class="number">150.0</span>,</span><br><span class="line">        child: CircularProgressIndicator(),</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure><p>我们使用 placeholderBuilder 来构造占位符并返回我们希望作为占位符的组件。</p><p>使用占位符：</p><p><img src="/images/hero4.gif" alt=""></p><h3 id="更改-hero-组件"><a href="#更改-hero-组件" class="headerlink" title="更改 hero 组件"></a>更改 hero 组件</h3><p>Flutter 允许我们更改从一个页面飞到另一个页面过程的组件，而无需更改两个页面上的组件。</p><p>让我们<strong>在不更改 hero 组件的子组件的前提下</strong>，使用火箭图标“飞”而不是 “+” 图标 。</p><p><img src="/images/hero5.gif" alt=""></p><p>我们使用 <strong>flightShuttleBuilder</strong> 参数执行此操作。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">  child: Icon(</span><br><span class="line">    Icons.add,</span><br><span class="line">    size: <span class="number">150.0</span>,</span><br><span class="line">  ),</span><br><span class="line">  flightShuttleBuilder: (flightContext, animation, direction,</span><br><span class="line">      fromContext, toContext) &#123;</span><br><span class="line">    <span class="keyword">return</span> Icon(FontAwesomeIcons.rocket, size: <span class="number">150.0</span>,);</span><br><span class="line">  &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>flightShuttleBuilder 有5个参数，用来设置动画以及动画的方向。</p><p>目前，两个方向的火箭图标大小都保持在 150.0 。 通过使用方法的 direction 参数，我们可以为每个方向配置不同的配置。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(direction == HeroFlightDirection.push) &#123;</span><br><span class="line">  <span class="keyword">return</span> Icon(</span><br><span class="line">    FontAwesomeIcons.rocket,</span><br><span class="line">    size: <span class="number">150.0</span>,</span><br><span class="line">  );</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == HeroFlightDirection.pop)&#123;</span><br><span class="line">  <span class="keyword">return</span> Icon(</span><br><span class="line">    FontAwesomeIcons.rocket,</span><br><span class="line">    size: <span class="number">70.0</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/hero6.gif" alt=""></p><h3 id="使-hero-动画可以支持-iOS-返回滑动手势"><a href="#使-hero-动画可以支持-iOS-返回滑动手势" class="headerlink" title="使 hero 动画可以支持 iOS 返回滑动手势"></a>使 hero 动画可以支持 iOS 返回滑动手势</h3><p>默认情况下，当在 iOS 上按后退按钮时，hero 动画会有效果，但它们在手势滑动时并没有。</p><p><strong>使用返回按钮：</strong></p><p><img src="/images/hero7.gif" alt=""></p><p><strong>使用滑动手势</strong></p><p><img src="/images/hero8.gif" alt=""></p><p>要解决此问题，只需在两个 Hero 组件上将 transitionOnUserGestures 设置为 true 即可。 默认情况下这里是 false。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Hero(</span><br><span class="line">  tag: <span class="string">"DemoTag"</span>,</span><br><span class="line">  child: Icon(</span><br><span class="line">    Icons.add,</span><br><span class="line">  ),</span><br><span class="line">  transitionOnUserGestures: <span class="keyword">true</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/images/hero9.gif" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>利用时间整理分析自己所学的知识是件非常有意义的事情，希望这也能帮到其他正在学习的同学。同时我也正在用Flutter写几个项目，写好之后就会开源给大家。</p><p>Github：<a href="https://github.com/MeandNi" target="_blank" rel="noopener">https://github.com/MeandNi</a></p><p>欢迎一起交流移动开发的技术！</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://flutter.io/docs/development/ui/animations/hero-animations" target="_blank" rel="noopener">https://flutter.io/docs/development/ui/animations/hero-animations</a></p><p><a href="https://medium.com/flutter-community/a-deep-dive-into-hero-widgets-in-flutter-d34f441eb026" target="_blank" rel="noopener">https://medium.com/flutter-community/a-deep-dive-into-hero-widgets-in-flutter-d34f441eb026</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标题&lt;/th&gt;
&lt;th&gt;链接&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Flutter进阶：深入探究 ListView 和 ScrollP
      
    
    </summary>
    
      <category term="Flutter" scheme="https://meandni.com/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】Flutter进阶：深入探究 TextField</title>
    <link href="https://meandni.com/2019/01/26/flutter-exploring-textfield/"/>
    <id>https://meandni.com/2019/01/26/flutter-exploring-textfield/</id>
    <published>2019-01-26T07:34:32.000Z</published>
    <updated>2020-10-18T07:52:13.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TextField-介绍"><a href="#TextField-介绍" class="headerlink" title="TextField 介绍"></a>TextField 介绍</h2><p>TextField 组件可以让用户填写信息。 TextField 的代码非常简单：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TextField()</span><br></pre></td></tr></table></figure><p><img src="/images/textfield1.png" alt=""></p><h2 id="从TextField中检索信息"><a href="#从TextField中检索信息" class="headerlink" title="从TextField中检索信息"></a>从TextField中检索信息</h2><p>由于 TextFields 组件没有像 Android 中那样的 ID，因此无法根据需要检索文本，而必须在更改时将其存储在变量中或使用控制器。</p><ol><li><p>最简单的方法是使用 onChanged 方法并将当前值存储在一个变量中。示例代码如下：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> value = <span class="string">""</span>;</span><br><span class="line">TextField(</span><br><span class="line">  onChanged: (text) &#123;</span><br><span class="line">    value = text;</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>第二种方法是使用 TextEditingController 。 控制器连接到 TextField ，让我们也可以监听和控制 TextField 的内容。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextEditingController controller = TextEditingController();</span><br><span class="line">TextField(</span><br><span class="line">  controller: controller,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们可以这样监听变化</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">controller.addListener(() &#123;</span><br><span class="line">  <span class="comment">// Do something here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>获取、设置文本内容：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(controller.text); <span class="comment">// Print current value</span></span><br><span class="line">controller.text = <span class="string">"Demo Text"</span>; <span class="comment">// Set new value</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="TextField-中其他的回调"><a href="#TextField-中其他的回调" class="headerlink" title="TextField 中其他的回调"></a>TextField 中其他的回调</h2><p>TextField 组件还提供其他回调，例如：</p><ol><li>onEditingCompleted</li><li>onSubmitted</li></ol><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onEditingComplete: () &#123;&#125;,</span><br><span class="line">onSubmitted: (value) &#123;&#125;,</span><br></pre></td></tr></table></figure><p>这些是在用户单击 iOS 上的“完成”按钮时调用的回调。</p><h2 id="在-TextField-中使用焦点"><a href="#在-TextField-中使用焦点" class="headerlink" title="在 TextField 中使用焦点"></a>在 TextField 中使用焦点</h2><p>在 TextField 上“聚焦”意味着激活 TextField ，键盘的任何输入都将导致在聚焦的 TextField 中输入数据。</p><h3 id="1-使其自动聚焦"><a href="#1-使其自动聚焦" class="headerlink" title="1. 使其自动聚焦"></a>1. 使其自动聚焦</h3><p>要在创建窗口时在 TextField 上自动对焦，请将自动对焦字段设置为 true 。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  autofocus: <span class="keyword">true</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>默认情况下，这会将焦点设置在 TextField 上。</p><p><img src="/images/textfield2.gif" alt=""></p><h3 id="2-自定义更改焦点"><a href="#2-自定义更改焦点" class="headerlink" title="2.自定义更改焦点"></a>2.自定义更改焦点</h3><p>如果我们想要改变焦点而不仅仅是自动对焦怎么办？ 看下面代码 ，我们将 FocusNode 附加到 TextField 并使用它来切换焦点。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialise outside the build method</span></span><br><span class="line">FocusNode nodeOne = FocusNode();</span><br><span class="line">FocusNode nodeTwo = FocusNode();</span><br><span class="line"><span class="comment">// Do this inside the build method</span></span><br><span class="line">TextField(</span><br><span class="line">  focusNode: nodeOne,</span><br><span class="line">),</span><br><span class="line">TextField(</span><br><span class="line">  focusNode: nodeTwo,</span><br><span class="line">),</span><br><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    FocusScope.of(context).requestFocus(nodeTwo);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">"Next Field"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>我们创建两个焦点节点并将它们附加到 TextFields 。 按下按钮时，我们使用 FocusScope 请求焦点到下一个TextField。</p><p><img src="/images/textfield3.gif" alt=""></p><h2 id="更改-TextFields-的键盘属性"><a href="#更改-TextFields-的键盘属性" class="headerlink" title="更改 TextFields 的键盘属性"></a>更改 TextFields 的键盘属性</h2><p>Flutter 中的 TextField 允许我们自定义与键盘相关的属性。</p><h3 id="1-键盘类型"><a href="#1-键盘类型" class="headerlink" title="1.键盘类型"></a>1.键盘类型</h3><p>TextField 允许您自定义在 TextField 成为焦点时显示的键盘类型。 我们更改 keyboardType 属性。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  keyboardType: TextInputType.number,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>类型有：</p><ol><li><strong>TextInputType.text</strong> (普通全键盘)</li><li><strong>TextInputType.number</strong> (数字键盘)</li><li><strong>TextInputType.emailAddress</strong> (普通键盘，带有“@”符号)</li><li><strong>TextInputType.datetime</strong> (数字键盘，带有 “/” 和  “:” 符号)</li><li><strong>TextInputType.multiline</strong> (数字键盘，带有启用有符号和十进制模式的选项)</li></ol><h3 id="2-TextInputAction"><a href="#2-TextInputAction" class="headerlink" title="2.TextInputAction"></a>2.TextInputAction</h3><p>更改 TextField 的 textInputAction 可以更改键盘本身的操作按钮。</p><p>例如：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textInputAction: TextInputAction.continueAction,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>这会导致 “Done” 按钮被 “Continue” 按钮替换：</p><p><img src="/images/textfield4.png" alt=""></p><p>或者：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textInputAction: TextInputAction.send,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield5.png" alt=""></p><p>还有很多类型，这里不一一列举。</p><h3 id="3-自动更正"><a href="#3-自动更正" class="headerlink" title="3.自动更正"></a>3.自动更正</h3><p>启用或禁用特定 TextField 的自动更正。 使用自动更正字段进行如下设置。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  autocorrect: <span class="keyword">false</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>这将禁用更正。</p><h3 id="4-文本大写"><a href="#4-文本大写" class="headerlink" title="4.文本大写"></a>4.文本大写</h3><p>TextField 提供了一些有关如何使用户输入中的字母大写的选项。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textCapitalization: TextCapitalization.sentences,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>选项有：</p><ol><li><p><strong>TextCapitalization.sentences</strong></p><p>这可以使每个句子的首字母大写。</p><p><img src="/images/textfield6.png" alt=""></p></li><li><p><strong>TextCapitalization.characters</strong></p><p>大写句子中的所有字符。</p><p><img src="/images/textfield7.png" alt=""></p></li><li><p><strong>TextCapitalization.words</strong></p><p>大写每个单词的首字母。</p><p><img src="/images/textfield8.png" alt=""></p><h2 id="Text-Style-Alignment-和-Cursor"><a href="#Text-Style-Alignment-和-Cursor" class="headerlink" title="Text Style, Alignment 和 Cursor"></a>Text Style, Alignment 和 Cursor</h2></li></ol><p>Flutter 允许自定义 TextField 内的文本样式和对齐方式以及 TextField 内的光标。</p><h3 id="TextField-内的文本对齐方式"><a href="#TextField-内的文本对齐方式" class="headerlink" title="TextField 内的文本对齐方式"></a>TextField 内的文本对齐方式</h3><p>使用 textAlign 属性调整 TextField 中光标的位置。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  textAlign: TextAlign.center,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield9.png" alt=""></p><p>通常的对齐属性有：<strong>start, end, left, right, center, justify</strong>.</p><h3 id="在-TextField-中设置文本样式"><a href="#在-TextField-中设置文本样式" class="headerlink" title="在 TextField 中设置文本样式"></a>在 TextField 中设置文本样式</h3><p>我们使用 style 属性来更改 TextField 内部文本的样式。 使用它来更改颜色，字体大小等。这类似于文本组件中的样式属性，这里我们不多做介绍。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  style: TextStyle(color: Colors.red, fontWeight: FontWeight.w300),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield10.png" alt=""></p><h3 id="更改-TextField-中的光标"><a href="#更改-TextField-中的光标" class="headerlink" title="更改 TextField 中的光标"></a>更改 TextField 中的光标</h3><p>可以直接自定义 TextField 组件的光标。</p><p>您可以更改光标颜色，宽度和半径。 例如，在这里我自定义了一个圆形红色光标。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  cursorColor: Colors.red,</span><br><span class="line">  cursorRadius: Radius.circular(<span class="number">16.0</span>),</span><br><span class="line">  cursorWidth: <span class="number">16.0</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield11.png" alt=""></p><h3 id="控制-TextField-中的大小和最大长度"><a href="#控制-TextField-中的大小和最大长度" class="headerlink" title="控制 TextField 中的大小和最大长度"></a>控制 TextField 中的大小和最大长度</h3><p>TextFields 可以控制其中写入的最大字符数、最大行数并在键入文本时展开。</p><h4 id="控制最大字符数"><a href="#控制最大字符数" class="headerlink" title="控制最大字符数"></a>控制最大字符数</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  maxLength: <span class="number">4</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield12.png" alt=""></p><p>通过设置 maxLength 属性，将强制执行最大长度，并且默认情况下会将计数器添加到 TextField 。</p><h4 id="制作可扩展的TextField"><a href="#制作可扩展的TextField" class="headerlink" title="制作可扩展的TextField"></a>制作可扩展的TextField</h4><p>有时，我们需要 TextField 当一行完成时会扩展。 在Flutter中，做法有点奇怪（但很容易）。 我们将 maxLines 设置为 null ，默认为1。 </p><p><img src="/images/textfield13.png" alt=""></p><p><strong>注意：默认情况下，将 maxLines 设置为直接值会将其自动扩展为该行数。</strong></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  maxLines: <span class="number">3</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/images/textfield14.png" alt=""></p><h4 id="模糊文字"><a href="#模糊文字" class="headerlink" title="模糊文字"></a>模糊文字</h4><p>要隐藏 TextField 中的文本，请将 obscureText 设置为true 。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  obscureText: <span class="keyword">true</span>,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield15.png" alt=""></p><h2 id="装饰-TextField"><a href="#装饰-TextField" class="headerlink" title="装饰 TextField"></a>装饰 TextField</h2><p>至此，我们专注于 Flutter 提供的输入功能。 现在我们来实际设计一个漂亮的 TextField 。</p><p>为了装饰 TextField，我们使用了带有 InputDecoration 的 decoration 属性。 由于 InputDecoration 类非常庞大，我们快速过一遍它的重要属性。</p><h3 id="使用提示和标签属性向用户提供信息"><a href="#使用提示和标签属性向用户提供信息" class="headerlink" title="使用提示和标签属性向用户提供信息"></a>使用提示和标签属性向用户提供信息</h3><p>提示和标签都是字符串，可帮助用户理解要在 TextField 中输入的信息。 不同之处在于，当标签浮动在 TextField上时，一旦用户开始输入，提示就会消失。</p><p><img src="/images/textfield16.png" alt="Hint"></p><p><img src="/images/textfield17.png" alt="Label"></p><h3 id="您可以使用-“icon”，“prefixIcon”-和-“suffixIcon”-添加图标"><a href="#您可以使用-“icon”，“prefixIcon”-和-“suffixIcon”-添加图标" class="headerlink" title="您可以使用 “icon”，“prefixIcon” 和 “suffixIcon” 添加图标"></a>您可以使用 “icon”，“prefixIcon” 和 “suffixIcon” 添加图标</h3><p>您可以直接向 TextFields 添加图标。 您也可以使用 prefixText 和 suffixText 代替 Text。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    icon: Icon(Icons.<span class="built_in">print</span>)</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield18.png" alt=""></p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    prefixIcon: Icon(Icons.<span class="built_in">print</span>)</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield19.png" alt=""></p><h3 id="对于其他任何组件，使用-“prefix”-而不是-“prefixIcon”"><a href="#对于其他任何组件，使用-“prefix”-而不是-“prefixIcon”" class="headerlink" title="对于其他任何组件，使用 “prefix” 而不是 “prefixIcon”"></a>对于其他任何组件，使用 “prefix” 而不是 “prefixIcon”</h3><p>要使用通用组件而不是仅仅一个图标，请使用 prefix field 。让我们在 TextField 中添加一个圆形进度框。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    prefix: CircularProgressIndicator(),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield20.png" alt=""></p><h3 id="像-hint-，label-等每个属性都有各自的样式字段"><a href="#像-hint-，label-等每个属性都有各自的样式字段" class="headerlink" title="像 hint ，label 等每个属性都有各自的样式字段"></a>像 <strong>hint</strong> ，<strong>label</strong> 等每个属性都有各自的样式字段</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    hintText: <span class="string">"Demo Text"</span>,</span><br><span class="line">    hintStyle: TextStyle(fontWeight: FontWeight.w300, color: Colors.red)</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><strong>注意：虽然我在此示例中这样操作，但通常不会更改提示颜色。</strong></p><h3 id="如果您不想要标签而想要为用户提供持久消息，请使用-“helperText”-。"><a href="#如果您不想要标签而想要为用户提供持久消息，请使用-“helperText”-。" class="headerlink" title="如果您不想要标签而想要为用户提供持久消息，请使用 “helperText” 。"></a>如果您不想要标签而想要为用户提供持久消息，请使用 “helperText” 。</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    helperText: <span class="string">"Hello"</span></span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield21.png" alt=""></p><h3 id="使用-“decoration：null”-或-InputDecoration-collapsed-删除-TextField-上的默认下划线"><a href="#使用-“decoration：null”-或-InputDecoration-collapsed-删除-TextField-上的默认下划线" class="headerlink" title="使用 “decoration：null” 或 InputDecoration.collapsed 删除 TextField 上的默认下划线"></a>使用 “decoration：null” 或 InputDecoration.collapsed 删除 TextField 上的默认下划线</h3><p>使用这些删除 TextField 上的默认下划线。</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration.collapsed(hintText: <span class="string">""</span>)</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield22.png" alt=""></p><h3 id="使用-“border”-为-TextField-设置边框"><a href="#使用-“border”-为-TextField-设置边框" class="headerlink" title="使用 “border” 为 TextField 设置边框"></a>使用 “border” 为 TextField 设置边框</h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">    border: OutlineInputBorder()</span><br><span class="line">  )</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p><img src="/images/textfield23.png" alt=""></p><p>您可以进一步做大量的装饰，我不可能将所有你需要的样式做出来。 但我希望这我已经让你知道怎么将它做出来！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TextField-介绍&quot;&gt;&lt;a href=&quot;#TextField-介绍&quot; class=&quot;headerlink&quot; title=&quot;TextField 介绍&quot;&gt;&lt;/a&gt;TextField 介绍&lt;/h2&gt;&lt;p&gt;TextField 组件可以让用户填写信息。 TextFie
      
    
    </summary>
    
      <category term="Flutter" scheme="https://meandni.com/categories/Flutter/"/>
    
    
      <category term="flutter" scheme="https://meandni.com/tags/flutter/"/>
    
  </entry>
  
</feed>
