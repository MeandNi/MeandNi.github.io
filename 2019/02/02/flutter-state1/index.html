<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Flutter实践：深入 Flutter 的状态管理方式(2)——演化BloC"><meta name="keywords" content="flutter,状态管理"><meta name="author" content="Joker"><meta name="copyright" content="Joker"><title>Flutter实践：深入 Flutter 的状态管理方式(2)——演化BloC | Joker's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何将-Stream-中的数据应用到-Widget？"><span class="toc-number">1.</span> <span class="toc-text">如何将 Stream 中的数据应用到 Widget？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现真正的-BloC"><span class="toc-number">2.</span> <span class="toc-text">实现真正的 BloC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一，BloC-实现了责任分离"><span class="toc-number">2.1.</span> <span class="toc-text">一，BloC 实现了责任分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二，可测试性"><span class="toc-number">2.2.</span> <span class="toc-text">二，可测试性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三，任意组织布局"><span class="toc-number">2.3.</span> <span class="toc-text">三，任意组织布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四，减少-“build”-的数量"><span class="toc-number">2.4.</span> <span class="toc-text">四，减少 “build” 的数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#只有一个约束……-BLoC的可访问性"><span class="toc-number">2.5.</span> <span class="toc-text">只有一个约束…… BLoC的可访问性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BloC-其他你必须知道的事情"><span class="toc-number">3.</span> <span class="toc-text">BloC 其他你必须知道的事情</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可以实现多个-BloC"><span class="toc-number">3.1.</span> <span class="toc-text">可以实现多个 BloC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为何不用-InheritedWidget-来全局管理-BloC-的状态"><span class="toc-number">3.2.</span> <span class="toc-text">为何不用 InheritedWidget 来全局管理 BloC 的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关于使用-InheritedWidget-的提醒"><span class="toc-number">3.3.</span> <span class="toc-text">关于使用 InheritedWidget 的提醒</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考链接"><span class="toc-number">5.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Joker</div><div class="author-info__description text-center">分享生活、技术、学习心得</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Joker's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Flutter实践：深入 Flutter 的状态管理方式(2)——演化BloC</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-02-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Flutter/">Flutter</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>在上篇文章中，我详细介绍了 InheritedWidget 及 ScopedModel 实现原理与方法，有同学说找不到源码，其实上篇文章包括这篇文章里的源码都按步骤放在<a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">样例代码</a>里了，有同学说有点懵，其实上一篇的概念过多而且本身我表达也不是很清晰，英文文档中我也解释的没有完全语义化，所以还请谅解，<strong>结合实际代码你会有更好地理解</strong>。</p>
<a id="more"></a>
<p>这篇的重点我将放在 BloC 的实现上面，我们已经知道 Strems 的概念，RXDart 是依赖 Streams 使用的输入（<em>Sink</em>）和输出（<em>stream</em>）封装而成的响应式库，BloC 基于此便可以实时侦听数据的变化而改变数据，并且，BloC 主要解决的问题就是他不会一刀切的更新整个状态树，它关注的是数据，经过一系列处理后得到它并且只改变应用它的 widget。</p>
<p><img src="/images/flutterstate2.png" alt=""></p>
<h3 id="如何将-Stream-中的数据应用到-Widget？"><a href="#如何将-Stream-中的数据应用到-Widget？" class="headerlink" title="如何将 Stream 中的数据应用到 Widget？"></a>如何将 Stream 中的数据应用到 Widget？</h3><p>我们先来实践一下如何在 widget 中使用数据。Flutter 提供了一个名为 <a href="https://docs.flutter.io/flutter/widgets/StreamBuilder-class.html" target="_blank" rel="noopener">StreamBuilder</a> 的 StatefulWidget。</p>
<p>StreamBuilder 监听 Stream，每当一些数据流出 Stream 时，它会自动重建，调用其构建器回调。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">StreamBuilder&lt;T&gt;(</span><br><span class="line">    key: ...optional, the unique ID of <span class="keyword">this</span> Widget...</span><br><span class="line">    stream: ...the stream to listen to...</span><br><span class="line">    initialData: ...any initial data, <span class="keyword">in</span> <span class="keyword">case</span> the stream would initially be empty...</span><br><span class="line">    builder: (BuildContext context, AsyncSnapshot&lt;T&gt; snapshot)&#123;</span><br><span class="line">        <span class="keyword">if</span> (snapshot.hasData)&#123;</span><br><span class="line">            <span class="keyword">return</span> ...the Widget to be built based <span class="keyword">on</span> snapshot.data</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ...the Widget to be built <span class="keyword">if</span> no data <span class="keyword">is</span> available</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>以下示例使用 Stream 而不是 setState() 模拟默认的“计数器”应用程序：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> StreamController&lt;<span class="built_in">int</span>&gt; _streamController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _streamController.close();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: _streamController.stream,</span><br><span class="line">          initialData: _counter,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          _streamController.sink.add(++_counter);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第24-30行：我们监听流，每次有一个新值流出这个流时，我们用该值更新 Text;</li>
<li>第35行：当我们点击 FloatingActionButton 时，我们递增计数器并通过接收器将其发送到 Stream; 侦听它的 StreamBuilder 注入了该值相应到后重建并“刷新”计数器;</li>
<li>我们不再需要 State，所有东西都可以通过 Stream 接受;</li>
<li>这里实现了相当大的优化，因为调用 setState() 方法会强制整个 Widget（和任何子组件）重新渲染。 而在这里，只重建 StreamBuilder（当然还有其子组件）;</li>
<li>我们仍需要使用 StatefulWidget 的唯一原因，仅仅是因为我们需要通过 dispose 方法第15行释放StreamController;</li>
</ul>
<h3 id="实现真正的-BloC"><a href="#实现真正的-BloC" class="headerlink" title="实现真正的 BloC"></a>实现真正的 BloC</h3><p>是时候展现真正的计技术了，我们依然将 BloC 用于默认的计数器应用中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">          primarySwatch: Colors.blue,</span><br><span class="line">        ),</span><br><span class="line">        home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">          bloc: IncrementBloc(),</span><br><span class="line">          child: CounterPage(),</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">'Stream version of the Counter App'</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: StreamBuilder&lt;<span class="built_in">int</span>&gt;(</span><br><span class="line">          stream: bloc.outCounter,</span><br><span class="line">          initialData: <span class="number">0</span>,</span><br><span class="line">          builder: (BuildContext context, AsyncSnapshot&lt;<span class="built_in">int</span>&gt; snapshot)&#123;</span><br><span class="line">            <span class="keyword">return</span> Text(<span class="string">'You hit me: <span class="subst">$&#123;snapshot.data&#125;</span> times'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        child: <span class="keyword">const</span> Icon(Icons.add),</span><br><span class="line">        onPressed: ()&#123;</span><br><span class="line">          bloc.incrementCounter.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IncrementBloc</span> <span class="keyword">implements</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController&lt;<span class="built_in">int</span>&gt; _counterController = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  StreamSink&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> _inAdd =&gt; _counterController.sink;</span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> outCounter =&gt; _counterController.stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Stream to handle the action on the counter</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  StreamController _actionController = StreamController();</span><br><span class="line">  StreamSink <span class="keyword">get</span> incrementCounter =&gt; _actionController.sink;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Constructor</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  IncrementBloc()&#123;</span><br><span class="line">    _counter = <span class="number">0</span>;</span><br><span class="line">    _actionController.stream</span><br><span class="line">                     .listen(_handleLogic);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    _actionController.close();</span><br><span class="line">    _counterController.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleLogic(data)&#123;</span><br><span class="line">    _counter = _counter + <span class="number">1</span>;</span><br><span class="line">    _inAdd.add(_counter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是上篇文章的最后给打大家制造悬念的代码？五脏俱全，基本已经实现了 BloC。</p>
<p>结合上面的例子来分析 BloC 体现出来的优势：（建议先将<a href="https://github.com/MeandNi/Flutter_StatePro/blob/master/lib/bloc_counter/main.dart" target="_blank" rel="noopener">这段代码</a>跑起来！）</p>
<h4 id="一，BloC-实现了责任分离"><a href="#一，BloC-实现了责任分离" class="headerlink" title="一，BloC 实现了责任分离"></a>一，BloC 实现了责任分离</h4><p>你可以看到 CounterPage（第21-45行），其中没有任何业务逻辑。</p>
<p>它承担的负责仅有：</p>
<ul>
<li>显示计数器，现在只在必要时更新</li>
<li>提供一个按钮，当按下时，请求执行动作</li>
</ul>
<p>此外，整个业务逻辑集中在一个单独的类“IncrementBloc”中。</p>
<p>如果现在，如果我们需要更改业务逻辑，只需更新方法 _handleLogic（第77-80行）。 也许新的业务逻辑将要求做非常复杂的事情…… CounterPage 永远与它无关！</p>
<h4 id="二，可测试性"><a href="#二，可测试性" class="headerlink" title="二，可测试性"></a>二，可测试性</h4><p>现在，测试业务逻辑也变得更加容易。</p>
<p>无需再通过用户界面测试业务逻辑。 只需要测试 IncrementBloc 类。</p>
<h4 id="三，任意组织布局"><a href="#三，任意组织布局" class="headerlink" title="三，任意组织布局"></a>三，任意组织布局</h4><p>由于使用了 Streams，您现在可以独立于业务逻辑组织布局。</p>
<p>你可以从应用程序中的任何位置用任何操作：只需调用 <em>.incrementCounter</em> 接收器即可。</p>
<p>您可以在任何页面的任何位置显示计数器，只需舰艇监听 .outCounter 流。</p>
<h4 id="四，减少-“build”-的数量"><a href="#四，减少-“build”-的数量" class="headerlink" title="四，减少 “build” 的数量"></a>四，减少 “build” 的数量</h4><p>不用 <code>setState()</code>而是使用 StreamBuilder，从而大大减少了“构建”的数量，只减少了所需的数量。</p>
<p>这是性能上的巨提高！</p>
<h4 id="只有一个约束……-BLoC的可访问性"><a href="#只有一个约束……-BLoC的可访问性" class="headerlink" title="只有一个约束…… BLoC的可访问性"></a>只有一个约束…… BLoC的可访问性</h4><p>为了达到各种目的，BLoC 需要可访问。</p>
<p>有以下几种方法可以访问它：</p>
<ul>
<li><p>通过全局单例的变量</p>
<p>这种方式很容易实现，但不推荐。 此外，由于 Dart 中没有类析构函数，因此我们永远无法正确释放资源。</p>
</li>
<li><p>作为本地实例</p>
<p>您可以实例化 BLoC 的本地实例。 在某些情况下，此解决方案完全符合需求。 在这种情况下，您应该始终考虑在 StatefulWidget 中初始化，以便您可以利用 dispose() 方法来释放它。</p>
</li>
<li><p>由根组件提供<br>使其可访问的最常见方式是通过根 Widget，将其实现为 StatefulWidget。</p>
<p>以下代码给出了一个通用 BlocProvider 的示例：（这个例子牛逼！）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generic Interface for all BLoCs</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BlocBase</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> dispose();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generic BLoC provider</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlocProvider</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">BlocBase</span>&gt; <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  BlocProvider(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.bloc,</span><br><span class="line">  &#125;): <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> T bloc;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> T of&lt;T <span class="keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;();</span><br><span class="line">    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type);</span><br><span class="line">    <span class="keyword">return</span> provider.bloc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BlocProviderState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">BlocProvider</span>&lt;<span class="title">BlocBase</span>&gt;&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose()&#123;</span><br><span class="line">    widget.bloc.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> widget.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这段通用的 <em>BlocProvider</em> 仔细回味，你会发现其精妙之处！</p>
<p>通用 <em>BlocProvider</em> 的一些解释：</p>
<p>首先，如何将其用作数据提供者？</p>
<p>如果你看了上面<a href="https://gist.github.com/MeandNi/1161560bf90c5bc7f341844e8126a8f4" target="_blank" rel="noopener">BloC 计数器的示例代码</a>示例代码，您将看到以下代码行（第12-15行）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">         bloc: IncrementBloc(),</span><br><span class="line">         child: CounterPage(),</span><br><span class="line">       ),</span><br></pre></td></tr></table></figure>
<p>使用以上代码，我们实例化了一个想要处理 <em>IncrementBloc</em> 的新 <em>BlocProvider</em>，并将 <em>CounterPage</em> 呈现为子组件。</p>
<p>从 <em>BlocProvider</em> 开始的子组件的任何组件部分都将能够通过以下行访问 <em>IncrementBloc</em>：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">IncrementBloc bloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>BLoC 的基本使用就介绍完了，所有<a href="https://github.com/MeandNi/Flutter_StatePro" target="_blank" rel="noopener">实例代码在这里</a> ，我将每种状态管理的方法分模块放在里面，选择使用哪种方式运行代码即可。</p>
<h3 id="BloC-其他你必须知道的事情"><a href="#BloC-其他你必须知道的事情" class="headerlink" title="BloC 其他你必须知道的事情"></a>BloC 其他你必须知道的事情</h3><h4 id="可以实现多个-BloC"><a href="#可以实现多个-BloC" class="headerlink" title="可以实现多个 BloC"></a>可以实现多个 BloC</h4><p>在大型项目中，这是非常可取的。 给以下几个建议：</p>
<ul>
<li>（如果有任何业务逻辑）每页顶部有一个BLoC，</li>
<li>用一个 ApplicationBloc 来处理应用程序所有状态</li>
<li>每个“足够复杂的组件”都有相应的BLoC。</li>
</ul>
<p>以下示例代码在整个应用程序的顶部使用 <em>ApplicationBloc</em>，然后在 <em>CounterPage</em> 顶部使用 <em>IncrementBloc</em>。该示例还展示了如何使用两个 Bloc：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(</span><br><span class="line">  BlocProvider&lt;ApplicationBloc&gt;(</span><br><span class="line">    bloc: ApplicationBloc(),</span><br><span class="line">    child: MyApp(),</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">'Streams Demo'</span>,</span><br><span class="line">      home: BlocProvider&lt;IncrementBloc&gt;(</span><br><span class="line">        bloc: IncrementBloc(),</span><br><span class="line">        child: CounterPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">final</span> IncrementBloc counterBloc = BlocProvider.of&lt;IncrementBloc&gt;(context);</span><br><span class="line">    <span class="keyword">final</span> ApplicationBloc appBloc = BlocProvider.of&lt;ApplicationBloc&gt;(context);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为何不用-InheritedWidget-来全局管理-BloC-的状态"><a href="#为何不用-InheritedWidget-来全局管理-BloC-的状态" class="headerlink" title="为何不用 InheritedWidget 来全局管理 BloC 的状态"></a>为何不用 InheritedWidget 来全局管理 BloC 的状态</h4><p>我为此也整理了一个将 BLoC 结合 InheritedWidget 使用的示例：</p>
<p>在很多与 BLoC 相关的文章中，您将看到 <em>Provider</em> 的实现其实是一个 <em>InheritedWidget</em>。</p>
<p>当然，  这是完全可以实现的，然而，</p>
<ul>
<li>一个 <em>InheritedWidget</em> 没有提供任何 <em>dispose</em> 方法，记住，在不再需要资源时总是释放资源是一个很好的做法。</li>
<li>当然，你也可以将 <em>InheritedWidget</em> 包装在另一个 <em>StatefulWidget</em> 中，但是，乍样使用 <em>InheritedWidget</em> 并没有什么便利之处！</li>
<li>最后，如果不受控制，使用 <em>InheritedWidget</em> 经常会导致一些副作用（请参阅下面的  <em>InheritedWidget</em> 上的提醒）。</li>
</ul>
<p>这 3 点解释了我为何将通用 BlocProvider 实现为 StatefulWidget，这样我就可以<strong>释放资源</strong>。</p>
<blockquote>
<p>Flutter无法实例化泛型类型</p>
<p>不幸的是，Flutter 无法实例化泛型类型，我们必须将 BLoC 的实例传递给 BlocProvider。 为了在每个BLoC中强制执行 dispose() 方法，所有BLoC都必须实现 BlocBase 接口。</p>
</blockquote>
<h4 id="关于使用-InheritedWidget-的提醒"><a href="#关于使用-InheritedWidget-的提醒" class="headerlink" title="关于使用 InheritedWidget 的提醒"></a>关于使用 InheritedWidget 的提醒</h4><p>在使用 <em>InheritedWidget</em> 并通过 <em>context.inheritFromWidgetOfExactType(…)</em> 获取指定类型最近的 <em>Widget</em> 时，每当InheritedWidget 的父级或者子布局发生变化时，这个方法会自动将当前 “<em>context</em>”（= <em>BuildContext</em>）注册到要重建的 <em>widget</em> 当中。</p>
<blockquote>
<p>请注意，为了完全正确，我刚才解释的与 <em>InheritedWidget</em> 相关的问题只发生在我们将 <em>InheritedWidget</em> 与 <em>StatefulWidget</em> 结合使用时。 当您只使用没有 State 的 InheritedWidget 时，问题就不会发生。 </p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flutter 状态管理的这几种模式同样可以适用于很多软件开发中，而 BloC 模式最初的设想是实现允许独立于平台重用相同的代码！因此多花时间学习这类模式便是软件开发的根基。</p>
<p>我的建议是将<strong>实例代码运行出来阅读代码</strong>，依靠文章理解！希望能帮助到你！</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>这篇内容是我反复看完 <a href="https://www.youtube.com/watch?v=RS36gBEp8OI&amp;index=115&amp;list=PLOU2XLYxmsIInFRc3M44HUTQc3b_YJ4-Y" target="_blank" rel="noopener">Build reactive mobile apps with Flutter (Google I/O ‘18)</a> 谷歌大会写完的。</p>
<p>并且大量借鉴了 <a href="https://www.didierboelens.com/2018/08/reactive-programming---streams---bloc/" target="_blank" rel="noopener">Reactive Programming - Streams - BLoC</a> 这篇文章。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Joker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://meandni.com/2019/02/02/flutter-state1/">https://meandni.com/2019/02/02/flutter-state1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/flutter/">flutter</a><a class="post-meta__tags" href="/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">状态管理</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/02/09/flutter-state3/"><i class="fa fa-chevron-left">  </i><span>Flutter实践：深入 Flutter 的状态管理方式(3)——Redux与旅途小结</span></a></div><div class="next-post pull-right"><a href="/2019/01/30/flutter-state1/"><span>Flutter实践：深入探索 Flutter 中的状态管理方式(1)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '12faa9d04b92d2d70968',
  clientSecret: 'ad1023eebffeb2972301ce0e730e0c277f64cf23',
  repo: 'MeandNi.github.io',
  owner: 'MeandNi',
  admin: 'MeandNi',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Joker</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>