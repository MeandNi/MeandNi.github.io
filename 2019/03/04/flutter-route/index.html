<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Flutter进阶：路由、路由栈详解及案例分析"><meta name="keywords" content="flutter"><meta name="author" content="Joker"><meta name="copyright" content="Joker"><title>Flutter进阶：路由、路由栈详解及案例分析 | Joker's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#路由初体验"><span class="toc-number">1.</span> <span class="toc-text">路由初体验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#组件路由"><span class="toc-number">1.1.</span> <span class="toc-text">组件路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命名路由"><span class="toc-number">1.2.</span> <span class="toc-text">命名路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pop"><span class="toc-number">1.3.</span> <span class="toc-text">Pop</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#详解路由栈"><span class="toc-number">2.</span> <span class="toc-text">详解路由栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pushReplacementNamed-与-popAndPushNamed"><span class="toc-number">2.1.</span> <span class="toc-text">pushReplacementNamed 与 popAndPushNamed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pushNamedAndRemoveUntil"><span class="toc-number">2.2.</span> <span class="toc-text">pushNamedAndRemoveUntil</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#popUntil"><span class="toc-number">2.3.</span> <span class="toc-text">popUntil</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Popup-routes（弹出路由）"><span class="toc-number">2.4.</span> <span class="toc-text">Popup routes（弹出路由）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义路由"><span class="toc-number">2.5.</span> <span class="toc-text">自定义路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#嵌套路由"><span class="toc-number">2.6.</span> <span class="toc-text">嵌套路由</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#页面间数据传递"><span class="toc-number">3.</span> <span class="toc-text">页面间数据传递</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据传递"><span class="toc-number">3.1.</span> <span class="toc-text">数据传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据返回"><span class="toc-number">3.2.</span> <span class="toc-text">数据返回</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他效果解释"><span class="toc-number">4.</span> <span class="toc-text">其他效果解释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#maybePop"><span class="toc-number">4.1.</span> <span class="toc-text">maybePop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#canPop"><span class="toc-number">4.2.</span> <span class="toc-text">canPop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何去除默认返回按钮"><span class="toc-number">4.3.</span> <span class="toc-text">如何去除默认返回按钮</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考链接"><span class="toc-number">5.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Joker</div><div class="author-info__description text-center">分享生活、技术、学习心得</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">35</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Joker's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Flutter进阶：路由、路由栈详解及案例分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-03-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Flutter/">Flutter</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="路由初体验"><a href="#路由初体验" class="headerlink" title="路由初体验"></a>路由初体验</h1><p>路由（Routes）是什么？路由是屏幕或应用程序页面的抽象。</p>
<p>Flutter 使我们能够优雅地管理路由主要依赖的是 Navigator（导航器）类。这是一个用于管理一组具有某种进出规则的页面的 Widget，也就是说用它我们能够实现各个页面间有规律的切换。而这里的规则便是在其内部维护的一个“ 路由栈”。</p>
<p>学习 Android 的同学知道 Activity 的启动模式可以实现各种业务需求，iOS 中也有嵌套路由的功能，Flutter 作为最有潜力的跨平台框架当然要吸取众家之精华，它当然完全有能力实现原生的各种效果！</p>
<p>我们先尝试实现一个小的功能。</p>
<a id="more"></a>
<h2 id="组件路由"><a href="#组件路由" class="headerlink" title="组件路由"></a>组件路由</h2><p>当我们第一次打开应用程序，出现在眼前的便是路由栈中的第一个也是最底部实例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(home: Screen1()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要在堆栈上推送新的实例，我们可以调用导航器 <code>Navigator.push</code> ，传入当前 context 并且使用构建器函数创建 MaterialPageRoute 实例，该函数可以创建您想要在屏幕上显示的内容。 例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">   onPressed:()&#123;</span><br><span class="line">   Navigator.push(context, MaterialPageRoute&lt;<span class="keyword">void</span>&gt;(</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> Scaffold(</span><br><span class="line">          appBar: AppBar(title: Text(<span class="string">'My Page'</span>)),</span><br><span class="line">          body: Center(</span><br><span class="line">            child: FlatButton(</span><br><span class="line">              child: Text(<span class="string">'POP'</span>),</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                Navigator.pop(context);</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    ));</span><br><span class="line">   &#125;,</span><br><span class="line">   child: <span class="keyword">new</span> Text(<span class="string">"Push to Screen 2"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>点击执行上方操作，我们将成功打开第二个页面。</p>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>在一般应用中，我们用的最多的还是命名路由，它是将应用中需要访问的每个页面命名为不重复的字符串，我们便可以通过这个字符串来将该页面实例推进路由。</p>
<blockquote>
<p>例如，’/ home’ 表示 HomeScreen， ‘/ login’ 表示 LoginScreen。 ‘/‘ 表示主页面。 这里的命名规范与 REST API 开发中的路由类似。 所以 ‘/‘ 通常表示的是我们的根页面。</p>
</blockquote>
<p>请看下方案例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> MaterialApp(</span><br><span class="line">  home: <span class="keyword">new</span> Screen1(),</span><br><span class="line">  routes: &lt;<span class="built_in">String</span>, WidgetBuilder&gt; &#123;</span><br><span class="line">    <span class="string">'/screen1'</span>: (BuildContext context) =&gt; <span class="keyword">new</span> Screen1(),</span><br><span class="line">    <span class="string">'/screen2'</span> : (BuildContext context) =&gt; <span class="keyword">new</span> Screen2(),</span><br><span class="line">    <span class="string">'/screen3'</span> : (BuildContext context) =&gt; <span class="keyword">new</span> Screen3(),</span><br><span class="line">    <span class="string">'/screen4'</span> : (BuildContext context) =&gt; <span class="keyword">new</span> Screen4()</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><em>Screen1()、Screen2()等是每个页面的类名。</em></p>
<p>我们同样可以实现前面的功能：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">   onPressed:()&#123;</span><br><span class="line">     Navigator.of(context).pushNamed(<span class="string">'/screen2'</span>);</span><br><span class="line">   &#125;,</span><br><span class="line">   child: <span class="keyword">new</span> Text(<span class="string">"Push to Screen 2"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(</span><br><span class="line">   onPressed:()&#123;</span><br><span class="line">     Navigator.pushNamed(context, <span class="string">"/screen2"</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   child: <span class="keyword">new</span> Text(<span class="string">"Push to Screen 2"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>同样可以实现上方效果。</p>
<h2 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h2><p>实现上面两种方法，此时，路由栈中的情况如下：</p>
<p><img src="/images/route1.png" alt="1_RKtC1MKJbjSfMjUlR-2K7g"></p>
<p>现在，当我们想要回退的到主屏幕时，我们则需要使用 pop 方法从 Navigator 的堆栈中弹出 Routes。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pop();</span><br></pre></td></tr></table></figure>
<p><img src="/images/route2.png" alt="1_hq7qfAer0wCCSyIBKr7sfg"></p>
<p>使用 Scaffold 时，通常不需要显式弹出路径，因为 Scaffold 会自动向其 AppBar 添加一个“后退”按钮，按下时会调用 <code>Navigator.pop()</code>。 </p>
<p>在 Android 中，按下设备后退按钮也会这样做。但是，我们也有可能需要将此方法用于其他组件，例如在用户单击“取消”按钮时弹出 AlertDialog。</p>
<blockquote>
<p><strong>这里要注意的是：</strong>切勿用 push 代替 pop，有同学说我在 Screen2 push Screen1 部照样能实现这个功能吗？其实不然啊，请看下图：</p>
</blockquote>
<p><img src="/images/route3.png" alt="1_Xsyo5c8s1JwO6f2OQ1nNEg"></p>
<blockquote>
<p>所以 <strong>push 只用于向栈中添加实例，pop 弹出实例！（特殊需求除外）</strong></p>
</blockquote>
<h1 id="详解路由栈"><a href="#详解路由栈" class="headerlink" title="详解路由栈"></a>详解路由栈</h1><p>前面，我们已经知道如何简单在路由栈中 push、pop 实例，然而，当遇到一些特殊的情况，这显然不能满足需求。学习 Android 的同学知道 Activity 的各种启动模式可以完成相应需求，Flutter 当然也有类似的可以解决各种业务需求的实现方式！</p>
<p>请看下面使用方法与案例分析。</p>
<h2 id="pushReplacementNamed-与-popAndPushNamed"><a href="#pushReplacementNamed-与-popAndPushNamed" class="headerlink" title="pushReplacementNamed 与 popAndPushNamed"></a>pushReplacementNamed 与 popAndPushNamed</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.pushReplacementNamed(context, <span class="string">"/screen4"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">"pushReplacementNamed"</span>),</span><br><span class="line">),</span><br><span class="line">RaisedButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    Navigator.popAndPushNamed(context, <span class="string">"/screen4"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Text(<span class="string">"popAndPushNamed"</span>),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p><em>我们在 Screen3 页面使用 <code>pushReplacementNamed</code> 与 <code>popAndPushNamed</code> 方法 push 了 Screen4。</em></p>
<p>此时路由栈情况如下：</p>
<p><img src="/images/route4.png" alt="1_cr77kgOgz7KRjwvMAVXoAg"></p>
<p><strong>Screen4 代替了 Screen</strong>。</p>
<p><code>pushReplacementNamed</code> 与 <code>popAndPushNamed</code> 的区别在于：  <code>popAndPushNamed</code>  能够执行 Screen2 弹出的动画与 Screen3 推进的动画而 <code>pushReplacementNamed</code> 仅显示 Screen3 推进的动画。</p>
<p><img src="/images/route10.gif" alt="1_cr77kgOgz7KRjwvMAVXoAg"></p>
<p>案例：</p>
<blockquote>
<p><strong>pushReplacementNamed</strong>：当用户成功登录并且现在在 <code>HomeScreen</code> 上时，您不希望用户还能够返回到 <code>LoginScreen</code>。因此，登录应完全由首页替换。另一个例子是从 <code>SplashScreen</code> 转到 <code>HomeScreen</code>。 它应该只显示一次，用户不能再从 <code>HomeScreen</code> 返回它。 在这种情况下，由于我们要进入一个全新的屏幕，我们可能需要借助此方法。</p>
<p><strong>popAndPushNamed</strong>：假设您正在有一个 <code>Shopping</code> 应用程序，该应用程序在 <code>ProductsListScreen</code> 中显示产品列表，用户可以在 <code>FiltersScreen</code> 中应用过滤商品。 当用户单击“应用筛选”按钮时，应弹出 <code>FiltersScreen</code> 并使用新的过滤器值推回到 <code>ProductsListScreen</code>。 这里 <code>popAndPushNamed</code> 显然更为合适。</p>
</blockquote>
<h2 id="pushNamedAndRemoveUntil"><a href="#pushNamedAndRemoveUntil" class="headerlink" title="pushNamedAndRemoveUntil"></a>pushNamedAndRemoveUntil</h2><blockquote>
<p>用户已经登陆进入 <code>HomeScreen</code> ，然后经过一系列操作回到配合只界面想要退出登录，你不能够直接 Push 进入 <code>LoginScreen</code> 吧？<strong>你需要将之前路由中的实例全部删除是的用户不会在回到先前的路由中。</strong></p>
</blockquote>
<p>pushNamedAndRemoveUntil 可实现该功能：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pushNamedAndRemoveUntil(<span class="string">'/screen4'</span>, (Route&lt;<span class="built_in">dynamic</span>&gt; route) =&gt; <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>(Route&lt;dynamic&gt; route) =&gt; false</code> 能够确保删除先前所有实例。</p>
<p><img src="/images/route5.png" alt="Logging out removes all routes and takes user back to LoginScreen"></p>
<p>现在又有一个需求：我们不希望删除先前所有实例，<strong>我们只要求删除指定个数的实例</strong>。</p>
<blockquote>
<p>我们有一个需要付款交易的购物应用。在应用程序中，一旦用户完成了支付交易，就应该从堆栈中删除所有与交易或购物车相关的页面，并且用户应该被带到 <code>PaymentConfirmationScreen</code> ,单击后退按钮应该只将它们带回到 <code>ProductsListScreen</code> 或 <code>HomeScreen</code>：</p>
</blockquote>
<p><img src="/images/route6.png" alt="1_aaZxoLUbKdFPgiIkBAmw7w"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.of(context).pushNamedAndRemoveUntil(<span class="string">'/screen4'</span>, ModalRoute.withName(<span class="string">'/screen1'</span>));</span><br></pre></td></tr></table></figure>
<p>通过代码，我们推送 <code>Screen4</code> 并删除所有路由，直到 <code>Screen1</code>：</p>
<p><img src="/images/route7.png" alt="1_D81iZF-BikxXJHak7_NkhA"></p>
<h2 id="popUntil"><a href="#popUntil" class="headerlink" title="popUntil"></a>popUntil</h2><p>想象一下，我们在应用程序中要填写一系列信息，表单分布在多个页面中。假设需要填写三个页面的表单一步接着一步。  然而，在表单的第 3 部分，用户取消了填写表单。 用户单击取消并且应弹出所有之前与表单相关的页面，并且应该将用户带回 <code>HomeScreen</code> 或者 <code>DashboardScreen</code>，这种情况下数据属于数据无效！ 我们不会在这里推新任何新东西，只是回到以前的路由栈中。</p>
<p><img src="/images/route8.png" alt="1_qV7mF0Kow2zch-fjksmA_Q"></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.popUntil(context, ModalRoute.withName(<span class="string">'/screen2'</span>));</span><br></pre></td></tr></table></figure>
<h2 id="Popup-routes（弹出路由）"><a href="#Popup-routes（弹出路由）" class="headerlink" title="Popup routes（弹出路由）"></a>Popup routes（弹出路由）</h2><p>路由不一定要遮挡整个屏幕。 <a href="https://docs.flutter.io/flutter/widgets/PopupRoute-class.html" target="_blank" rel="noopener">PopupRoute</a>s 使用 <a href="https://docs.flutter.io/flutter/widgets/ModalRoute/barrierColor.html" target="_blank" rel="noopener">ModalRoute.barrierColor</a>  覆盖屏幕，<a href="https://docs.flutter.io/flutter/widgets/ModalRoute/barrierColor.html" target="_blank" rel="noopener">ModalRoute.barrierColor</a> 只能部分不透明以允许当前屏幕显示。 弹出路由是“模态”的，因为它们阻止了对下面其他组件的输入。</p>
<p>有一些方法可以创建和显示这类弹出路由。 例如：showDialog，showMenu 和 showModalBottomSheet。 如上所述，这些函数返回其推送路由的 Future（异步数据，参考下面的数据部分）。 执行可以等待返回的值在弹出路由时执行操作。</p>
<p>还有一些组件可以创建弹出路由，如 PopupMenuButton 和 DropdownButton。 这些组件创建 PopupRoute 的内部子类，并使用 Navigator 的 push 和 pop 方法来显示和关闭它们。</p>
<h2 id="自定义路由"><a href="#自定义路由" class="headerlink" title="自定义路由"></a>自定义路由</h2><p>您可以创建自己的一个窗口z组件库路由类（如 PopupRoute，ModalRoute 或 PageRoute）的子类，以控制用于显示路径的动画过渡，路径的模态屏障的颜色和行为以及路径的其他各个特性。</p>
<p>PageRouteBuilder 类可以根据回调定义自定义路由。 下面是一个在路由出现或消失时旋转并淡化其子节点的示例。 此路由不会遮挡整个屏幕，因为它指定了opaque：false，就像弹出路由一样。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Navigator.push(context, PageRouteBuilder(</span><br><span class="line">  opaque: <span class="keyword">false</span>,</span><br><span class="line">  pageBuilder: (BuildContext context, _, __) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(child: Text(<span class="string">'My PageRoute'</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">  transitionsBuilder: (___, Animation&lt;<span class="built_in">double</span>&gt; animation, ____, Widget child) &#123;</span><br><span class="line">    <span class="keyword">return</span> FadeTransition(</span><br><span class="line">      opacity: animation,</span><br><span class="line">      child: RotationTransition(</span><br><span class="line">        turns: Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0.5</span>, end: <span class="number">1.0</span>).animate(animation),</span><br><span class="line">        child: child,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<p><img src="/images/route9.gif" alt="ezgif-3-14c32a6d8764"></p>
<p>路由两部分构成，“pageBuilder”和“transitionsBuilder”。 该页面成为传递给 buildTransitions 方法的子代的后代。 通常，页面只构建一次，因为它不依赖于其动画参数（在此示例中以_和__表示）。 过渡是建立在每个帧的持续时间。</p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>一个应用程序可以使用多个路由导航器。将一个导航器嵌套在另一个导航器下方可用于创建“内部旅程”，例如选项卡式导航，用户注册，商店结帐或代表整个应用程序子部分的其他独立个体。</p>
<p>iOS应用程序的标准做法是使用选项卡式导航，其中每个选项卡都维护自己的导航历史记录。因此，每个选项卡都有自己的导航器，创建了一种“并行导航”。</p>
<p>除了选项卡的并行导航之外，还可以启动完全覆盖选项卡的全屏页面。例如：入职流程或警报对话框。因此，必须存在位于选项卡导航上方的“根”导航器。因此，每个选项卡的 Navigators 实际上都是嵌套在一个根导航器下面的 Navigators。</p>
<p>用于选项卡式导航的嵌套导航器位于 WidgetApp 和 <a href="https://docs.flutter.io/flutter/cupertino/CupertinoTabView-class.html" target="_blank" rel="noopener">CupertinoTabView</a> 中，因此在这种情况下您无需担心嵌套的导航器，但它是使用嵌套导航器的真实示例。</p>
<p>以下示例演示了如何使用嵌套的 Navigator 来呈现独立的用户注册过程。</p>
<p>尽管此示例使用两个 Navigators 来演示嵌套的 Navigators，但仅使用一个 Navigato r就可以获得类似的结果。 </p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      <span class="comment">// ...some parameters omitted...</span></span><br><span class="line">      <span class="comment">// MaterialApp contains our top-level Navigator</span></span><br><span class="line">      initialRoute: <span class="string">'/'</span>,</span><br><span class="line">      routes: &#123;</span><br><span class="line">        <span class="string">'/'</span>: (BuildContext context) =&gt; HomePage(),</span><br><span class="line">        <span class="string">'/signup'</span>: (BuildContext context) =&gt; SignUpPage(),</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignUpPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"> <span class="meta">@override</span></span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line">   <span class="comment">// SignUpPage builds its own Navigator which ends up being a nested</span></span><br><span class="line">   <span class="comment">// Navigator in our app.</span></span><br><span class="line">   <span class="keyword">return</span> Navigator(</span><br><span class="line">     initialRoute: <span class="string">'signup/personal_info'</span>,</span><br><span class="line">     onGenerateRoute: (RouteSettings settings) &#123;</span><br><span class="line">       WidgetBuilder builder;</span><br><span class="line">       <span class="keyword">switch</span> (settings.name) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'signup/personal_info'</span>:</span><br><span class="line">           <span class="comment">// Assume CollectPersonalInfoPage collects personal info and then</span></span><br><span class="line">           <span class="comment">// navigates to 'signup/choose_credentials'.</span></span><br><span class="line">           builder = (BuildContext _) =&gt; CollectPersonalInfoPage();</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">'signup/choose_credentials'</span>:</span><br><span class="line">           <span class="comment">// Assume ChooseCredentialsPage collects new credentials and then</span></span><br><span class="line">           <span class="comment">// invokes 'onSignupComplete()'.</span></span><br><span class="line">           builder = (BuildContext _) =&gt; ChooseCredentialsPage(</span><br><span class="line">             onSignupComplete: () &#123;</span><br><span class="line">               <span class="comment">// Referencing Navigator.of(context) from here refers to the</span></span><br><span class="line">               <span class="comment">// top level Navigator because SignUpPage is above the</span></span><br><span class="line">               <span class="comment">// nested Navigator that it created. Therefore, this pop()</span></span><br><span class="line">               <span class="comment">// will pop the entire "sign up" journey and return to the</span></span><br><span class="line">               <span class="comment">// "/" route, AKA HomePage.</span></span><br><span class="line">               Navigator.of(context).pop();</span><br><span class="line">             &#125;,</span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">throw</span> Exception(<span class="string">'Invalid route: <span class="subst">$&#123;settings.name&#125;</span>'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> MaterialPageRoute(builder: builder, settings: settings);</span><br><span class="line">     &#125;,</span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Navigator.of 在给定 BuildContext 中最近的根 Navigator 上运行。 确保在预期的 Navigator 下面提供BuildContext，尤其是在创建嵌套 Navigators 的大型构建方法中。 Builder 组件可用于访问组件子树中所需位置的 BuildContext。</p>
<h1 id="页面间数据传递"><a href="#页面间数据传递" class="headerlink" title="页面间数据传递"></a>页面间数据传递</h1><h2 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h2><p>在上面的大多数示例中，我们推送新路由时没有发送数据，但在实际应用中这种情况应用很少。 要发送数据，我们将使用 Navigator 将新的 MaterialPageRoute 用我们的数据推送到堆栈上（这里是 <code>userName</code>）</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> userName = <span class="string">"John Doe"</span>;</span><br><span class="line">Navigator.push(</span><br><span class="line">    context,</span><br><span class="line">    <span class="keyword">new</span> MaterialPageRoute(</span><br><span class="line">        builder: (BuildContext context) =&gt;</span><br><span class="line">        <span class="keyword">new</span> Screen5(userName)));</span><br></pre></td></tr></table></figure>
<p>要在 <code>Screen5</code> 中得到数据，我们只需在 <code>Screen5</code> 中添加一个参数化构造函数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen5</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> userName;</span><br><span class="line">  Screen5(<span class="keyword">this</span>.userName);</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="built_in">print</span>(userName)</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这表示我们不仅可以使用 <code>MaterialPageRoute</code> 作为 <code>push</code> 方法，还可以使用 <code>pushReplacement</code> ，<code>pushAndPopUntil</code> 等。基本上从我们描述的上述方法中路由方法，第一个参数现在将采用 <code>MaterialPageRoute</code> 而不是 <code>namedRoute</code> 的 <code>String</code>。</p>
<h2 id="数据返回"><a href="#数据返回" class="headerlink" title="数据返回"></a>数据返回</h2><p>我们可能还想从新页面返回数据。 就像一个警报应用程序，并为警报设置一个新音调，您将显示一个带有音频音调选项列表的对话框。 显然，一旦弹出对话框，您将需要所选的项目数据。 它可以这样实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> RaisedButton(onPressed: ()<span class="keyword">async</span>&#123;</span><br><span class="line">  <span class="built_in">String</span> value = <span class="keyword">await</span> Navigator.push(context, <span class="keyword">new</span> MaterialPageRoute&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> GestureDetector(</span><br><span class="line">              child: <span class="keyword">new</span> Text(<span class="string">'OK'</span>),</span><br><span class="line">              onTap: () &#123; Navigator.pop(context, <span class="string">"Audio1"</span>); &#125;</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">  )</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">print</span>(value);</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">  child: <span class="keyword">new</span> Text(<span class="string">"Return"</span>),)</span><br></pre></td></tr></table></figure>
<p><em>在 <code>Screen4</code> 中尝试并检查控制台的打印值。</em></p>
<p>另请注意：当路由用于返回值时，路由的类型参数应与 pop 的结果类型匹配。 这里我们需要一个 String 数据，所以我们使用了 <code>MaterialPageRoute &lt;String&gt;</code>。 不指定类型也没关系。</p>
<h1 id="其他效果解释"><a href="#其他效果解释" class="headerlink" title="其他效果解释"></a>其他效果解释</h1><h2 id="maybePop"><a href="#maybePop" class="headerlink" title="maybePop"></a>maybePop</h2><p>源码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Future&lt;<span class="built_in">bool</span>&gt; maybePop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;(BuildContext context, [ T result ]) &#123;</span><br><span class="line">    <span class="keyword">return</span> Navigator.of(context).maybePop&lt;T&gt;(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@optionalTypeArgs</span></span><br><span class="line">  Future&lt;<span class="built_in">bool</span>&gt; maybePop&lt;T <span class="keyword">extends</span> <span class="built_in">Object</span>&gt;([ T result ]) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Route&lt;T&gt; route = _history.last;</span><br><span class="line">    <span class="keyword">assert</span>(route._navigator == <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">final</span> RoutePopDisposition disposition = <span class="keyword">await</span> route.willPop();</span><br><span class="line">    <span class="keyword">if</span> (disposition != RoutePopDisposition.bubble &amp;&amp; mounted) &#123;</span><br><span class="line">      <span class="keyword">if</span> (disposition == RoutePopDisposition.pop)</span><br><span class="line">        pop(result);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们在初始路由上并且有人错误地试图弹出这个唯一页面怎么办？ 弹出堆栈中唯一的页面将关闭您的应用程序，因为它后面已经没有页面了。这显然是不好的体验。 这就是 <code>maybePop()</code> 起的作用。 点击 <code>Screen1</code> 上的 <code>maybePop</code> 按钮，没有任何效果。 在 <code>Screen3</code> 上尝试相同的操作，可以正常弹出。</p>
<p>这种效果也可通过 canPop 实现：</p>
<h2 id="canPop"><a href="#canPop" class="headerlink" title="canPop"></a>canPop</h2><p>源码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> canPop(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> NavigatorState navigator = Navigator.of(context, nullOk: <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> navigator != <span class="keyword">null</span> &amp;&amp; navigator.canPop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> canPop() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_history.isNotEmpty);</span><br><span class="line">    <span class="keyword">return</span> _history.length &gt; <span class="number">1</span> || _history[<span class="number">0</span>].willHandlePopInternally;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果占中实例大于 1 或 willHandlePopInternally 属性为 true 返回 true，否则返回 false。</p>
<p>我们可以通过判断 canPop 来确定是否能够弹出该页面。</p>
<h2 id="如何去除默认返回按钮"><a href="#如何去除默认返回按钮" class="headerlink" title="如何去除默认返回按钮"></a>如何去除默认返回按钮</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AppBar(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.leading,</span><br><span class="line">    <span class="keyword">this</span>.automaticallyImplyLeading = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.title,</span><br><span class="line">    <span class="keyword">this</span>.actions,</span><br><span class="line">    <span class="keyword">this</span>.flexibleSpace,</span><br><span class="line">    <span class="keyword">this</span>.bottom,</span><br><span class="line">    <span class="keyword">this</span>.elevation = <span class="number">4.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.backgroundColor,</span><br><span class="line">    <span class="keyword">this</span>.brightness,</span><br><span class="line">    <span class="keyword">this</span>.iconTheme,</span><br><span class="line">    <span class="keyword">this</span>.textTheme,</span><br><span class="line">    <span class="keyword">this</span>.primary = <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">this</span>.centerTitle,</span><br><span class="line">    <span class="keyword">this</span>.titleSpacing = NavigationToolbar.kMiddleSpacing,</span><br><span class="line">    <span class="keyword">this</span>.toolbarOpacity = <span class="number">1.0</span>,</span><br><span class="line">    <span class="keyword">this</span>.bottomOpacity = <span class="number">1.0</span>,</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(automaticallyImplyLeading != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(elevation != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(primary != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(titleSpacing != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(toolbarOpacity != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">assert</span>(bottomOpacity != <span class="keyword">null</span>),</span><br><span class="line">       preferredSize = Size.fromHeight(kToolbarHeight + (bottom?.preferredSize?.height ?? <span class="number">0.0</span>)),</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br></pre></td></tr></table></figure>
<p>将 <code>automaticallyImplyLeading</code>置为 <code>false</code></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://docs.flutter.io/flutter/widgets/Navigator-class.html" target="_blank" rel="noopener">https://docs.flutter.io/flutter/widgets/Navigator-class.html</a></p>
<p><a href="https://medium.com/flutter-community/flutter-push-pop-push-1bb718b13c31" target="_blank" rel="noopener">https://medium.com/flutter-community/flutter-push-pop-push-1bb718b13c31</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Joker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://meandni.com/2019/03/04/flutter-route/">https://meandni.com/2019/03/04/flutter-route/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://meandni.com">Joker's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/flutter/">flutter</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5ebb714f13e60e34" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/03/12/reading-record2/"><i class="fa fa-chevron-left">  </i><span>2019第二次阅读记录</span></a></div><div class="next-post pull-right"><a href="/2019/02/09/flutter-state3/"><span>Flutter实践：深入 Flutter 的状态管理方式(3)——Redux与旅途小结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '12faa9d04b92d2d70968',
  clientSecret: 'ad1023eebffeb2972301ce0e730e0c277f64cf23',
  repo: 'MeandNi.github.io',
  owner: 'MeandNi',
  admin: 'MeandNi',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Joker</div><div class="framework-info"><span>驱动 - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>