<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Flutter动画全解析（动画四要素、动画组件、隐式动画组件原理等）"><meta name="keywords" content="flutter,动画"><meta name="author" content="Joker"><meta name="copyright" content="Joker"><title>Flutter动画全解析（动画四要素、动画组件、隐式动画组件原理等） | Joker's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-动画四要素"><span class="toc-number">1.</span> <span class="toc-text">1. 动画四要素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-插值器（Tweens）"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 插值器（Tweens）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-动画曲线（Animation-Curves）"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 动画曲线（Animation Curves）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Ticker-providers"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Ticker providers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-动画控制器（AnimationController）"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 动画控制器（AnimationController）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-Animation"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 Animation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-5-动画监听"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.5 动画监听</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-动画组件"><span class="toc-number">2.</span> <span class="toc-text">2. 动画组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-隐式动画组件"><span class="toc-number">3.</span> <span class="toc-text">3. 隐式动画组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-AnimatedContainer"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 AnimatedContainer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-AnimatedOpacity"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 AnimatedOpacity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-隐式动画原理简析"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 隐式动画原理简析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-实现自定义隐式动画组件"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 实现自定义隐式动画组件</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Joker</div><div class="author-info__description text-center">分享生活、技术、学习心得</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">37</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">26</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">11</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Joker's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Flutter动画全解析（动画四要素、动画组件、隐式动画组件原理等）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%8E%9F%E5%88%9B/">原创</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%8E%9F%E5%88%9B/Flutter/">Flutter</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>本文通过拆解 Flutter 中动画的实现方式以及原理来介绍动画实现的整个过程。</p>
</blockquote>
<h2 id="1-动画四要素"><a href="#1-动画四要素" class="headerlink" title="1. 动画四要素"></a>1. 动画四要素</h2><p>动画在各个平台的实现原理都基本相同，都是由在一段时间内一系列连续变化画面的帧构成的。在 Flutter 中，动画的过程又被量化成一段值区间，我们可以利用这些值设置控件的各个属性来实现动画，其内部由四个关键的部分来实现这一过程。</p>
<a id="more"></a>
<h3 id="1-1-插值器（Tweens）"><a href="#1-1-插值器（Tweens）" class="headerlink" title="1.1 插值器（Tweens）"></a>1.1 插值器（Tweens）</h3><p>tweens 可为动画提供起始值和结束值。默认情况下，Flutter 中的动画将任何给定时刻的值映射到介于 0.0 和 1.0 之间的 double 值。 我们可以使用以下 Tween 将其间值的范围定义为从 -200.0变为 0.0：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">tween = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">-200</span>, end: <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>我们也可以将值设置为相应需要改变的对象值，比如将起始值设置为红色，结束值设置为蓝色，那么 tweens 产生的动画便是由红渐渐的变成蓝色。如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">colorTween = ColorTween(begin: Colors.red, end: Colors.blue);</span><br></pre></td></tr></table></figure>
<h3 id="1-2-动画曲线（Animation-Curves）"><a href="#1-2-动画曲线（Animation-Curves）" class="headerlink" title="1.2 动画曲线（Animation Curves）"></a>1.2 动画曲线（Animation Curves）</h3><p>Curves 用来调整动画过程中随时间的变化率，默认情况下，动画以均匀的线性模型变化。读者可以通过自定义继承 Curves 的类来定义动画的变化率，比如设置为加速、减速或者先加速后减速等曲线模型。Flutter 内部也提供了一系列实现相应变化率的 Curves 对象：</p>
<ul>
<li>linear</li>
<li>decelerate</li>
<li>ease</li>
<li>easeIn</li>
<li>easeOut</li>
<li>easeInOut</li>
<li>fastOutSlowIn</li>
<li>bounceIn</li>
<li>bounceOut</li>
<li>bounceInOut</li>
<li>elasticIn</li>
<li>elasticOut</li>
<li>elasticInOut</li>
</ul>
<p>相关动画曲线模型图如下：</p>
<p><img src="/images/curve_linear.gif" alt="curve_linear"></p>
<p><img src="/images/curve_bounce_in.gif.gif" alt="curve_bounce_in"></p>
<p><img src="/images/curve_ease_in.gif.gif" alt="curve_ease_in"></p>
<h3 id="1-3-Ticker-providers"><a href="#1-3-Ticker-providers" class="headerlink" title="1.3 Ticker providers"></a>1.3 Ticker providers</h3><p>Flutter 中的动画以屏幕频繁的重绘而实现，即每秒 60 帧。Ticker 可以被应用在 Flutter 每个对象中，当对象实现了 Ticker 的功能后，每次动画帧改变便会通知该对象。这里，开发者们不需要为对象手动实现 Ticker，flutter 提供了 TickerProvider 类可以帮助我们快速实现该功能。例如，在有状态控件下使用动画时，通常需要在 State 对象下混入 TickerProviderStateMixin。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAnimationState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyAnimation</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-动画控制器（AnimationController）"><a href="#1-4-动画控制器（AnimationController）" class="headerlink" title="1.4 动画控制器（AnimationController）"></a>1.4 动画控制器（AnimationController）</h3><p>Flutter 中动画的实现还有一个非常重要的类 AnimationController，即动画控制器。很明显，我们用它来控制动画，即动画的启动、暂停等。其接受两个参数，第一个是 vsync，为 Ticker 对象，其作用是当接受到来自 tweens 和 curves 的新值后通知对应对象，第二个 duration 参数为动画持续的时长。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混入 SingleTickerProviderStateMixin 使对象实现 Ticker 功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimatedContainerState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimatedContainer</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  AnimationController _controller;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 创建 AnimationController 动画</span></span><br><span class="line">    _controller = AnimationController(</span><br><span class="line">      <span class="comment">// 传入 Ticker 对象</span></span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">      <span class="comment">// 传入 动画持续时间</span></span><br><span class="line">      duration: <span class="keyword">new</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">1000</span>),</span><br><span class="line">    );</span><br><span class="line">    startAnimation();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; startAnimation() <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 AnimationController 的 forward 方法启动动画</span></span><br><span class="line">    <span class="keyword">await</span> _controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      width: _controller.value;</span><br><span class="line">      child: <span class="comment">//...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AnimationController 继承自 Animation，具有一系列控制动画的方法，如可用 <code>forward()</code> 方法来启动动画，可用 <code>repeat()</code> 方法使动画重复执行，也可以通过其 value 属性得到当前值。</p>
<h4 id="1-4-1-Animation"><a href="#1-4-1-Animation" class="headerlink" title="1.4.1 Animation"></a>1.4.1 Animation</h4><p>我们可以通过在 CurvedAnimation 传入 AnimationController 和 Curve 对象创建一个 Animation 对象，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimationController controller = AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> Animation&lt;<span class="built_in">double</span>&gt; animation = CurvedAnimation(</span><br><span class="line">  parent: controller,</span><br><span class="line">  curve: Curves.ease,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>也可以通过调用 tween 的 animate 方法传入 controller 对象创建 Animation 对象，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimationController controller = AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(controller);</span><br></pre></td></tr></table></figure>
<p>Animation 是一个抽象类，其中保存了动画的过程值（value）和状态，下面是四种状态类型。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> AnimationStatus &#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">动画处于停止状态</span></span></span><br><span class="line">  dismissed,</span><br><span class="line">  <span class="comment">/// <span class="markdown">动画从头到尾执行</span></span></span><br><span class="line">  forward,</span><br><span class="line">  <span class="comment">/// <span class="markdown">动画从尾到头执行</span></span></span><br><span class="line">  reverse,</span><br><span class="line">  <span class="comment">/// <span class="markdown">动画已执行完成</span></span></span><br><span class="line">  completed,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AnimationController 是它的一个实现类。其内部通过范型机制可实现对各类型对象的动画，比如 <code>Animation&lt;double&gt;</code>、<code>Animation&lt;Color&gt;</code>、<code>Animation&lt;Size&gt;</code> 等。其另一个实现类 Curved­Animation，可以用来与 Curves 结合实现各类曲线模型函数的动画。</p>
<p>Animation 另一个实现方法是调用 tween 对象的 animate 方法传入 Animation 对象创建另一个 Animation 对象，该方法可通过将使动画值定义在 tween 区间内，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimationController controller = AnimationController(</span><br><span class="line">    duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), vsync: <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">final</span> Animation curve =</span><br><span class="line">    CurvedAnimation(parent: controller, curve: Curves.easeOut);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(curve);</span><br></pre></td></tr></table></figure>
<h4 id="1-4-5-动画监听"><a href="#1-4-5-动画监听" class="headerlink" title="1.4.5 动画监听"></a>1.4.5 动画监听</h4><p>Animation 对象可以有设置两种监听器，分别是帧监听器和状态监听器。使用 <code>addListener()</code> 添加帧监听器，使用<code>addStatusListener()</code>  添加状态监听器。</p>
<p>只要动画的值发生变化，就会触发帧监听器的回调。 通常，我们在其内部调用 <code>setState()</code> 来重建组件来实现动画效果，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">animation = <span class="keyword">new</span> CurvedAnimation(</span><br><span class="line">        parent: animationController, curve: Curves.elasticOut)</span><br><span class="line">animation.addListener(() =&gt; <span class="keyword">this</span>.setState(() &#123;&#125;))</span><br></pre></td></tr></table></figure>
<p>动画开始，结束，前进或后退时会触发 StatusListener 的回调，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">animation = <span class="keyword">new</span> CurvedAnimation(</span><br><span class="line">        parent: animationController, curve: Curves.elasticOut)</span><br><span class="line">animation.addStatusListener((AnimationStatus status) &#123;&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="2-动画组件"><a href="#2-动画组件" class="headerlink" title="2. 动画组件"></a>2. 动画组件</h2><p>我们已经知道了 Flutter 控制动画的四大要素，其中涉及的各个概念可以帮助我们设计出各种各样的动画效果，但不免也多了一些需要重复编写的模版代码，比如，在 Animation 的帧监听器设置的监听器回调里，几乎所有场景中我们都只是调用 <code>setState()</code>，再比如 State 对象每次都需要我们手动地混入 <code>SingleTickerProviderStateMixin</code> 等等这类情况。Flutter 为了提高开发者的开发效率，提供了 AnimatedWidget 抽象类来封装这部分模版代码，其源码非常简单，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimatedWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">该 Widget 在 listenable 状态改变后将会重建.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">[listenable] 为必要参数.</span></span></span><br><span class="line">  <span class="keyword">const</span> AnimatedWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.listenable</span><br><span class="line">  &#125;) : <span class="keyword">assert</span>(listenable != <span class="keyword">null</span>),</span><br><span class="line">       <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">The [Listenable] to which this widget is listening.</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">一般是一个 [Animation] 或者 [ChangeNotifier] 对象.</span></span></span><br><span class="line">  <span class="keyword">final</span> Listenable listenable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">继承该方法构建依赖 listenable（当前 value 值等） 状态的 Widget.</span></span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _AnimatedState createState() =&gt; _AnimatedState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimatedState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimatedWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    widget.listenable.addListener(_handleChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(AnimatedWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">    <span class="keyword">if</span> (widget.listenable != oldWidget.listenable) &#123;</span><br><span class="line">      oldWidget.listenable.removeListener(_handleChange);</span><br><span class="line">      widget.listenable.addListener(_handleChange);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    widget.listenable.removeListener(_handleChange);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleChange() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="comment">// 状态改变，重建 Widget.</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; widget.build(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AnimatedWidget 作为一个抽象类可供我们实现一个我们自己的具体类，其接受一个 Listenable 对象作为参数，并需要重写 <code>build</code> 方法。我们上一节中多次提到的 Animation 继承自 Listenable。下面的这个这个组件就是我自己实现的动画组件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sun</span> <span class="keyword">extends</span> <span class="title">AnimatedWidget</span> </span>&#123;</span><br><span class="line">  Sun(&#123;Key key, Animation&lt;Color&gt; animation&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key, listenable: animation);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">final</span> Animation&lt;Color&gt; animation = listenable;</span><br><span class="line">    <span class="keyword">var</span> maxWidth = MediaQuery.of(context).size.width;</span><br><span class="line">    <span class="keyword">var</span> margin = (maxWidth * <span class="number">.3</span>) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AspectRatio(</span><br><span class="line">        aspectRatio: <span class="number">1.0</span>,</span><br><span class="line">        child: <span class="keyword">new</span> Container(</span><br><span class="line">            margin: EdgeInsets.symmetric(horizontal: margin),</span><br><span class="line">            constraints: BoxConstraints(</span><br><span class="line">              maxWidth: maxWidth,</span><br><span class="line">            ),</span><br><span class="line">            decoration: <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">              shape: BoxShape.circle,</span><br><span class="line">              color: animation.value,</span><br><span class="line">            )));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过传入已经定义好的 Animation 对象来使用该组件：??</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimateWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimateWidget</span>&gt; </span>&#123;</span><br><span class="line">  AnimationController _animationController;</span><br><span class="line">  ColorTween _colorTween;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: </span><br><span class="line">          Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          Sun(animation: _colorTween.animate(_animationController)),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就封装了自己的一个动画组件，另外，Flutter 内部为我们提供了多个已经封装好的动画组件，利用好这些组件可以大大地提高我们的开发效率：</p>
<ul>
<li>SlideTransition</li>
<li>ScaleTransition</li>
<li>RotationTransition</li>
<li>SizeTransition</li>
</ul>
<h2 id="3-隐式动画组件"><a href="#3-隐式动画组件" class="headerlink" title="3. 隐式动画组件"></a>3. 隐式动画组件</h2><p>利用动画组件我们已经可以方便地封装出一系列控件动画了，但是这种实现方式均需要我们自己提供 Animation 对象，然后通过提供的接口方法来启动我们的动画，控件的属性由 Animation 对象提供并在动画过程中改变而达到动画的效果。为了使动画使用起来更加方便，Flutter 帮助了开发者从另一个角度以更简单的方式实现了动画效果——隐式动画组件（ImplicitlyAnimatedWidget）。</p>
<p>通过隐式动画组件，我们不需要手动实现插值器、曲线等对象，开发者甚至也不需要使用 AnimationController 来启动动画，它的实现方式更贴近对组件本身的操作，我们可以直接通过 <code>setState()</code> 的方法改变隐式动画组件的属性值，其内部自行为我们实现动画过程的过渡效果，即隐藏了所有动画实现的细节。Flutter 内部为我们提供了多个实用的隐式动画组件，我们本节分别介绍 AnimatedContainer 和 AnimatedOpacity 这两个最常用的隐式动画组件。</p>
<h3 id="3-1-AnimatedContainer"><a href="#3-1-AnimatedContainer" class="headerlink" title="3.1 AnimatedContainer"></a>3.1 AnimatedContainer</h3><p>AnimatedContainer 是我们最常使用到的隐式动画组件之一，从名字可以看出这个控件是以动画形式而成的 Contianer 控件，它们都是页面中渲染一个空的容器并且使用方法也非常相似。我们可以用下面的方式使用 Contianer 控件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> height = <span class="number">40.0</span>  </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">Container(</span><br><span class="line">    width: <span class="number">60.0</span>,</span><br><span class="line">    height: height,</span><br><span class="line">    color: Color(<span class="number">0xff14ff65</span>),</span><br><span class="line">  ),</span><br></pre></td></tr></table></figure>
<p>上面的代码中，我们将 Container 的高度设置为 height 变量，即为 40.0，当我们使用一个 Button 按钮触发改变 height 值的事件并且重绘界面时，Container 的高度会随之改变：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onPressed: ()&#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    height = <span class="number">320.0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>但这种变化很明显仅是属性的改变并不是一个平滑的过渡动画，然而同样的事件发生在 AnimatedContainer 控件上，便会有一个渐变的效果：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">AnimatedContainer(</span><br><span class="line">  duration: <span class="built_in">Duration</span>(seconds: <span class="number">5</span>),</span><br><span class="line">  width: <span class="number">60.0</span>,</span><br><span class="line">  height: height,</span><br><span class="line">  color: Color(<span class="number">0xff14ff65</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>使用 AnimatedContainer 后，我们再次触发 height 变量改变后，页面中的 AnimatedContainer 便会平滑的过渡到相应的高度，其 duration 属性用于设置动画过渡的时间，这里，我们设置为 5 秒??。</p>
<p>我们可以用相同的方式为 Container 的 Color、width 等各种属性设置动画，同时也可以通过为其设置 alignment 属性来设置其内部子控件的位置。</p>
<h3 id="3-2-AnimatedOpacity"><a href="#3-2-AnimatedOpacity" class="headerlink" title="3.2 AnimatedOpacity"></a>3.2 AnimatedOpacity</h3><p>在 Flutter 中，另一种常用的动画是控件透明度的过渡动画，其对应的隐式动画组件为 AnimatedOpacity。它的用法与 Opacity 相似，内部持有的 opacity 属性可以设置为 0.0～1.0 中的任意浮点数，分别对应完全透明与完全不透明，使用下面的方式，我们便可以设置了一个半透明的 Opacity 控件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Opacity(</span><br><span class="line">    opacity: <span class="number">0.5</span>,</span><br><span class="line">    child: Text(<span class="string">"hello"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>我们以相同的方法使用 AnimatedOpacity：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> opacity = <span class="number">1.0</span>;</span><br><span class="line">...</span><br><span class="line">AnimatedOpacity(</span><br><span class="line">    opacity: opacity,</span><br><span class="line">    duration: <span class="built_in">Duration</span>(seconds: <span class="number">1</span>),</span><br><span class="line">    child: Text(<span class="string">"hello"</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>它也接受 duration 属性来设置过渡时间，通过改变 opacity 变量的值可以实现透明度变化的动画效果：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">setState(() &#123;</span><br><span class="line">	opacity = <span class="number">0.0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-隐式动画原理简析"><a href="#3-3-隐式动画原理简析" class="headerlink" title="3.3 隐式动画原理简析"></a>3.3 隐式动画原理简析</h3><p>我们已经在之前部分介绍了 Flutter 中的三棵重要的树及它们在组件渲染中的作用了。在元素树中，每个 Element 对象持有控件树中 Widget 组件的状态信息，这里我们将它称为 State 对象，Widget 刷新重建时，Element 会对比自己所对应 Widget 是否更新而做出相应屏幕渲染上的改变。</p>
<p>在各个隐式动画组件中，其动画信息便储存在 Element 所持有的 State 对象中，Widget 每次刷新都会引起 Element 对其重新引用，当对应的 Widget 类型改变则其 Element 会连带 State 对象自然而然的需要重新渲染，然而当 Widget 类型不变，则 Element 不需要重建，只需要改变 State 对象储存的动画信息即可。这样一种连续更新属性的过程便实现了更为我们所方便使用的隐式动画。</p>
<h3 id="3-4-实现自定义隐式动画组件"><a href="#3-4-实现自定义隐式动画组件" class="headerlink" title="3.4 实现自定义隐式动画组件"></a>3.4 实现自定义隐式动画组件</h3><p>实现自定义的隐式动画组件，我们需要使用到两个类：ImplicitlyAnimatedWidget 和 AnimatedWidgetBaseState。</p>
<p>ImplicitlyAnimatedWidget 是所有隐式动画组件的父类，继承自 StatefulWidget，并且仅需要接受动画曲线 curve 与动画过渡时长 duration 两个参数：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ImplicitlyAnimatedWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.curve = Curves.linear,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.duration</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>在我们自定义的隐式动画组件可以扩充他的参数类型满足我们的需求。</p>
<p>AnimatedWidgetBaseState 即 ImplicitlyAnimatedWidget 这个有状态组件所对应的 State 对象类，我们自定义的隐式动画组件所对应的 State 也必须继承该类，其内部需要重写 <code>forEachTween</code> 方法。</p>
<p>下面就是我自己定义的隐式动画组件：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnimatedWidget</span> <span class="keyword">extends</span> <span class="title">ImplicitlyAnimatedWidget</span> </span>&#123;</span><br><span class="line">  MyAnimatedWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.param, <span class="comment">//导致动画的参数</span></span><br><span class="line">    Curve curve = Curves.linear,</span><br><span class="line">    <span class="meta">@required</span> <span class="built_in">Duration</span> duration,</span><br><span class="line">  &#125;) :<span class="keyword">super</span>(key: key, curve: curve, duration: duration);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> param;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyAnimatedWidgetState createState() =&gt; _MyAnimatedWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyAnimatedWidgetState</span> <span class="keyword">extends</span> <span class="title">AnimatedWidgetBaseState</span>&lt;<span class="title">MyAnimatedWidget</span>&gt; </span>&#123;</span><br><span class="line">  Tween&lt;<span class="built_in">double</span>&gt; _param; <span class="comment">// State 内部保存的当前状态信息，类型为 Tween</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> forEachTween(TweenVisitor&lt;<span class="built_in">dynamic</span>&gt; visitor) &#123;</span><br><span class="line">    _param = visitor(_param, widget.param, (value) =&gt; Tween&lt;<span class="built_in">double</span>&gt;(begin: value));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//return a widget built on a parameter</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们在父类的基础之上拓展了 param 参数，它是我们在动画过程中需要关注的动画属性值。我们还需要重点关注 _MyAnimatedWidgetState 类中 <code>forEachTween</code> 方法，它是隐式动画实现的核心方法，其用于每次更新组件的动画属性，接受一个 <code>TweenVisitor</code> 对象 visitor 作为参数。visitor 同时接受是那个参数，第一个为一个插值器对象 <code>Tween&lt;T&gt;</code>，其是应用在属性中的插值器当前补间值，第二个参数为一个 <code>T</code> 类型的值，即新的目标属性值，第三个参数为一个回调函数，用于配置给定的 value 值作为新的插值器开始值。<code>TweenVisitor&lt;T&gt;</code> 函数返回一个 <code>Tween&lt;T&gt;</code> 对象，我们将其赋值给组件中当前的插值器对象作为下次调用 <code>forEachTween</code> 方法时的当前值。</p>
<p>按照以上原理，我们就完成自己的隐式动画组件了。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Joker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://meandni.com/2019/07/01/c0f2/">https://meandni.com/2019/07/01/c0f2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/flutter/">flutter</a><a class="post-meta__tags" href="/tags/%E5%8A%A8%E7%94%BB/">动画</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/05/05/flutter-principle/"><span>Flutter原理：三棵重要的树(渲染过程、布局约束、应用视图的构建等)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '12faa9d04b92d2d70968',
  clientSecret: 'ad1023eebffeb2972301ce0e730e0c277f64cf23',
  repo: 'MeandNi.github.io',
  owner: 'MeandNi',
  admin: 'MeandNi',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Joker</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>