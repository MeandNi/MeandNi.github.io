<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《The Modern Javascript Tutorial》：javascript中的&quot;this&quot;"><meta name="keywords" content="阅读,技术,javascript"><meta name="author" content="Joker"><meta name="copyright" content="Joker"><title>《The Modern Javascript Tutorial》：javascript中的&quot;this&quot; | Joker's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#对象方法与-“this”"><span class="toc-number">1.</span> <span class="toc-text">对象方法与 “this”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#方法示例"><span class="toc-number">1.1.</span> <span class="toc-text">方法示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#方法简写"><span class="toc-number">1.1.1.</span> <span class="toc-text">方法简写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法中的-“this”"><span class="toc-number">1.2.</span> <span class="toc-text">方法中的 “this”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#“this”-不受限制"><span class="toc-number">1.3.</span> <span class="toc-text">“this” 不受限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内部：引用类型"><span class="toc-number">1.4.</span> <span class="toc-text">内部：引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数没有自己的-“this”"><span class="toc-number">1.5.</span> <span class="toc-text">箭头函数没有自己的 “this”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Joker</div><div class="author-info__description text-center">分享生活、技术、学习心得</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">38</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Joker's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">《The Modern Javascript Tutorial》：javascript中的&quot;this&quot;</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-09-08</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="对象方法与-“this”"><a href="#对象方法与-“this”" class="headerlink" title="对象方法与 “this”"></a>对象方法与 “this”</h1><p>对象通常被用来表示真实世界中的实体，比如用户、订单等等：</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，在现实世界中，用户可以<strong>操作</strong>：从购物车中挑选某物、登录、注销等。</p>
<p>在 JavaScript 中，操作通过属性中的函数来表示。</p>
<h2 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h2><p>刚开始，我们来让 <code>user</code> 说 hello：</p>
<figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line">user.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">user.sayHi(); /</span><span class="regexp">/ Hello!</span></span><br></pre></td></tr></table></figure>
<p>这里我们使用函数表达式创建了函数，并将其指定给对象的 <code>user.sayHi</code> 属性。</p>
<p>随后我们调用它。用户现在可以说话了！</p>
<p>作为对象属性的函数称之为<strong>方法</strong>。</p>
<p>那么，现在 <code>user</code> 对象有了一个 <code>sayHi</code> 方法。</p>
<p>当然我们也可以使用预先定义的函数作为方法，就像这样：</p>
<figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line"><span class="comment">// 首先声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"Hello!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将其作为一个方法</span></span><br><span class="line">user.sayHi = sayHi;</span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">user.sayHi(); /</span><span class="regexp">/ Hello!</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>header</span></figcaption><table><tr><td class="code"><pre><span class="line">当我们在代码中用对象表示实体时，这就是所谓的[面向对象编程](https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Object-oriented_programming)，简称为 &quot;OOP&quot;。</span><br><span class="line"></span><br><span class="line">OOP 是一门很大的学问，也是一门有其本身乐趣的学问。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于此方面的书，例如 E.Gamma、R.Helm、R.Johnson 和 J.Vissides 所著的《设计模式：可复用面向对象软件的基础》、G.Booch 所著的《面向对象分析与设计》等等。在后面的 &lt;info:object-oriented-programming&gt; 一章中，我们将会触及这个主题的浅层内容。</span><br></pre></td></tr></table></figure>
<h3 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h3><p>在对象字面量中，有一种更短的（声明）方法的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些对象作用一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法简写看起来更好，对吧？</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">*!*</span><br><span class="line">  sayHi() &#123; <span class="comment">// 与 "sayHi: function()" 一样</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">    alert("Hello");</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>如所示，我们可以省略 <code>&quot;function&quot;</code> 只写了 <code>sayHi()</code>。</p>
<p>说实话，这种表示法还是有些不同。与对象集成有关的细微差别（稍后将会介绍），但现在它们无关紧要。在几乎所有的情况下，较短的语法是最好的。</p>
<h2 id="方法中的-“this”"><a href="#方法中的-“this”" class="headerlink" title="方法中的 “this”"></a>方法中的 “this”</h2><p>对象方法需要访问对象中的存储的信息完成其工作是很常见的。</p>
<p>举个例子，<code>user.sayHi()</code> 中的代码可能需要用到 <code>user</code> 的 name 属性。</p>
<p><strong>为了访问该对象，方法中可以使用 <code>this</code> 关键字。</strong></p>
<p><code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p>
<p>举个例子：</p>
<figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">*!*</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">user.sayHi(); /</span><span class="regexp">/ John</span></span><br></pre></td></tr></table></figure>
<p>在这里 <code>user.sayHi()</code> 执行过程中，<code>this</code> 的值是 <code>user</code>。</p>
<p>技术上讲，也可以在不使用 <code>this</code> 的情况下，通过外部变量名来引用它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">*!*</span><br><span class="line">    alert(user.name); <span class="comment">// "user" 替代 "this"</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>但这样的代码是不可靠的。如果我们将 <code>user</code> 复制给另一个变量。例如 <code>admin = user</code>，并赋另外的值给 <code>user</code>，那么它将访问到错误的对象。</p>
<p>如下所示：</p>
<figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">*!*</span><br><span class="line">    alert( user.name ); <span class="comment">// 导致错误</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let admin = user;</span></span><br><span class="line"><span class="regexp">user = null; /</span><span class="regexp">/ 覆盖让其更易懂</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">admin.sayHi(); /</span><span class="regexp">/ 噢哟！在 sayHi() 使用了旧的变量名。错误！</span></span><br></pre></td></tr></table></figure>
<p>如果在 <code>alert</code> 中以 <code>this.name</code> 替换 <code>user.name</code>，那么代码就会正常运行。</p>
<h2 id="“this”-不受限制"><a href="#“this”-不受限制" class="headerlink" title="“this” 不受限制"></a>“this” 不受限制</h2><p>在 JavaScript 中，”this” 关键字与大多数其他编程语言中的不同。首先，它可以用于任何函数。</p>
<p>这样的代码没有语法错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( *!*<span class="keyword">this</span>*<span class="regexp">/!*.name );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>this</code> 是在运行时求值的。它可以是任何值。</p>
<p>例如，从不同的对象中调用同一个函数可能会有不同的 “this” 值：</p>
<figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">"John"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">"Admin"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert( <span class="keyword">this</span>.name );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line"><span class="comment">// 在两个对象中使用的是相同的函数</span></span><br><span class="line">user.f = sayHi;</span><br><span class="line">admin.f = sayHi;</span><br><span class="line">*<span class="regexp">/!*</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 它们调用时有不同的 this 值。</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 函数内部的 "this" 是点之前的这个对象。</span></span><br><span class="line"><span class="regexp">user.f(); /</span><span class="regexp">/ John  (this == user)</span></span><br><span class="line"><span class="regexp">admin.f(); /</span><span class="regexp">/ Admin  (this == admin)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">admin['f'](); /</span><span class="regexp">/ Admin（使用点或方括号语法来访问这个方法，都没有关系。）</span></span><br></pre></td></tr></table></figure>
<p>实际上，我们可以在没有任何对象的情况下调用函数：</p>
<figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。如果我们尝试访问 <code>this.name</code>，将会出现错误。</p>
<p>在非严格模式（没有使用 <code>use strict</code>）的情况下，<code>this</code> 将会是<strong>全局对象</strong>（浏览器中的 <code>window</code>，我们稍后会进行讨论）。<code>&quot;use strict&quot;</code> 可以修复这个历史行为。</p>
<p>请注意，通常在没有对象的情况下使用 <code>this</code> 的函数调用是不常见的，会（导致）编程错误。如果函数中有 <code>this</code>，那么通常意味着它是在对象上下文环境中被调用的。</p>
<figure class="highlight plain"><figcaption><span>header</span></figcaption><table><tr><td class="code"><pre><span class="line">如果你来自其他的编程语言，那么你可能熟悉『绑定 &#96;this&#96;』的概念。在对象定义的方法中，&#96;this&#96; 总是指向该对象。</span><br><span class="line"></span><br><span class="line">在 JavaScript 中，&#96;this&#96; 是『自由』的，它的值是在调用时进行求值的，它的值并不取决于方法声明的位置，而是（取决）于在『点之前』的是什么对象。</span><br><span class="line"></span><br><span class="line">在运行时对 &#96;this&#96; 求值的这个想法有其优缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性给错误留下了余地。</span><br><span class="line"></span><br><span class="line">这里我们的立场并不是要评判编程语言的这个想法的好坏，而是要了解怎样使用它，如何趋利避害。</span><br></pre></td></tr></table></figure>
<h2 id="内部：引用类型"><a href="#内部：引用类型" class="headerlink" title="内部：引用类型"></a>内部：引用类型</h2><p>​```warn header=”In-depth language feature”<br>本文介绍一个进阶的主题，来更好地理解一些特殊情况。</p>
<p>如果你想学得更快，这部分你可以跳过或过后来读。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">『复杂』的方法调用可能会失去 &#96;this&#96;，比如：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;js run</span><br><span class="line">let user &#x3D; &#123;</span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line">  hi() &#123; alert(this.name); &#125;,</span><br><span class="line">  bye() &#123; alert(&quot;Bye&quot;); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.hi(); &#x2F;&#x2F; John (the simple call works)</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line">&#x2F;&#x2F; 现在我们要判断 name 属性，来决定调用 user.hi 或是 user.bye。</span><br><span class="line">(user.name &#x3D;&#x3D; &quot;John&quot; ? user.hi : user.bye)(); &#x2F;&#x2F; Error!</span><br><span class="line">*&#x2F;!*</span><br></pre></td></tr></table></figure></p>
<p>最后一行中有一个三元运算符，它要判断是 <code>user.hi</code> 或 <code>user.bye</code>。在这种情况下，结果会是 <code>user.hi</code>。</p>
<p>该方法立即被括号 <code>()</code> 调用。但它无效。</p>
<p>你可以看到该调用导致了错误，因为调用中的 <code>&quot;this&quot;</code> 为 <code>undefined</code>。</p>
<p>这样是正确的（对象点方法）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">user.hi();</span><br></pre></td></tr></table></figure>
<p>这样没有效果（对方法求值）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(user.name == <span class="string">"John"</span> ? user.hi : user.bye)(); <span class="comment">// 错误！</span></span><br></pre></td></tr></table></figure>
<p>原因是什么？如果我们想了解为什么会这样，那么我们要深入理解 <code>obj.method()</code> 调用的原理。</p>
<p>仔细看，我们可能注意到 <code>obj.method()</code> 语句中有两个操作符。</p>
<ol>
<li>首先，点 <code>&#39;.&#39;</code> 取得这个 <code>obj.method</code> 属性。</li>
<li>其后的括号 <code>()</code> 调用它。</li>
</ol>
<p>那么，<code>this</code> 是如何从第一部分传递到第二部分的呢？</p>
<p>如果把这些操作分离开，那么 <code>this</code> 肯定会丢失：</p>
<figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name: <span class="string">"John"</span>,</span><br><span class="line">  hi() &#123; alert(<span class="keyword">this</span>.name); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*!*</span><br><span class="line"><span class="comment">// 将赋值与方法调用拆分为两行</span></span><br><span class="line"><span class="keyword">let</span> hi = user.hi;</span><br><span class="line">hi(); <span class="comment">// 错误，因为 this 未定义</span></span><br><span class="line">*<span class="regexp">/!*</span></span><br></pre></td></tr></table></figure>
<p>这里 <code>hi = user.hi</code> 把函数赋值给变量，其后的最后一行是完全独立的，所以它没有 <code>this</code>。</p>
<p><strong>为了让 <code>user.hi()</code> 有效，JavaScript 用一个技巧 —— 这个 <code>&#39;.&#39;</code> 点返回的不是一个函数, 而是一种特殊的[引用类型]的值(<a href="https://tc39.github.io/ecma262/#sec-reference-specification-type" target="_blank" rel="noopener">https://tc39.github.io/ecma262/#sec-reference-specification-type</a>).</strong></p>
<p>引用类型是一种『规范中有的类型』。我们不能明确地指定它，但是可以在语言内部使用。</p>
<p>引用类型的值是三点的结合 <code>(base, name, strict)</code>，如下：</p>
<ul>
<li><code>base</code> 是对象。</li>
<li><code>name</code> 是属性。</li>
<li>当 <code>use strict</code> 生效，<code>strict</code> 为真。</li>
</ul>
<p><code>user.hi</code> 属性访问的值不是函数，而是引用类型的值。在严格模式下，<code>user.hi</code> 是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用类型值</span></span><br><span class="line">(user, <span class="string">"hi"</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>当在引用类型上用 <code>()</code> 调用时，它们接收到这个对象和它的方法的所有信息，并且设定正确的 <code>this</code> 值（这里等于 <code>user</code>）。</p>
<p><code>hi = user.hi</code> 赋值等其他的操作，将引用类型作为一个整体丢弃，只获取 <code>user.hi</code>（一个函数）的值进行传递。因此，进一步操作『失去』了 <code>this</code>（值）。</p>
<p>所以如果直接使用点 <code>obj.method()</code> 或方括号语法 <code>obj[method]()</code>（它们在这里并无差别）调用函数，那么作为结果，<code>this</code> 值会以正确的方式进行传递。</p>
<h2 id="箭头函数没有自己的-“this”"><a href="#箭头函数没有自己的-“this”" class="headerlink" title="箭头函数没有自己的 “this”"></a>箭头函数没有自己的 “this”</h2><p>箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部『正常的』函数。</p>
<p>举个例子，这里的 <code>arrow()</code> 使用的 <code>this</code> 来自外部的 <code>user.sayHi()</code> 方法：</p>
<figure class="highlight js"><figcaption><span>run</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">"Ilya"</span>,</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="keyword">let</span> arrow = <span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="keyword">this</span>.firstName);</span><br><span class="line">    arrow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.sayHi(); <span class="comment">// Ilya</span></span><br></pre></td></tr></table></figure>
<p>这是箭头函数的一个特征，当我们并不想要一个独立的 <code>this</code> 值，反而想从外部上下文中获取时，它很有用。在后面的章节 <info:arrow-functions> 中我们将更深入地介绍箭头函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>存储在对象中函数称之为『方法』。</li>
<li>对象执行方法进行『操作』，比如 <code>object.doSomething()</code>。</li>
<li>方法可以将该对象引用为 <code>this</code>。</li>
</ul>
<p><code>this</code> 的值是在运行时求值的。</p>
<ul>
<li>函数声明使用的 <code>this</code> 只有等到调用时才会有值。</li>
<li>函数可以在对象之间进行共用。</li>
<li>当函数使用『方法』语法 <code>object.method()</code> 调用时，调用过程中的 <code>this</code> 总是指向 <code>object</code>。</li>
</ul>
<p>请注意箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问的都是来自外部的 <code>this</code> 值。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Joker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://meandni.com/2018/09/08/f1a1/">https://meandni.com/2018/09/08/f1a1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%98%85%E8%AF%BB/">阅读</a><a class="post-meta__tags" href="/tags/%E6%8A%80%E6%9C%AF/">技术</a><a class="post-meta__tags" href="/tags/javascript/">javascript</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/10/05/3a4f/"><i class="fa fa-chevron-left">  </i><span>2018.10.5有感！</span></a></div><div class="next-post pull-right"><a href="/2018/09/07/f1a1/"><span>《The Modern Javascript Tutorial》：javascript递归函数的分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '12faa9d04b92d2d70968',
  clientSecret: 'ad1023eebffeb2972301ce0e730e0c277f64cf23',
  repo: 'MeandNi.github.io',
  owner: 'MeandNi',
  admin: 'MeandNi',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Joker</div><div class="framework-info"><span>Driven - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>