<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="解锁 Android 性能优化的五大误区和两大疑点"><meta name="keywords" content="Android,性能优化"><meta name="author" content="Joker"><meta name="copyright" content="Joker"><title>解锁 Android 性能优化的五大误区和两大疑点 | Joker's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#误区1：Kotlin-比-Java-更消耗性能"><span class="toc-number">1.</span> <span class="toc-text">误区1：Kotlin 比 Java 更消耗性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#误区二：Getters-and-setters-更耗时"><span class="toc-number">2.</span> <span class="toc-text">误区二：Getters and setters 更耗时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#误区三：Lambda-比内部类慢"><span class="toc-number">3.</span> <span class="toc-text">误区三：Lambda 比内部类慢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#误区四：对象分配开销过大，应该使用对象池"><span class="toc-number">4.</span> <span class="toc-text">误区四：对象分配开销过大，应该使用对象池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#误区五：debug-模式下进行性能分析"><span class="toc-number">5.</span> <span class="toc-text">误区五：debug 模式下进行性能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#疑点"><span class="toc-number"></span> <span class="toc-text">疑点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#疑点1：Multidex：是否影响应用性能？"><span class="toc-number">1.</span> <span class="toc-text">疑点1：Multidex：是否影响应用性能？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#疑点2：无用代码"><span class="toc-number">2.</span> <span class="toc-text">疑点2：无用代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number"></span> <span class="toc-text">总结</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Joker</div><div class="author-info__description text-center">分享生活感悟、技术、学习心得</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">44</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">40</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-1*6sptV9J5Q2xTsG-Y9xZppw-20201015221149205.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Joker's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">解锁 Android 性能优化的五大误区和两大疑点</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>本文翻译自：<a href="https://medium.com/flutter/performance-testing-on-the-web-25323252de69" target="_blank" rel="noopener">Busting Android performance myths</a>，作者：Calin Juravle，译文首次发表于微信公众号「Mending」</p>
</blockquote>
<p>近年来，社区充斥着关于 Android 性能的各种误区，本文本着<strong>误区终结者</strong>的精神，使用具体的性能检测工具，结合真实案例仔细分析这些情况，并对比它们的测试结果。本文也会聚焦 Android 开发者平时在编码过程的实际场景，用实际数据告诉你<strong>在实际编码之前请，一定要进行必要的性能检测</strong>。</p>
<h4 id="误区1：Kotlin-比-Java-更消耗性能"><a href="#误区1：Kotlin-比-Java-更消耗性能" class="headerlink" title="误区1：Kotlin 比 Java 更消耗性能"></a>误区1：Kotlin 比 Java 更消耗性能</h4><p>Google 云端硬盘团队目前已将其应用程序从 Java 全面替换为 Kotlin，重构范围涉及 170 多个文件，超过 16,000 行代码，包含 40 多个编译产物，在团队监控的指标中，第一要素是启动时间，测试结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*HMsbHNNmEj0q1yrb-20201015223338214.png" alt=""></p>
<p>如图所示，使用 kotlin 并没有对性能造成实质的影响，而且在整个基准测试过程中，Google 团队也都没有观察到性能差异，即使编译时间和编译后的代码大小略有增加，但都保持在 2％ 之内，完全可以忽略不计。而得益于 kotlin，团队的代码行却减少了大约 25％，也变得更清晰和易于维护。</p>
<p>值得一提的是，使用 kotlin 时，我们也可以使用像 R8 这样的代码缩减工具，对代码进行进一步的优化。</p>
<h4 id="误区二：Getters-and-setters-更耗时"><a href="#误区二：Getters-and-setters-更耗时" class="headerlink" title="误区二：Getters and setters 更耗时"></a>误区二：Getters and setters 更耗时</h4><p>因为担心性能下降，有些开发者会选择在类中直接使用 public 修饰字段，而不去写 getter 和 setter 方法，如下面这段代码，这里的 getFoo() 方法就是变量 foo 的 getter 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ToyClass &#123;</span><br><span class="line">   public int foo;</span><br><span class="line">   public int getFoo() &#123; return foo; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ToyClass tc &#x3D; new ToyClass();</span><br></pre></td></tr></table></figure>
<p>直接使用  tc.foo 获取变量显然已经破坏了对象的封装，而在性能方面，我们在配备 Android 10 的 Pixel 3 上使用 <a href="https://developer.android.com/studio/profile/benchmark" target="_blank" rel="noopener">Jetpack Benchmark </a>对 tc.getFoo() 与 tc.foo 两个方法进行了<a href="https://developer.android.com/studio/profile/benchmark" target="_blank" rel="noopener">基准测试</a>，该库提供了预热代码的功能，最终的稳定测试结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*wbkp1A7_V8laRaRS-20201015132144978-20201015223342914.png" alt=""></p>
<p>getter 方法的性能与直接 access 变量的性能也并没有差别，结果并不奇怪，因为 Android RunTime(ART)内联了代码中所有的 getter 方法，因此，在 JIT 或 AOT 编译后执行的代码是相同的，正因如此，在 kotlin 中即使我们默认需要使用 getter 或 setter 获得变量，性能也并不会有所下降，如果使用 Java，除非特殊需要，否则就不应该使用这种方式破坏代码的封装。</p>
<h4 id="误区三：Lambda-比内部类慢"><a href="#误区三：Lambda-比内部类慢" class="headerlink" title="误区三：Lambda 比内部类慢"></a>误区三：Lambda 比内部类慢</h4><p>Lambda（尤其是在引入 Stream API 的情况下）是一种非常方便的语法，可实现非常简洁的代码。如下这段代码，对对象数组的内部字段值求和，这里，使用了 Stream API 搭配 map-reduce 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ToyClass&gt; array = build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = array.stream().map(tc -&gt; tc.foo).reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure>
<p>第一个 lambda 会将对象转换为整数，第二个 lambda 会将产生的两个值相加。</p>
<p>下面代码中，我们再将 lambda 表达式换成内部类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ToyClassToInteger toyClassToInteger &#x3D; new ToyClassToInteger();</span><br><span class="line"></span><br><span class="line">SumOp sumOp &#x3D; new SumOp();</span><br><span class="line"></span><br><span class="line">int sum &#x3D; array.stream().map(toyClassToInteger).reduce(0, sumOp);</span><br></pre></td></tr></table></figure>
<p>这里，有两个内部类：一个是 toyClassToInteger，它可以将对象转换为整数，第二个 SumOp 用来做求和运算。</p>
<p>从语法上看，第一个带有 lambda 的示例显然更优雅，也更易读。那么，性能差异又如何呢？我们再次在 Pixel 3 上使用了Jetpack Benchmark，也没有发现性能差异：</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*UBNsamryvRy8Zgxe-20201015223348768.png" alt=""></p>
<p>从图中可以看到，我们还定义了单独的外部(top-level)类一起来做比较，发现性能都没有什么差异，原因就是 lambda 表达式最终也会被转换为匿名内部类。因此，为了代码的简洁易读，在这种场景下 lambda 表达式就是第一选择。</p>
<h4 id="误区四：对象分配开销过大，应该使用对象池"><a href="#误区四：对象分配开销过大，应该使用对象池" class="headerlink" title="误区四：对象分配开销过大，应该使用对象池"></a>误区四：对象分配开销过大，应该使用对象池</h4><p>Android 内置了最先进的内存分配和垃圾回收机制，如下图所示，几乎每个版本的更新都在对象分配方面做各式各样的更新。</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*RP2kwLn9MbtPg6Ru.png" alt=""></p>
<p>各个版本之间的垃圾收集性能都有显著的改善，如今，垃圾收集对应用程序的流畅已经几乎没有影响了。下图展示了 Google 官方在 Android 10 中对具有分代并发收集的对象收集所做的改进，新版本的 Android 11 中也有明显的改进。</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*2QorsoqRUJj0KhKt.png" alt=""></p>
<p>在GC基准测试（例如H2）中，吞吐量大幅提高了 170％ 以上，而在实际应用（如 Google Sheets）中，吞吐量也提高了 68％。</p>
<p>如果认为垃圾收集效率低下并且内存分配负担很重，那么就相当于认为创建的垃圾越少，垃圾收集工作就越少，因此，代替每次使用时都创建新对象，我们可以维护一个经常使用的类型的对象池，然后从那里获取对象，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pool&lt;A&gt; pool[] &#x3D; new Pool&lt;&gt;[50];</span><br><span class="line"></span><br><span class="line">void foo() &#123;</span><br><span class="line">   A a &#x3D; pool.acquire();</span><br><span class="line">   …</span><br><span class="line">   pool.release(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里省略了代码细节，大体就是就是定义了一个 pool，从 pool 中获取对象，然后最终释放。</p>
<p>要测试这种场景，我们使用微基准测试(microbenchmark)：从池中测试分配对象的开销，以及CPU的开销，来确定垃圾回收是否会影响应用程序的性能。</p>
<p>在这种情况下，我们在装有 Android 10 的 Pixel 2 XL 上循环运行了数千次分配对象的代码，因为对于小型或大型对象，性能可能会有所不同，我们还通过添加不同的字段来模拟不同的对象大小，最终的开销结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*Uo_w_LzYAUiFrvax-20201015223358709.png" alt=""></p>
<p>用于垃圾回收的 CPU 开销的结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-2020-10-15-0*UW6KyFWPOYpz7-xd.png" alt=""></p>
<p>从图中可以看出，标准分配和池化对象之间的差异也很小，但是，当涉及到较大对象的垃圾回收时，池解决方案略微高一点。</p>
<p>这个结果并不意外，因为池化对象会增加应用的内存占用量，此时，应用突然占用了太多的内存，即使由于池化对象减少了垃圾回收调用的数量，每个垃圾回收调用的成本也更高，因为垃圾收集器必须遍历更多的内存才能确定哪些对象需要被收集，哪些对象需要保留。</p>
<p>那么，对象是否应该被池化，这还是主要取决于应用的需求。如果不考虑到代码复杂性，池化对象有如下缺点：</p>
<ul>
<li>提高内存占用量</li>
<li>使对象存活变长</li>
<li>需要非常完善的对象池机制</li>
</ul>
<p>但是，池的方法对于大并且耗时的对象分配可能确实是有效的，关键是要记住在选择方案之前进行充分的测试。</p>
<h4 id="误区五：debug-模式下进行性能分析"><a href="#误区五：debug-模式下进行性能分析" class="headerlink" title="误区五：debug 模式下进行性能分析"></a>误区五：debug 模式下进行性能分析</h4><p>在 debug 的同时对应用进行性能分析非常方便，毕竟，我们通常也是在 debug 模式下进行编码的，并且，即使 debug 应用中的性能分析不准确，也可以更快地进行迭代修改提高效率，<strong>然后事实是并没有</strong>。</p>
<p>为了验证这一误解，我们分析了 Activity 相关的常见操作过程过的测试结果，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*G3DDVYBx8-XegSHS-20201015132148928.png" alt=""></p>
<p>在某些测试（例如反序列化）中，debug 与否对性能没有影响，但是，有些结果却有 50％ 甚至以上的差别，我们甚至发现结果速度可能会慢 100％ 的例子，这是因为 runtime 在 debug 模式下时对代码几乎没有优化，因此与用户在生产设备上运行的代码有很大不同。</p>
<p>在 debug 模式下进行性能分析的结果是可能会误导优化方向，导致浪费时间来优化不需要优化的内容。</p>
<h3 id="疑点"><a href="#疑点" class="headerlink" title="疑点"></a>疑点</h3><p>现在，我们需要有意识的逃避上述提到的五大误区，下面我们再来看一下一些日常开发中不太明显，但我们经常会有的疑惑的问题，事实结果可能也与我们想的大相径庭。</p>
<h4 id="疑点1：Multidex：是否影响应用性能？"><a href="#疑点1：Multidex：是否影响应用性能？" class="headerlink" title="疑点1：Multidex：是否影响应用性能？"></a>疑点1：Multidex：是否影响应用性能？</h4><p>如今的 APK 文件越来越大，因为大型应用通常会超出 Android 限定的方法数量，从而使用 Multidex 方案如破传统的 dex 规范。</p>
<p>问题是，多少方法可以称之为多？而且如果应用包含大量 dex 是否对性能产生影响？很多时候我们也并不是因为应用太大，而是为了根据功能拆分 dex 文件来方便团队开发而使用 Multidex。</p>
<p>为了测试多个 dex 文件对性能的影响，我们使用了计算器应用，默认情况下，它只包含单个 dex 文件，我们可以根据其程序包边界将其拆分为五个 dex 文件，来根据功能部件模拟拆分。</p>
<p>首先，测试启动应用的性能，结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*trjzpDOQpLbgFNvV.png" alt=""></p>
<p>因此，拆分 dex 文件对此处并没有影响，对于其他应用，可能会因为某些因素而产生轻微的开销：应用程序的大小以及拆分方式。但是，只要合理地分割 dex 文件并且不添加成百个 dex 文件，对启动时间的影响应该不大。</p>
<p>接下来是 APK 的大小和内存消耗：</p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/uPic/0*0-61ZDBsfpeWqsS6-20201015132150431.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-0*fgW2o3w1ftMuFXKu.png" alt=""></p>
<p>如图所示，APK 大小和应用的运行时内存占用量都略有增加，这是因为将应用程序拆分为多个 dex 文件时，每个 dex 文件都会有一些符号表和缓存表中的重复数据。</p>
<p>但是，我们可以通过减少 dex 文件之间的依赖关系来最大限度地避免这种情况，在这个案例中，并没有将 dex 包量化，我们可以使用 R8 和 D8 之类的工具合理分析项目结构并使用最小化的依赖关系，这些工具可以自动拆分 dex 文件，并帮助我们避免常见的错误，最大程度地减少依赖关系，如创建的 dex 文件数量不会超过指定的数量，并且不会将所有启动类都放置在主文件中。但是，如果我们对 dex 文件进行自定义拆分，请确保合理分析。</p>
<h4 id="疑点2：无用代码"><a href="#疑点2：无用代码" class="headerlink" title="疑点2：无用代码"></a>疑点2：无用代码</h4><p>使用 ART 这样的即使编译器的好处之一就是可以再运行时分析代码，并对其进行优化。有一种说法是，如果解释器/ JIT系统没有对代码进行概要分析，就可能不会执行该代码。为了验证这一理论，我们检查了 Google 应用生成的 ART 配置文件，发现许多代码并没有被 JIT 做概要分析，这就表明许多代码实际上从未在设备上执行过。</p>
<p>有几种类型的代码可能无法剖析：</p>
<ul>
<li>错误处理代码，希望它不会执行太多。</li>
<li>兼容性代码，并非在所有设备上都执行的代码，尤其是 Android 5 以上版本的设备。</li>
<li>不常用功能的代码。</li>
</ul>
<p>但是，从结果分布来看，应用程序中还是会存在很多不必要的代码。R8 可以帮助我们快速，简便，免费地删除不必要的代码，来缩小这部分的开销。如果不这么做，我们也可以将应用打包成 <a href="https://developer.android.com/guide/app-bundle" target="_blank" rel="noopener">Android App Bundle</a>，这种格式只会使用特定设备所需的代码和资源来运行应用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文，我们自己分析了 Android 性能优化的多个误区，但某些情况下数据的结果还并不清晰，我们需要做的就是在优化和修改代码之前尽量做好性能测试。</p>
<p>目前，已经有很多工具可以帮助我们分析评估如何优化应用了，如 Android Studio 中的 profilers，它也提供了电池和网络的监测功能。也可以用一些工具做更深入的探究，如 Perfetto 和 Systrace，这些工具会提供更加详细的功能，例如在应用启动或执行过程中发生的具体情况。</p>
<p>Jetpack Benchmark 摒弃了监测和基准测试的所有复杂操作，官方强烈建议我们在持续集成系统中使用它来跟踪性能，并查看应用在添加功能的行为，最后需要注意的一点是，不要在 debug 模式下分析应用性能。</p>
<p><strong>关注公众号「Meandni」，及时阅读最新技术动态。</strong></p>
<p><img src="/images/qrcode_for_small.jpg" alt="扫一扫，Meandni"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Joker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://meandni.com/2020/10/15/busting-android-performance-myths/">https://meandni.com/2020/10/15/busting-android-performance-myths/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://meandni.com">Joker's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5ebb714f13e60e34" async></script><nav id="pagination"><div class="next-post pull-right"><a href="/2020/10/11/performance-testing-on-the-web/"><span>在 Chrome 中测试 Flutter Web 应用性能</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '12faa9d04b92d2d70968',
  clientSecret: 'ad1023eebffeb2972301ce0e730e0c277f64cf23',
  repo: 'MeandNi.github.io',
  owner: 'MeandNi',
  admin: 'MeandNi',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/meandni/blogimg@main/img/2020-10-15-1*6sptV9J5Q2xTsG-Y9xZppw-20201015221149205.png)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Joker</div><div class="framework-info"><span>驱动 - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>