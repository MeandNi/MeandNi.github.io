<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Linux 容器化技术详解（虚拟化、容器化、Docker）"><meta name="keywords" content="Linux,容器化,虚拟化,Docker"><meta name="author" content="Joker"><meta name="copyright" content="Joker"><title>Linux 容器化技术详解（虚拟化、容器化、Docker） | Joker's Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="/css/iconfont.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟化技术"><span class="toc-number">1.</span> <span class="toc-text">虚拟化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟化的工作原理"><span class="toc-number">1.1.</span> <span class="toc-text">虚拟化的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟化技术应用"><span class="toc-number">1.2.</span> <span class="toc-text">虚拟化技术应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器化技术"><span class="toc-number">2.</span> <span class="toc-text">容器化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#容器化技术应用"><span class="toc-number">2.1.</span> <span class="toc-text">容器化技术应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器化技术规范化"><span class="toc-number">2.2.</span> <span class="toc-text">容器化技术规范化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker"><span class="toc-number">2.3.</span> <span class="toc-text">Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-实战"><span class="toc-number">2.4.</span> <span class="toc-text">Docker 实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章以及衍生阅读"><span class="toc-number">3.</span> <span class="toc-text">参考文章以及衍生阅读</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Joker</div><div class="author-info__description text-center">分享生活感悟、技术、学习心得</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">40</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">38</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/virtualization-vs-containers.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Joker's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">目录</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Linux 容器化技术详解（虚拟化、容器化、Docker）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-05-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA/">深入理解计算机</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p>容器化技术自前几年火热发展后一直都是业内非常热门的话题，为了拓展自己的知识面当然也要学起来，本篇文章从发展的角度来解释了它的前世今生，并将它与传统虚拟化技术做对比，并分析他们各自的运行原理。</p>
</blockquote>
<h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>虚拟化是过去用来充分利用计算机物理资源的最常用方法。早年间，我们可以用一台服务器运行一个操作系统，处理一个任务，带来的问题是资源利用率极其不足，计算机的潜能并不能完全发挥，而后多道批处理系统、分时系统相继出现，Unix、Linux 等操作系统成为了人类 “压榨” 计算机物理资源的神兵利器，而此时，虚拟化技术却并未崭露头角。</p>
<p>目光聚焦到 20 世纪的 90 年代，当时 IT 行业逐渐步入工业化，大量公司部署起了自己内部的 IT 环境，他们使用了多个不同供应商提供的价格相对低廉的服务器、操作系统和应用程序，此时就暴露出了一个严重的问题：大多数企业使用的都是物理服务器或者由单家供应商提供的应用，每台服务器又只能运行一个供应商特定的任务，不同供应商之间硬件也并不兼容，如果这时候再各自为他们配备不同的硬件设备必然也会面临物理硬件利用率不足的问题。此时虚拟化技术才得以大展身手，它主要解决了<strong>可对服务器分区</strong>、<strong>可在同一个主机上运行不同环境的应用</strong>两个主要的问题。</p>
<p>自此，服务器开始得到更高效利用，也降低了企业采购、设置、散热和维护的成本。虚拟化的广泛应用也有助于减少企业对单家供应商的依赖，并为后来云计算的发展奠定了基础。</p>
<h3 id="虚拟化的工作原理"><a href="#虚拟化的工作原理" class="headerlink" title="虚拟化的工作原理"></a>虚拟化的工作原理</h3><p>虚拟化技术的实现主要依托于 <strong>Hypervisor （虚拟机监控程序）</strong>。它处于计算机物理层与虚拟机之间，能够有效地管理计算机的物理资源并将这些资源分配给不同虚拟环境。作为软件，Hypervisor 可以直接运行在操作系统之上；作为服务器，它也可以直接安装在硬件上，这就是大多数企业使用虚拟化的方式。</p>
<p>此时，Hypervisor 直接接管物理资源，可以对它们做分区处理，分配给了多个虚拟机使用，而用户在虚拟机中也可以通过它直接和计算机底层交互。当虚拟机运行时，如果用户的程序发出一条硬件指令请求资源，Hypervisor 就会直接将请求传递到物理系统做缓存更改，所有这些操作速度都和本机运行速度几近相同，这种直接运行在物理硬件中的 Hypervisor 即为我们经常听说的 <strong>Type1</strong>，也称为裸机管理程序（Metal Hypervisor），目前市面上常用的 VMware ESXi、MiscroSoft Hyper-V 和 KVM（Kernel-based Virtual Machine）都基于这类 Hypervisor。</p>
<p><img src="/images/TYPE1.jpg" alt="Hypervisor Type1"></p>
<p>而另一种运行于操作系统之上的 Hypervisor 即为 <strong>Type2</strong>，这种命名方式非常简单粗暴，让人很难忘记，它的处理方式就是使 Hypervisor 不直接与物理层基础，因此也称作托管程序（Hosted Hypervisor），它主要用于面向个体用户，我们经常在本机中安装的 Virtual Box、VMware WorkStation 就属于这种类型。此时，相较于 Type1 ，Type2 显然多了一些延迟。</p>
<p><img src="/images/type-2-1024x499.jpg" alt="Hypervisor Type2"></p>
<p>这样，每个虚拟机在 Hypervisor 之上相互独立，运行不同的操作系统，操作不同的物理资源，这也带来了我们期望了灵活性和可移植性，我们可以将一个虚拟机从一个 Hypervisor 中直接迁移到一个新的 Hypervisor 中，此时就达到了一种<strong>环境复用</strong>的效果。</p>
<p><img src="/images/how-virtualization-works-400x217.png" alt="虚拟化技术原理"></p>
<h3 id="虚拟化技术应用"><a href="#虚拟化技术应用" class="headerlink" title="虚拟化技术应用"></a>虚拟化技术应用</h3><p>虚拟化发展之初主要用于服务器虚拟化，但随着这种方式逐渐普及，也衍生出了许多诸如网络虚拟化，应用程序虚拟化，数据虚拟化以及存储虚拟化等技术。本篇文章就不对他们再做一一介绍了，感兴趣的读者可以查阅底部衍生查阅中的相关资料。</p>
<h2 id="容器化技术"><a href="#容器化技术" class="headerlink" title="容器化技术"></a>容器化技术</h2><p>此时，既然虚拟化技术已经成熟，我们就可以投入生产将它运用起来了，如果希望将自己开发的一个 NodeJs 程序放入虚拟机中，就需要在宿主系统中基于 Hypervisor 安装一个 Linux 虚拟机（单独安装 Linux OS），并在 Linux 中为该服务配置一个完整的 JS 应用运行环境和必要的库，如下图所示。</p>
<p><img src="/images/vm_js.jpg" alt=""></p>
<p>这样做带来的问题也明显，NodeJS 运行时需要的资源可能非常少（10M），而虚拟机本身却占有相当多的资源（&gt;400M），如果继续在该服务器中放入更多的服务，资源消耗程度可见一般，服务器迅速过载。</p>
<p><img src="/images/vm_js_2.jpg" alt=""></p>
<p>从这方面来看，虚拟化技术虽然做到了在同一宿主系统提供不同的任务，解决了硬件层面的硬件资源共享问题，但在应用上层的资源消耗却仍是一个非常大的难题。同时，在日常开发中，如果我们使用的是自己的个人电脑，像 Macbook 开发应用程序时推入服务端也可能存在其他兼容性问题，通常是表现为我的应用程序在本地运行良好，投入生产环境后却病态百出，不利于 DevOps、持续集成和交付。</p>
<p>容器化通过将应用程序代码和运行所需的相关配置文件，库和依赖项捆绑起来解决了上面描述的两个问题。此时，应用程序和其他依赖项俨然成为了一个整体，打包在一个文件中，而运行这个文件就会生成一个虚拟容器，程序在这个封闭的虚拟容器里运行，容器提供了它想要的一切资源，就好像在真实的物理机上运行一样。有了容器，再也不用担心环境问题了。另外，如下图所示，容器也不会捆绑应用环境所依赖的操作系统，轻量级不言而喻。</p>
<p><img src="/images/container_js.jpg" alt=""></p>
<p>要达到应用程序容器化通常只需三步，首先，定义一个清单文件（如 Docker 中的 Dockerfile 或者 Cloud Fundary 中的 yaml 文件），然后，创建一个镜像文件（如 Docker Image 或者 Rocket 的 ACI），最后生成容器即可，这里就包含了应用运行时所有需要的库、二进制文件等等，在上面的例子中，我们同样可以通过该种方式获得 NodeJS 程序的容器并将放入宿主系统中。</p>
<p><img src="/images/Containerization.jpg" alt="容器化三大步骤"></p>
<p>此时，容器化技术也可以摒弃冗余的资源消耗，实现更加轻量级的环境部署。另外，再考虑一个问题，如果在我们的 Nodejs 应用中还需要应用其他环境的库，如需要 python 应用做图像识别、java 应用做数据处理，那么，如果使用虚拟化技术，为了达到云原生的方式就必须在之前的宿主主机中释放出一些资源，然后再将 python 等应用部署进去，而当使用容器化技术时只需要在原服务器中放入一个 python 应用的副本，然后利用剩余的空闲资源做容器之间的共存，这正是容器化技术的伟大之处，它可以实现<strong>容器间隔离的同时做到 CPU 资源共享</strong>。</p>
<p><img src="/images/container_js_2.jpg" alt=""></p>
<p>此时，容器引擎（如 Docker 引擎）安装在宿主系统中可以成为所有容器共享同一操作系统资源的渠道。</p>
<blockquote>
<p>Linux 容器是我们开发、部署和管理应用方式的又一次飞跃。Linux 容器镜像提供了可移植性和版本控制，确保能够在开发人员的笔记本电脑上运行的应用，同样也能在生产环境中正常运行。相较于虚拟机，Linux 容器在运行时所占用的资源更少，使用的是标准化接口（启动、停止、环境变量等），并会与其他应用隔离。此外，作为（包含多个容器）大型应用的一部分时，容器也更易于管理。</p>
</blockquote>
<h3 id="容器化技术应用"><a href="#容器化技术应用" class="headerlink" title="容器化技术应用"></a>容器化技术应用</h3><p>容器化技术日益发展，尤其是在云环境中，许多企业已经在考虑将容器替代虚拟机作为他们应用的通用计算平台了，在其如此广泛的应用，如下几个最为典型：</p>
<ul>
<li>微服务：容器小巧轻量，非常适合微服务体系结构，在微体系结构中，应用程序可以由许多松散耦合且可独立部署的较小服务构成。</li>
<li>DevOps：微服务作为架构和容器与平台的结合，可作为许多团队将 DevOps 视为构建，交付和运行软件的方式的共同基础。</li>
<li>混合云（hybrid cloud）、多云方案（multi-cloud）：由于容器可以在笔记本电脑，本地和云环境中的任何地方运行，因此它是混合云和多云方案的理想基础架构，在这种情况下，企业可以在多个公有云中与数据中心交互。 </li>
<li>应用程序现代化迁移：容器化可以使应用程序现代化，并直接迁移到云中。</li>
</ul>
<h3 id="容器化技术规范化"><a href="#容器化技术规范化" class="headerlink" title="容器化技术规范化"></a>容器化技术规范化</h3><p>随着容器化技术的不断发展，对容器技术和打包软件代码方法的标准化需求也逐渐显现出来了，2015 年 6 月，Docker 和其他行业推动者成立了开放容器计划（OCI），目的就是为了促进容器技术的通用，轻量，开放标准以及规范化，用户也将不会再被特定厂商的技术所束缚，而可以利用 OCI 认证的技术，这些技术使用户能够使用多种 DevOps 工具构建容器化的应用程序，并在基础架构上以一致地标准流程运行这些应用程序。</p>
<p>目前，Docker 是应用最广泛的容器引擎技术之一，但它也并不是我们唯一的选择，社区也正在对容器化和其他替代方案（例如 CoreOS rkt，Mesos Containerizer，LXC Linux 容器，OpenVZ 和 crio-d 等等）进行标准化。虽然现在，他们的功能和默认设置可能会有所不同，但是随着不断规范化地发展，利用 OCI 规范就能确保解决方案与特定供应商无关，可以完全在多种环境中使用部署应用。</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 技术使用的是 Linux 内核和其相关功能（例如 Cgroups 和 namespaces）来分隔进程，达到各进程相互独立运行。这种独立性正是采用容器的意义所在，它可以独立运行多种进程、多个应用，更加充分地利用基础资源，同时保持各个独立系统的安全性。</p>
<p>此外。Docker 技术与传统的 Linux 容器也并不完全相同，最初它是基于 <a href="https://linuxcontainers.org/" target="_blank" rel="noopener">LXC</a>（LinuX Containers，Linux 容器） 技术构建，但后来它逐渐摆脱了对这种技术的依赖。与虚拟化相比较，LXC 确实独占鳌头，但它并不能提供良好的用户体验，这一点，Docker 显然更胜一筹，除了运行容器之外，Docker 技术也具备其他多项功能，包括简化用于构建容器、传输镜像以及控制镜像版本的流程等等。</p>
<p>传统的 Linux 容器使用 init 系统来管理多种进程，这使得所有应用都作为一个整体运行在不同的环境中，而 Docker 技术正与此相反，它力争让应用各自独立运行在进程中，并提供相应工具，帮助实现这一功能，这种精细化运作模式自有其优势。</p>
<h3 id="Docker-实战"><a href="#Docker-实战" class="headerlink" title="Docker 实战"></a>Docker 实战</h3><p>Docker 在各平台安装请参考<a href="https://docs.docker.com/desktop/" target="_blank" rel="noopener">官方文档</a>，安装之后终端执行下面这条命令可以验证是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version</span></span><br></pre></td></tr></table></figure>
<p>Docker 把应用程序及其依赖都打包在 image 文件里面，通过这个文件就能生成 Docker 容器。执行下面这条指令可以列出本机的所有 image 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br></pre></td></tr></table></figure>
<p>如果是第一次运行 Docker，可以执行下面这条命令启动一个 nginx 服务器测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 80:80 --name myserver nginx</span></span><br></pre></td></tr></table></figure>
<p>这条命令执行完之后，由于这是第一次运行，并且 nginx 镜像还没有下载到本地，因此 Docker 会自动从 Docker Hub 库中拉去该镜像，如果命令成功完成，此时在本地访问 <a href="http:// localhost">http:// localhost</a> 后就可以查看道 nginx 服务器的主页了。</p>
<p>下面我来以使用 Docker 安装 Hadoop 环境演示 Docker 具体使用的方法。要将 Hadoop 安装在 Docker 容器中，首先就需要一个 Hadoop Docker 镜像，要想生成镜像，我们可以使用 Github 中的 docker-hadoop 镜像库，执行如下命令拉取该仓库中的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/big-data-europe/docker-hadoop.git</span></span><br></pre></td></tr></table></figure>
<p>docker-hadoop 镜像中就含有生成镜像的清单文件 Makefile，此时，执行下面这条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker-compose up -d</span></span><br></pre></td></tr></table></figure>
<p>docker-Compose 可以用来同时安装多个容器。 -d 参数作用是后台运行命令程序并返回命令提示符。仅使用上面的一条命令，就可以设置一个 Hadoop 集群了。</p>
<p>如果镜像在本地不可用，docker-compose 也会尝试从 docker-hub 库中拉去远程镜像，构建镜像并启动容器。 完成后，就可以使用以下命令来检查当前正在运行的容器了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br></pre></td></tr></table></figure>
<p>进入 <a href="http:// localhost:9870">http:// localhost:9870</a> 就可以从名称节点查看系统的当前状态了。</p>
<p>当然，除了使用这种方法使用别人在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">docker-hub</a> 或者 Github  开源的镜像，我们也可以自定义镜像，这种方式本篇文章先不做讨论。本篇到这里先结束了，看完后关于虚拟化和容器的概念你是不是都掌握了？大家有任何问题可直接联系我，也可在博客评论区讨论。</p>
<h2 id="参考文章以及衍生阅读"><a href="#参考文章以及衍生阅读" class="headerlink" title="参考文章以及衍生阅读"></a>参考文章以及衍生阅读</h2><p><a href="https://www.redhat.com/en/topics/virtualization/what-is-virtualization" target="_blank" rel="noopener">RED-HAT-what-is-virtualization</a></p>
<p><a href="https://www.redhat.com/en/topics/containers/whats-a-linux-container" target="_blank" rel="noopener">RED-HAT-What’s a Linux container?</a></p>
<p><a href="https://opensource.com/article/18/1/history-low-level-container-runtimes" target="_blank" rel="noopener">A history of low-level Linux container runtimes</a></p>
<p><a href="https://www.redhat.com/zh/topics/virtualization/what-is-KVM" target="_blank" rel="noopener">RED-HAT-what-is-KVM</a></p>
<p><a href="https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/" target="_blank" rel="noopener">Docker 背后的内核知识——cgroups 资源限制</a></p>
<p>部分图片来自：<a href="https://blog.resellerclub.com/what-is-virtualization-and-how-does-it-work/" target="_blank" rel="noopener">what-is-virtualization-and-how-does-it-work</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Joker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://meandni.com/2020/05/14/virtualization-containerization-docker/">https://meandni.com/2020/05/14/virtualization-containerization-docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://meandni.com">Joker's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E5%AE%B9%E5%99%A8%E5%8C%96/">容器化</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/">虚拟化</a><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5ebb714f13e60e34" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/09/28/d206/"><i class="fa fa-chevron-left">  </i><span>全方位剖析 Flutter Windows 内测版。</span></a></div><div class="next-post pull-right"><a href="/2020/05/12/3619/"><span>深入理解字符编码（ASCII、Unicode、UTF-8、UTF-16、UTF-32）</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '12faa9d04b92d2d70968',
  clientSecret: 'ad1023eebffeb2972301ce0e730e0c277f64cf23',
  repo: 'MeandNi.github.io',
  owner: 'MeandNi',
  admin: 'MeandNi',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/images/virtualization-vs-containers.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Joker</div><div class="framework-info"><span>驱动 - </span><a href="#"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>